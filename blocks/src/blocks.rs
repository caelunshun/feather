//! This file was generated by /generators/blocks
use feather_codegen::{FromSnakeCase, ToSnakeCase};
use num_traits::FromPrimitive;
use std::collections::HashMap;
const INTERNAL_ID_OFFSETS: [usize; 598usize] = [
    0usize, 1usize, 2usize, 3usize, 4usize, 5usize, 6usize, 7usize, 8usize, 10usize, 11usize,
    12usize, 14usize, 15usize, 16usize, 17usize, 18usize, 19usize, 20usize, 21usize, 23usize,
    25usize, 27usize, 29usize, 31usize, 33usize, 34usize, 50usize, 66usize, 67usize, 68usize,
    69usize, 70usize, 71usize, 72usize, 75usize, 78usize, 81usize, 84usize, 87usize, 90usize,
    93usize, 96usize, 99usize, 102usize, 105usize, 108usize, 111usize, 114usize, 117usize,
    120usize, 123usize, 126usize, 129usize, 132usize, 135usize, 138usize, 141usize, 144usize,
    158usize, 172usize, 186usize, 200usize, 214usize, 228usize, 229usize, 230usize, 231usize,
    232usize, 233usize, 245usize, 246usize, 247usize, 248usize, 748usize, 764usize, 780usize,
    796usize, 812usize, 828usize, 844usize, 860usize, 876usize, 892usize, 908usize, 924usize,
    940usize, 956usize, 972usize, 988usize, 1004usize, 1016usize, 1028usize, 1040usize, 1041usize,
    1042usize, 1043usize, 1044usize, 1045usize, 1047usize, 1059usize, 1083usize, 1084usize,
    1085usize, 1086usize, 1087usize, 1088usize, 1089usize, 1090usize, 1091usize, 1092usize,
    1093usize, 1094usize, 1095usize, 1096usize, 1097usize, 1098usize, 1099usize, 1111usize,
    1112usize, 1113usize, 1114usize, 1115usize, 1116usize, 1117usize, 1118usize, 1119usize,
    1120usize, 1121usize, 1122usize, 1123usize, 1124usize, 1125usize, 1126usize, 1128usize,
    1129usize, 1130usize, 1131usize, 1132usize, 1136usize, 1648usize, 1649usize, 1729usize,
    1753usize, 3049usize, 3050usize, 3051usize, 3052usize, 3060usize, 3068usize, 3076usize,
    3108usize, 3172usize, 3180usize, 3190usize, 3270usize, 3278usize, 3302usize, 3304usize,
    3368usize, 3370usize, 3372usize, 3374usize, 3376usize, 3378usize, 3380usize, 3382usize,
    3384usize, 3392usize, 3416usize, 3424usize, 3425usize, 3426usize, 3442usize, 3443usize,
    3459usize, 3461usize, 3493usize, 3494usize, 3495usize, 3496usize, 3497usize, 3499usize,
    3503usize, 3507usize, 3514usize, 3578usize, 3579usize, 3580usize, 3581usize, 3582usize,
    3583usize, 3584usize, 3585usize, 3586usize, 3587usize, 3588usize, 3589usize, 3590usize,
    3591usize, 3592usize, 3593usize, 3594usize, 3658usize, 3722usize, 3786usize, 3850usize,
    3914usize, 3978usize, 3979usize, 3980usize, 3981usize, 3982usize, 3983usize, 3984usize,
    3985usize, 3986usize, 3987usize, 3988usize, 4052usize, 4116usize, 4180usize, 4212usize,
    4244usize, 4245usize, 4249usize, 4253usize, 4261usize, 4269usize, 4301usize, 4333usize,
    4413usize, 4493usize, 4495usize, 4496usize, 4497usize, 4529usize, 4609usize, 4613usize,
    4614usize, 4622usize, 4626usize, 4627usize, 4635usize, 4636usize, 4637usize, 4639usize,
    4651usize, 4731usize, 4732usize, 4740usize, 4756usize, 4884usize, 4885usize, 4965usize,
    5045usize, 5125usize, 5137usize, 5138usize, 5202usize, 5266usize, 5267usize, 5268usize,
    5269usize, 5270usize, 5271usize, 5272usize, 5273usize, 5274usize, 5275usize, 5276usize,
    5277usize, 5278usize, 5279usize, 5280usize, 5281usize, 5282usize, 5283usize, 5284usize,
    5285usize, 5286usize, 5287usize, 5288usize, 5296usize, 5304usize, 5328usize, 5352usize,
    5376usize, 5400usize, 5424usize, 5448usize, 5452usize, 5468usize, 5472usize, 5488usize,
    5492usize, 5508usize, 5512usize, 5528usize, 5532usize, 5548usize, 5552usize, 5568usize,
    5572usize, 5576usize, 5580usize, 5604usize, 5620usize, 5636usize, 5652usize, 5684usize,
    5685usize, 5686usize, 5696usize, 5697usize, 5698usize, 5701usize, 5781usize, 5793usize,
    5805usize, 5806usize, 5807usize, 5808usize, 5809usize, 5810usize, 5811usize, 5812usize,
    5813usize, 5814usize, 5815usize, 5816usize, 5817usize, 5818usize, 5819usize, 5820usize,
    5821usize, 5853usize, 5885usize, 5917usize, 5949usize, 5981usize, 6013usize, 6045usize,
    6077usize, 6109usize, 6141usize, 6173usize, 6205usize, 6237usize, 6269usize, 6301usize,
    6333usize, 6413usize, 6493usize, 6494usize, 6495usize, 6559usize, 6560usize, 6561usize,
    6562usize, 6642usize, 6722usize, 6802usize, 6808usize, 6814usize, 6820usize, 6821usize,
    6824usize, 6825usize, 6826usize, 6827usize, 6828usize, 6829usize, 6830usize, 6831usize,
    6832usize, 6833usize, 6834usize, 6835usize, 6836usize, 6837usize, 6838usize, 6839usize,
    6840usize, 6841usize, 6842usize, 6843usize, 6845usize, 6847usize, 6849usize, 6851usize,
    6853usize, 6855usize, 6871usize, 6887usize, 6903usize, 6919usize, 6935usize, 6951usize,
    6967usize, 6983usize, 6999usize, 7015usize, 7031usize, 7047usize, 7063usize, 7079usize,
    7095usize, 7111usize, 7115usize, 7119usize, 7123usize, 7127usize, 7131usize, 7135usize,
    7139usize, 7143usize, 7147usize, 7151usize, 7155usize, 7159usize, 7163usize, 7167usize,
    7171usize, 7175usize, 7176usize, 7177usize, 7178usize, 7258usize, 7264usize, 7270usize,
    7276usize, 7282usize, 7288usize, 7294usize, 7300usize, 7306usize, 7312usize, 7318usize,
    7324usize, 7330usize, 7336usize, 7342usize, 7348usize, 7354usize, 7355usize, 7356usize,
    7357usize, 7358usize, 7390usize, 7422usize, 7454usize, 7486usize, 7518usize, 7550usize,
    7582usize, 7614usize, 7646usize, 7678usize, 7742usize, 7806usize, 7870usize, 7934usize,
    7998usize, 8004usize, 8068usize, 8074usize, 8075usize, 8078usize, 8158usize, 8159usize,
    8163usize, 8164usize, 8165usize, 8177usize, 8189usize, 8193usize, 8194usize, 8195usize,
    8196usize, 8199usize, 8200usize, 8212usize, 8218usize, 8224usize, 8230usize, 8236usize,
    8242usize, 8248usize, 8254usize, 8260usize, 8266usize, 8272usize, 8278usize, 8284usize,
    8290usize, 8296usize, 8302usize, 8308usize, 8314usize, 8318usize, 8322usize, 8326usize,
    8330usize, 8334usize, 8338usize, 8342usize, 8346usize, 8350usize, 8354usize, 8358usize,
    8362usize, 8366usize, 8370usize, 8374usize, 8378usize, 8379usize, 8380usize, 8381usize,
    8382usize, 8383usize, 8384usize, 8385usize, 8386usize, 8387usize, 8388usize, 8389usize,
    8390usize, 8391usize, 8392usize, 8393usize, 8394usize, 8395usize, 8396usize, 8397usize,
    8398usize, 8399usize, 8400usize, 8401usize, 8402usize, 8403usize, 8404usize, 8405usize,
    8406usize, 8407usize, 8408usize, 8409usize, 8410usize, 8436usize, 8437usize, 8438usize,
    8450usize, 8451usize, 8452usize, 8453usize, 8454usize, 8455usize, 8456usize, 8457usize,
    8458usize, 8459usize, 8460usize, 8462usize, 8464usize, 8466usize, 8468usize, 8470usize,
    8472usize, 8474usize, 8476usize, 8478usize, 8480usize, 8488usize, 8496usize, 8504usize,
    8512usize, 8520usize, 8528usize, 8536usize, 8544usize, 8552usize, 8560usize, 8562usize,
    8564usize, 8566usize, 8568usize, 8570usize, 8572usize, 8574usize, 8576usize, 8578usize,
    8580usize, 8588usize, 8589usize, 8591usize, 8592usize, 8593usize, 8595usize,
];
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum Block {
    Air,
    Stone,
    Granite,
    PolishedGranite,
    Diorite,
    PolishedDiorite,
    Andesite,
    PolishedAndesite,
    GrassBlock(GrassBlockData),
    Dirt,
    CoarseDirt,
    Podzol(PodzolData),
    Cobblestone,
    OakPlanks,
    SprucePlanks,
    BirchPlanks,
    JunglePlanks,
    AcaciaPlanks,
    DarkOakPlanks,
    OakSapling(OakSaplingData),
    SpruceSapling(SpruceSaplingData),
    BirchSapling(BirchSaplingData),
    JungleSapling(JungleSaplingData),
    AcaciaSapling(AcaciaSaplingData),
    DarkOakSapling(DarkOakSaplingData),
    Bedrock,
    Water(WaterData),
    Lava(LavaData),
    Sand,
    RedSand,
    Gravel,
    GoldOre,
    IronOre,
    CoalOre,
    OakLog(OakLogData),
    SpruceLog(SpruceLogData),
    BirchLog(BirchLogData),
    JungleLog(JungleLogData),
    AcaciaLog(AcaciaLogData),
    DarkOakLog(DarkOakLogData),
    StrippedSpruceLog(StrippedSpruceLogData),
    StrippedBirchLog(StrippedBirchLogData),
    StrippedJungleLog(StrippedJungleLogData),
    StrippedAcaciaLog(StrippedAcaciaLogData),
    StrippedDarkOakLog(StrippedDarkOakLogData),
    StrippedOakLog(StrippedOakLogData),
    OakWood(OakWoodData),
    SpruceWood(SpruceWoodData),
    BirchWood(BirchWoodData),
    JungleWood(JungleWoodData),
    AcaciaWood(AcaciaWoodData),
    DarkOakWood(DarkOakWoodData),
    StrippedOakWood(StrippedOakWoodData),
    StrippedSpruceWood(StrippedSpruceWoodData),
    StrippedBirchWood(StrippedBirchWoodData),
    StrippedJungleWood(StrippedJungleWoodData),
    StrippedAcaciaWood(StrippedAcaciaWoodData),
    StrippedDarkOakWood(StrippedDarkOakWoodData),
    OakLeaves(OakLeavesData),
    SpruceLeaves(SpruceLeavesData),
    BirchLeaves(BirchLeavesData),
    JungleLeaves(JungleLeavesData),
    AcaciaLeaves(AcaciaLeavesData),
    DarkOakLeaves(DarkOakLeavesData),
    Sponge,
    WetSponge,
    Glass,
    LapisOre,
    LapisBlock,
    Dispenser(DispenserData),
    Sandstone,
    ChiseledSandstone,
    CutSandstone,
    NoteBlock(NoteBlockData),
    WhiteBed(WhiteBedData),
    OrangeBed(OrangeBedData),
    MagentaBed(MagentaBedData),
    LightBlueBed(LightBlueBedData),
    YellowBed(YellowBedData),
    LimeBed(LimeBedData),
    PinkBed(PinkBedData),
    GrayBed(GrayBedData),
    LightGrayBed(LightGrayBedData),
    CyanBed(CyanBedData),
    PurpleBed(PurpleBedData),
    BlueBed(BlueBedData),
    BrownBed(BrownBedData),
    GreenBed(GreenBedData),
    RedBed(RedBedData),
    BlackBed(BlackBedData),
    PoweredRail(PoweredRailData),
    DetectorRail(DetectorRailData),
    StickyPiston(StickyPistonData),
    Cobweb,
    Grass,
    Fern,
    DeadBush,
    Seagrass,
    TallSeagrass(TallSeagrassData),
    Piston(PistonData),
    PistonHead(PistonHeadData),
    WhiteWool,
    OrangeWool,
    MagentaWool,
    LightBlueWool,
    YellowWool,
    LimeWool,
    PinkWool,
    GrayWool,
    LightGrayWool,
    CyanWool,
    PurpleWool,
    BlueWool,
    BrownWool,
    GreenWool,
    RedWool,
    BlackWool,
    MovingPiston(MovingPistonData),
    Dandelion,
    Poppy,
    BlueOrchid,
    Allium,
    AzureBluet,
    RedTulip,
    OrangeTulip,
    WhiteTulip,
    PinkTulip,
    OxeyeDaisy,
    BrownMushroom,
    RedMushroom,
    GoldBlock,
    IronBlock,
    Bricks,
    Tnt(TntData),
    Bookshelf,
    MossyCobblestone,
    Obsidian,
    Torch,
    WallTorch(WallTorchData),
    Fire(FireData),
    Spawner,
    OakStairs(OakStairsData),
    Chest(ChestData),
    RedstoneWire(RedstoneWireData),
    DiamondOre,
    DiamondBlock,
    CraftingTable,
    Wheat(WheatData),
    Farmland(FarmlandData),
    Furnace(FurnaceData),
    Sign(SignData),
    OakDoor(OakDoorData),
    Ladder(LadderData),
    Rail(RailData),
    CobblestoneStairs(CobblestoneStairsData),
    WallSign(WallSignData),
    Lever(LeverData),
    StonePressurePlate(StonePressurePlateData),
    IronDoor(IronDoorData),
    OakPressurePlate(OakPressurePlateData),
    SprucePressurePlate(SprucePressurePlateData),
    BirchPressurePlate(BirchPressurePlateData),
    JunglePressurePlate(JunglePressurePlateData),
    AcaciaPressurePlate(AcaciaPressurePlateData),
    DarkOakPressurePlate(DarkOakPressurePlateData),
    RedstoneOre(RedstoneOreData),
    RedstoneTorch(RedstoneTorchData),
    RedstoneWallTorch(RedstoneWallTorchData),
    StoneButton(StoneButtonData),
    Snow(SnowData),
    Ice,
    SnowBlock,
    Cactus(CactusData),
    Clay,
    SugarCane(SugarCaneData),
    Jukebox(JukeboxData),
    OakFence(OakFenceData),
    Pumpkin,
    Netherrack,
    SoulSand,
    Glowstone,
    NetherPortal(NetherPortalData),
    CarvedPumpkin(CarvedPumpkinData),
    JackOLantern(JackOLanternData),
    Cake(CakeData),
    Repeater(RepeaterData),
    WhiteStainedGlass,
    OrangeStainedGlass,
    MagentaStainedGlass,
    LightBlueStainedGlass,
    YellowStainedGlass,
    LimeStainedGlass,
    PinkStainedGlass,
    GrayStainedGlass,
    LightGrayStainedGlass,
    CyanStainedGlass,
    PurpleStainedGlass,
    BlueStainedGlass,
    BrownStainedGlass,
    GreenStainedGlass,
    RedStainedGlass,
    BlackStainedGlass,
    OakTrapdoor(OakTrapdoorData),
    SpruceTrapdoor(SpruceTrapdoorData),
    BirchTrapdoor(BirchTrapdoorData),
    JungleTrapdoor(JungleTrapdoorData),
    AcaciaTrapdoor(AcaciaTrapdoorData),
    DarkOakTrapdoor(DarkOakTrapdoorData),
    InfestedStone,
    InfestedCobblestone,
    InfestedStoneBricks,
    InfestedMossyStoneBricks,
    InfestedCrackedStoneBricks,
    InfestedChiseledStoneBricks,
    StoneBricks,
    MossyStoneBricks,
    CrackedStoneBricks,
    ChiseledStoneBricks,
    BrownMushroomBlock(BrownMushroomBlockData),
    RedMushroomBlock(RedMushroomBlockData),
    MushroomStem(MushroomStemData),
    IronBars(IronBarsData),
    GlassPane(GlassPaneData),
    Melon,
    AttachedPumpkinStem(AttachedPumpkinStemData),
    AttachedMelonStem(AttachedMelonStemData),
    PumpkinStem(PumpkinStemData),
    MelonStem(MelonStemData),
    Vine(VineData),
    OakFenceGate(OakFenceGateData),
    BrickStairs(BrickStairsData),
    StoneBrickStairs(StoneBrickStairsData),
    Mycelium(MyceliumData),
    LilyPad,
    NetherBricks,
    NetherBrickFence(NetherBrickFenceData),
    NetherBrickStairs(NetherBrickStairsData),
    NetherWart(NetherWartData),
    EnchantingTable,
    BrewingStand(BrewingStandData),
    Cauldron(CauldronData),
    EndPortal,
    EndPortalFrame(EndPortalFrameData),
    EndStone,
    DragonEgg,
    RedstoneLamp(RedstoneLampData),
    Cocoa(CocoaData),
    SandstoneStairs(SandstoneStairsData),
    EmeraldOre,
    EnderChest(EnderChestData),
    TripwireHook(TripwireHookData),
    Tripwire(TripwireData),
    EmeraldBlock,
    SpruceStairs(SpruceStairsData),
    BirchStairs(BirchStairsData),
    JungleStairs(JungleStairsData),
    CommandBlock(CommandBlockData),
    Beacon,
    CobblestoneWall(CobblestoneWallData),
    MossyCobblestoneWall(MossyCobblestoneWallData),
    FlowerPot,
    PottedOakSapling,
    PottedSpruceSapling,
    PottedBirchSapling,
    PottedJungleSapling,
    PottedAcaciaSapling,
    PottedDarkOakSapling,
    PottedFern,
    PottedDandelion,
    PottedPoppy,
    PottedBlueOrchid,
    PottedAllium,
    PottedAzureBluet,
    PottedRedTulip,
    PottedOrangeTulip,
    PottedWhiteTulip,
    PottedPinkTulip,
    PottedOxeyeDaisy,
    PottedRedMushroom,
    PottedBrownMushroom,
    PottedDeadBush,
    PottedCactus,
    Carrots(CarrotsData),
    Potatoes(PotatoesData),
    OakButton(OakButtonData),
    SpruceButton(SpruceButtonData),
    BirchButton(BirchButtonData),
    JungleButton(JungleButtonData),
    AcaciaButton(AcaciaButtonData),
    DarkOakButton(DarkOakButtonData),
    SkeletonWallSkull(SkeletonWallSkullData),
    SkeletonSkull(SkeletonSkullData),
    WitherSkeletonWallSkull(WitherSkeletonWallSkullData),
    WitherSkeletonSkull(WitherSkeletonSkullData),
    ZombieWallHead(ZombieWallHeadData),
    ZombieHead(ZombieHeadData),
    PlayerWallHead(PlayerWallHeadData),
    PlayerHead(PlayerHeadData),
    CreeperWallHead(CreeperWallHeadData),
    CreeperHead(CreeperHeadData),
    DragonWallHead(DragonWallHeadData),
    DragonHead(DragonHeadData),
    Anvil(AnvilData),
    ChippedAnvil(ChippedAnvilData),
    DamagedAnvil(DamagedAnvilData),
    TrappedChest(TrappedChestData),
    LightWeightedPressurePlate(LightWeightedPressurePlateData),
    HeavyWeightedPressurePlate(HeavyWeightedPressurePlateData),
    Comparator(ComparatorData),
    DaylightDetector(DaylightDetectorData),
    RedstoneBlock,
    NetherQuartzOre,
    Hopper(HopperData),
    QuartzBlock,
    ChiseledQuartzBlock,
    QuartzPillar(QuartzPillarData),
    QuartzStairs(QuartzStairsData),
    ActivatorRail(ActivatorRailData),
    Dropper(DropperData),
    WhiteTerracotta,
    OrangeTerracotta,
    MagentaTerracotta,
    LightBlueTerracotta,
    YellowTerracotta,
    LimeTerracotta,
    PinkTerracotta,
    GrayTerracotta,
    LightGrayTerracotta,
    CyanTerracotta,
    PurpleTerracotta,
    BlueTerracotta,
    BrownTerracotta,
    GreenTerracotta,
    RedTerracotta,
    BlackTerracotta,
    WhiteStainedGlassPane(WhiteStainedGlassPaneData),
    OrangeStainedGlassPane(OrangeStainedGlassPaneData),
    MagentaStainedGlassPane(MagentaStainedGlassPaneData),
    LightBlueStainedGlassPane(LightBlueStainedGlassPaneData),
    YellowStainedGlassPane(YellowStainedGlassPaneData),
    LimeStainedGlassPane(LimeStainedGlassPaneData),
    PinkStainedGlassPane(PinkStainedGlassPaneData),
    GrayStainedGlassPane(GrayStainedGlassPaneData),
    LightGrayStainedGlassPane(LightGrayStainedGlassPaneData),
    CyanStainedGlassPane(CyanStainedGlassPaneData),
    PurpleStainedGlassPane(PurpleStainedGlassPaneData),
    BlueStainedGlassPane(BlueStainedGlassPaneData),
    BrownStainedGlassPane(BrownStainedGlassPaneData),
    GreenStainedGlassPane(GreenStainedGlassPaneData),
    RedStainedGlassPane(RedStainedGlassPaneData),
    BlackStainedGlassPane(BlackStainedGlassPaneData),
    AcaciaStairs(AcaciaStairsData),
    DarkOakStairs(DarkOakStairsData),
    SlimeBlock,
    Barrier,
    IronTrapdoor(IronTrapdoorData),
    Prismarine,
    PrismarineBricks,
    DarkPrismarine,
    PrismarineStairs(PrismarineStairsData),
    PrismarineBrickStairs(PrismarineBrickStairsData),
    DarkPrismarineStairs(DarkPrismarineStairsData),
    PrismarineSlab(PrismarineSlabData),
    PrismarineBrickSlab(PrismarineBrickSlabData),
    DarkPrismarineSlab(DarkPrismarineSlabData),
    SeaLantern,
    HayBlock(HayBlockData),
    WhiteCarpet,
    OrangeCarpet,
    MagentaCarpet,
    LightBlueCarpet,
    YellowCarpet,
    LimeCarpet,
    PinkCarpet,
    GrayCarpet,
    LightGrayCarpet,
    CyanCarpet,
    PurpleCarpet,
    BlueCarpet,
    BrownCarpet,
    GreenCarpet,
    RedCarpet,
    BlackCarpet,
    Terracotta,
    CoalBlock,
    PackedIce,
    Sunflower(SunflowerData),
    Lilac(LilacData),
    RoseBush(RoseBushData),
    Peony(PeonyData),
    TallGrass(TallGrassData),
    LargeFern(LargeFernData),
    WhiteBanner(WhiteBannerData),
    OrangeBanner(OrangeBannerData),
    MagentaBanner(MagentaBannerData),
    LightBlueBanner(LightBlueBannerData),
    YellowBanner(YellowBannerData),
    LimeBanner(LimeBannerData),
    PinkBanner(PinkBannerData),
    GrayBanner(GrayBannerData),
    LightGrayBanner(LightGrayBannerData),
    CyanBanner(CyanBannerData),
    PurpleBanner(PurpleBannerData),
    BlueBanner(BlueBannerData),
    BrownBanner(BrownBannerData),
    GreenBanner(GreenBannerData),
    RedBanner(RedBannerData),
    BlackBanner(BlackBannerData),
    WhiteWallBanner(WhiteWallBannerData),
    OrangeWallBanner(OrangeWallBannerData),
    MagentaWallBanner(MagentaWallBannerData),
    LightBlueWallBanner(LightBlueWallBannerData),
    YellowWallBanner(YellowWallBannerData),
    LimeWallBanner(LimeWallBannerData),
    PinkWallBanner(PinkWallBannerData),
    GrayWallBanner(GrayWallBannerData),
    LightGrayWallBanner(LightGrayWallBannerData),
    CyanWallBanner(CyanWallBannerData),
    PurpleWallBanner(PurpleWallBannerData),
    BlueWallBanner(BlueWallBannerData),
    BrownWallBanner(BrownWallBannerData),
    GreenWallBanner(GreenWallBannerData),
    RedWallBanner(RedWallBannerData),
    BlackWallBanner(BlackWallBannerData),
    RedSandstone,
    ChiseledRedSandstone,
    CutRedSandstone,
    RedSandstoneStairs(RedSandstoneStairsData),
    OakSlab(OakSlabData),
    SpruceSlab(SpruceSlabData),
    BirchSlab(BirchSlabData),
    JungleSlab(JungleSlabData),
    AcaciaSlab(AcaciaSlabData),
    DarkOakSlab(DarkOakSlabData),
    StoneSlab(StoneSlabData),
    SandstoneSlab(SandstoneSlabData),
    PetrifiedOakSlab(PetrifiedOakSlabData),
    CobblestoneSlab(CobblestoneSlabData),
    BrickSlab(BrickSlabData),
    StoneBrickSlab(StoneBrickSlabData),
    NetherBrickSlab(NetherBrickSlabData),
    QuartzSlab(QuartzSlabData),
    RedSandstoneSlab(RedSandstoneSlabData),
    PurpurSlab(PurpurSlabData),
    SmoothStone,
    SmoothSandstone,
    SmoothQuartz,
    SmoothRedSandstone,
    SpruceFenceGate(SpruceFenceGateData),
    BirchFenceGate(BirchFenceGateData),
    JungleFenceGate(JungleFenceGateData),
    AcaciaFenceGate(AcaciaFenceGateData),
    DarkOakFenceGate(DarkOakFenceGateData),
    SpruceFence(SpruceFenceData),
    BirchFence(BirchFenceData),
    JungleFence(JungleFenceData),
    AcaciaFence(AcaciaFenceData),
    DarkOakFence(DarkOakFenceData),
    SpruceDoor(SpruceDoorData),
    BirchDoor(BirchDoorData),
    JungleDoor(JungleDoorData),
    AcaciaDoor(AcaciaDoorData),
    DarkOakDoor(DarkOakDoorData),
    EndRod(EndRodData),
    ChorusPlant(ChorusPlantData),
    ChorusFlower(ChorusFlowerData),
    PurpurBlock,
    PurpurPillar(PurpurPillarData),
    PurpurStairs(PurpurStairsData),
    EndStoneBricks,
    Beetroots(BeetrootsData),
    GrassPath,
    EndGateway,
    RepeatingCommandBlock(RepeatingCommandBlockData),
    ChainCommandBlock(ChainCommandBlockData),
    FrostedIce(FrostedIceData),
    MagmaBlock,
    NetherWartBlock,
    RedNetherBricks,
    BoneBlock(BoneBlockData),
    StructureVoid,
    Observer(ObserverData),
    ShulkerBox(ShulkerBoxData),
    WhiteShulkerBox(WhiteShulkerBoxData),
    OrangeShulkerBox(OrangeShulkerBoxData),
    MagentaShulkerBox(MagentaShulkerBoxData),
    LightBlueShulkerBox(LightBlueShulkerBoxData),
    YellowShulkerBox(YellowShulkerBoxData),
    LimeShulkerBox(LimeShulkerBoxData),
    PinkShulkerBox(PinkShulkerBoxData),
    GrayShulkerBox(GrayShulkerBoxData),
    LightGrayShulkerBox(LightGrayShulkerBoxData),
    CyanShulkerBox(CyanShulkerBoxData),
    PurpleShulkerBox(PurpleShulkerBoxData),
    BlueShulkerBox(BlueShulkerBoxData),
    BrownShulkerBox(BrownShulkerBoxData),
    GreenShulkerBox(GreenShulkerBoxData),
    RedShulkerBox(RedShulkerBoxData),
    BlackShulkerBox(BlackShulkerBoxData),
    WhiteGlazedTerracotta(WhiteGlazedTerracottaData),
    OrangeGlazedTerracotta(OrangeGlazedTerracottaData),
    MagentaGlazedTerracotta(MagentaGlazedTerracottaData),
    LightBlueGlazedTerracotta(LightBlueGlazedTerracottaData),
    YellowGlazedTerracotta(YellowGlazedTerracottaData),
    LimeGlazedTerracotta(LimeGlazedTerracottaData),
    PinkGlazedTerracotta(PinkGlazedTerracottaData),
    GrayGlazedTerracotta(GrayGlazedTerracottaData),
    LightGrayGlazedTerracotta(LightGrayGlazedTerracottaData),
    CyanGlazedTerracotta(CyanGlazedTerracottaData),
    PurpleGlazedTerracotta(PurpleGlazedTerracottaData),
    BlueGlazedTerracotta(BlueGlazedTerracottaData),
    BrownGlazedTerracotta(BrownGlazedTerracottaData),
    GreenGlazedTerracotta(GreenGlazedTerracottaData),
    RedGlazedTerracotta(RedGlazedTerracottaData),
    BlackGlazedTerracotta(BlackGlazedTerracottaData),
    WhiteConcrete,
    OrangeConcrete,
    MagentaConcrete,
    LightBlueConcrete,
    YellowConcrete,
    LimeConcrete,
    PinkConcrete,
    GrayConcrete,
    LightGrayConcrete,
    CyanConcrete,
    PurpleConcrete,
    BlueConcrete,
    BrownConcrete,
    GreenConcrete,
    RedConcrete,
    BlackConcrete,
    WhiteConcretePowder,
    OrangeConcretePowder,
    MagentaConcretePowder,
    LightBlueConcretePowder,
    YellowConcretePowder,
    LimeConcretePowder,
    PinkConcretePowder,
    GrayConcretePowder,
    LightGrayConcretePowder,
    CyanConcretePowder,
    PurpleConcretePowder,
    BlueConcretePowder,
    BrownConcretePowder,
    GreenConcretePowder,
    RedConcretePowder,
    BlackConcretePowder,
    Kelp(KelpData),
    KelpPlant,
    DriedKelpBlock,
    TurtleEgg(TurtleEggData),
    DeadTubeCoralBlock,
    DeadBrainCoralBlock,
    DeadBubbleCoralBlock,
    DeadFireCoralBlock,
    DeadHornCoralBlock,
    TubeCoralBlock,
    BrainCoralBlock,
    BubbleCoralBlock,
    FireCoralBlock,
    HornCoralBlock,
    DeadTubeCoral(DeadTubeCoralData),
    DeadBrainCoral(DeadBrainCoralData),
    DeadBubbleCoral(DeadBubbleCoralData),
    DeadFireCoral(DeadFireCoralData),
    DeadHornCoral(DeadHornCoralData),
    TubeCoral(TubeCoralData),
    BrainCoral(BrainCoralData),
    BubbleCoral(BubbleCoralData),
    FireCoral(FireCoralData),
    HornCoral(HornCoralData),
    DeadTubeCoralWallFan(DeadTubeCoralWallFanData),
    DeadBrainCoralWallFan(DeadBrainCoralWallFanData),
    DeadBubbleCoralWallFan(DeadBubbleCoralWallFanData),
    DeadFireCoralWallFan(DeadFireCoralWallFanData),
    DeadHornCoralWallFan(DeadHornCoralWallFanData),
    TubeCoralWallFan(TubeCoralWallFanData),
    BrainCoralWallFan(BrainCoralWallFanData),
    BubbleCoralWallFan(BubbleCoralWallFanData),
    FireCoralWallFan(FireCoralWallFanData),
    HornCoralWallFan(HornCoralWallFanData),
    DeadTubeCoralFan(DeadTubeCoralFanData),
    DeadBrainCoralFan(DeadBrainCoralFanData),
    DeadBubbleCoralFan(DeadBubbleCoralFanData),
    DeadFireCoralFan(DeadFireCoralFanData),
    DeadHornCoralFan(DeadHornCoralFanData),
    TubeCoralFan(TubeCoralFanData),
    BrainCoralFan(BrainCoralFanData),
    BubbleCoralFan(BubbleCoralFanData),
    FireCoralFan(FireCoralFanData),
    HornCoralFan(HornCoralFanData),
    SeaPickle(SeaPickleData),
    BlueIce,
    Conduit(ConduitData),
    VoidAir,
    CaveAir,
    BubbleColumn(BubbleColumnData),
    StructureBlock(StructureBlockData),
}
impl Block {
    fn internal_type_id(&self) -> usize {
        match self {
            Block::Air => 0usize,
            Block::Stone => 1usize,
            Block::Granite => 2usize,
            Block::PolishedGranite => 3usize,
            Block::Diorite => 4usize,
            Block::PolishedDiorite => 5usize,
            Block::Andesite => 6usize,
            Block::PolishedAndesite => 7usize,
            Block::GrassBlock(_) => 8usize,
            Block::Dirt => 9usize,
            Block::CoarseDirt => 10usize,
            Block::Podzol(_) => 11usize,
            Block::Cobblestone => 12usize,
            Block::OakPlanks => 13usize,
            Block::SprucePlanks => 14usize,
            Block::BirchPlanks => 15usize,
            Block::JunglePlanks => 16usize,
            Block::AcaciaPlanks => 17usize,
            Block::DarkOakPlanks => 18usize,
            Block::OakSapling(_) => 19usize,
            Block::SpruceSapling(_) => 20usize,
            Block::BirchSapling(_) => 21usize,
            Block::JungleSapling(_) => 22usize,
            Block::AcaciaSapling(_) => 23usize,
            Block::DarkOakSapling(_) => 24usize,
            Block::Bedrock => 25usize,
            Block::Water(_) => 26usize,
            Block::Lava(_) => 27usize,
            Block::Sand => 28usize,
            Block::RedSand => 29usize,
            Block::Gravel => 30usize,
            Block::GoldOre => 31usize,
            Block::IronOre => 32usize,
            Block::CoalOre => 33usize,
            Block::OakLog(_) => 34usize,
            Block::SpruceLog(_) => 35usize,
            Block::BirchLog(_) => 36usize,
            Block::JungleLog(_) => 37usize,
            Block::AcaciaLog(_) => 38usize,
            Block::DarkOakLog(_) => 39usize,
            Block::StrippedSpruceLog(_) => 40usize,
            Block::StrippedBirchLog(_) => 41usize,
            Block::StrippedJungleLog(_) => 42usize,
            Block::StrippedAcaciaLog(_) => 43usize,
            Block::StrippedDarkOakLog(_) => 44usize,
            Block::StrippedOakLog(_) => 45usize,
            Block::OakWood(_) => 46usize,
            Block::SpruceWood(_) => 47usize,
            Block::BirchWood(_) => 48usize,
            Block::JungleWood(_) => 49usize,
            Block::AcaciaWood(_) => 50usize,
            Block::DarkOakWood(_) => 51usize,
            Block::StrippedOakWood(_) => 52usize,
            Block::StrippedSpruceWood(_) => 53usize,
            Block::StrippedBirchWood(_) => 54usize,
            Block::StrippedJungleWood(_) => 55usize,
            Block::StrippedAcaciaWood(_) => 56usize,
            Block::StrippedDarkOakWood(_) => 57usize,
            Block::OakLeaves(_) => 58usize,
            Block::SpruceLeaves(_) => 59usize,
            Block::BirchLeaves(_) => 60usize,
            Block::JungleLeaves(_) => 61usize,
            Block::AcaciaLeaves(_) => 62usize,
            Block::DarkOakLeaves(_) => 63usize,
            Block::Sponge => 64usize,
            Block::WetSponge => 65usize,
            Block::Glass => 66usize,
            Block::LapisOre => 67usize,
            Block::LapisBlock => 68usize,
            Block::Dispenser(_) => 69usize,
            Block::Sandstone => 70usize,
            Block::ChiseledSandstone => 71usize,
            Block::CutSandstone => 72usize,
            Block::NoteBlock(_) => 73usize,
            Block::WhiteBed(_) => 74usize,
            Block::OrangeBed(_) => 75usize,
            Block::MagentaBed(_) => 76usize,
            Block::LightBlueBed(_) => 77usize,
            Block::YellowBed(_) => 78usize,
            Block::LimeBed(_) => 79usize,
            Block::PinkBed(_) => 80usize,
            Block::GrayBed(_) => 81usize,
            Block::LightGrayBed(_) => 82usize,
            Block::CyanBed(_) => 83usize,
            Block::PurpleBed(_) => 84usize,
            Block::BlueBed(_) => 85usize,
            Block::BrownBed(_) => 86usize,
            Block::GreenBed(_) => 87usize,
            Block::RedBed(_) => 88usize,
            Block::BlackBed(_) => 89usize,
            Block::PoweredRail(_) => 90usize,
            Block::DetectorRail(_) => 91usize,
            Block::StickyPiston(_) => 92usize,
            Block::Cobweb => 93usize,
            Block::Grass => 94usize,
            Block::Fern => 95usize,
            Block::DeadBush => 96usize,
            Block::Seagrass => 97usize,
            Block::TallSeagrass(_) => 98usize,
            Block::Piston(_) => 99usize,
            Block::PistonHead(_) => 100usize,
            Block::WhiteWool => 101usize,
            Block::OrangeWool => 102usize,
            Block::MagentaWool => 103usize,
            Block::LightBlueWool => 104usize,
            Block::YellowWool => 105usize,
            Block::LimeWool => 106usize,
            Block::PinkWool => 107usize,
            Block::GrayWool => 108usize,
            Block::LightGrayWool => 109usize,
            Block::CyanWool => 110usize,
            Block::PurpleWool => 111usize,
            Block::BlueWool => 112usize,
            Block::BrownWool => 113usize,
            Block::GreenWool => 114usize,
            Block::RedWool => 115usize,
            Block::BlackWool => 116usize,
            Block::MovingPiston(_) => 117usize,
            Block::Dandelion => 118usize,
            Block::Poppy => 119usize,
            Block::BlueOrchid => 120usize,
            Block::Allium => 121usize,
            Block::AzureBluet => 122usize,
            Block::RedTulip => 123usize,
            Block::OrangeTulip => 124usize,
            Block::WhiteTulip => 125usize,
            Block::PinkTulip => 126usize,
            Block::OxeyeDaisy => 127usize,
            Block::BrownMushroom => 128usize,
            Block::RedMushroom => 129usize,
            Block::GoldBlock => 130usize,
            Block::IronBlock => 131usize,
            Block::Bricks => 132usize,
            Block::Tnt(_) => 133usize,
            Block::Bookshelf => 134usize,
            Block::MossyCobblestone => 135usize,
            Block::Obsidian => 136usize,
            Block::Torch => 137usize,
            Block::WallTorch(_) => 138usize,
            Block::Fire(_) => 139usize,
            Block::Spawner => 140usize,
            Block::OakStairs(_) => 141usize,
            Block::Chest(_) => 142usize,
            Block::RedstoneWire(_) => 143usize,
            Block::DiamondOre => 144usize,
            Block::DiamondBlock => 145usize,
            Block::CraftingTable => 146usize,
            Block::Wheat(_) => 147usize,
            Block::Farmland(_) => 148usize,
            Block::Furnace(_) => 149usize,
            Block::Sign(_) => 150usize,
            Block::OakDoor(_) => 151usize,
            Block::Ladder(_) => 152usize,
            Block::Rail(_) => 153usize,
            Block::CobblestoneStairs(_) => 154usize,
            Block::WallSign(_) => 155usize,
            Block::Lever(_) => 156usize,
            Block::StonePressurePlate(_) => 157usize,
            Block::IronDoor(_) => 158usize,
            Block::OakPressurePlate(_) => 159usize,
            Block::SprucePressurePlate(_) => 160usize,
            Block::BirchPressurePlate(_) => 161usize,
            Block::JunglePressurePlate(_) => 162usize,
            Block::AcaciaPressurePlate(_) => 163usize,
            Block::DarkOakPressurePlate(_) => 164usize,
            Block::RedstoneOre(_) => 165usize,
            Block::RedstoneTorch(_) => 166usize,
            Block::RedstoneWallTorch(_) => 167usize,
            Block::StoneButton(_) => 168usize,
            Block::Snow(_) => 169usize,
            Block::Ice => 170usize,
            Block::SnowBlock => 171usize,
            Block::Cactus(_) => 172usize,
            Block::Clay => 173usize,
            Block::SugarCane(_) => 174usize,
            Block::Jukebox(_) => 175usize,
            Block::OakFence(_) => 176usize,
            Block::Pumpkin => 177usize,
            Block::Netherrack => 178usize,
            Block::SoulSand => 179usize,
            Block::Glowstone => 180usize,
            Block::NetherPortal(_) => 181usize,
            Block::CarvedPumpkin(_) => 182usize,
            Block::JackOLantern(_) => 183usize,
            Block::Cake(_) => 184usize,
            Block::Repeater(_) => 185usize,
            Block::WhiteStainedGlass => 186usize,
            Block::OrangeStainedGlass => 187usize,
            Block::MagentaStainedGlass => 188usize,
            Block::LightBlueStainedGlass => 189usize,
            Block::YellowStainedGlass => 190usize,
            Block::LimeStainedGlass => 191usize,
            Block::PinkStainedGlass => 192usize,
            Block::GrayStainedGlass => 193usize,
            Block::LightGrayStainedGlass => 194usize,
            Block::CyanStainedGlass => 195usize,
            Block::PurpleStainedGlass => 196usize,
            Block::BlueStainedGlass => 197usize,
            Block::BrownStainedGlass => 198usize,
            Block::GreenStainedGlass => 199usize,
            Block::RedStainedGlass => 200usize,
            Block::BlackStainedGlass => 201usize,
            Block::OakTrapdoor(_) => 202usize,
            Block::SpruceTrapdoor(_) => 203usize,
            Block::BirchTrapdoor(_) => 204usize,
            Block::JungleTrapdoor(_) => 205usize,
            Block::AcaciaTrapdoor(_) => 206usize,
            Block::DarkOakTrapdoor(_) => 207usize,
            Block::InfestedStone => 208usize,
            Block::InfestedCobblestone => 209usize,
            Block::InfestedStoneBricks => 210usize,
            Block::InfestedMossyStoneBricks => 211usize,
            Block::InfestedCrackedStoneBricks => 212usize,
            Block::InfestedChiseledStoneBricks => 213usize,
            Block::StoneBricks => 214usize,
            Block::MossyStoneBricks => 215usize,
            Block::CrackedStoneBricks => 216usize,
            Block::ChiseledStoneBricks => 217usize,
            Block::BrownMushroomBlock(_) => 218usize,
            Block::RedMushroomBlock(_) => 219usize,
            Block::MushroomStem(_) => 220usize,
            Block::IronBars(_) => 221usize,
            Block::GlassPane(_) => 222usize,
            Block::Melon => 223usize,
            Block::AttachedPumpkinStem(_) => 224usize,
            Block::AttachedMelonStem(_) => 225usize,
            Block::PumpkinStem(_) => 226usize,
            Block::MelonStem(_) => 227usize,
            Block::Vine(_) => 228usize,
            Block::OakFenceGate(_) => 229usize,
            Block::BrickStairs(_) => 230usize,
            Block::StoneBrickStairs(_) => 231usize,
            Block::Mycelium(_) => 232usize,
            Block::LilyPad => 233usize,
            Block::NetherBricks => 234usize,
            Block::NetherBrickFence(_) => 235usize,
            Block::NetherBrickStairs(_) => 236usize,
            Block::NetherWart(_) => 237usize,
            Block::EnchantingTable => 238usize,
            Block::BrewingStand(_) => 239usize,
            Block::Cauldron(_) => 240usize,
            Block::EndPortal => 241usize,
            Block::EndPortalFrame(_) => 242usize,
            Block::EndStone => 243usize,
            Block::DragonEgg => 244usize,
            Block::RedstoneLamp(_) => 245usize,
            Block::Cocoa(_) => 246usize,
            Block::SandstoneStairs(_) => 247usize,
            Block::EmeraldOre => 248usize,
            Block::EnderChest(_) => 249usize,
            Block::TripwireHook(_) => 250usize,
            Block::Tripwire(_) => 251usize,
            Block::EmeraldBlock => 252usize,
            Block::SpruceStairs(_) => 253usize,
            Block::BirchStairs(_) => 254usize,
            Block::JungleStairs(_) => 255usize,
            Block::CommandBlock(_) => 256usize,
            Block::Beacon => 257usize,
            Block::CobblestoneWall(_) => 258usize,
            Block::MossyCobblestoneWall(_) => 259usize,
            Block::FlowerPot => 260usize,
            Block::PottedOakSapling => 261usize,
            Block::PottedSpruceSapling => 262usize,
            Block::PottedBirchSapling => 263usize,
            Block::PottedJungleSapling => 264usize,
            Block::PottedAcaciaSapling => 265usize,
            Block::PottedDarkOakSapling => 266usize,
            Block::PottedFern => 267usize,
            Block::PottedDandelion => 268usize,
            Block::PottedPoppy => 269usize,
            Block::PottedBlueOrchid => 270usize,
            Block::PottedAllium => 271usize,
            Block::PottedAzureBluet => 272usize,
            Block::PottedRedTulip => 273usize,
            Block::PottedOrangeTulip => 274usize,
            Block::PottedWhiteTulip => 275usize,
            Block::PottedPinkTulip => 276usize,
            Block::PottedOxeyeDaisy => 277usize,
            Block::PottedRedMushroom => 278usize,
            Block::PottedBrownMushroom => 279usize,
            Block::PottedDeadBush => 280usize,
            Block::PottedCactus => 281usize,
            Block::Carrots(_) => 282usize,
            Block::Potatoes(_) => 283usize,
            Block::OakButton(_) => 284usize,
            Block::SpruceButton(_) => 285usize,
            Block::BirchButton(_) => 286usize,
            Block::JungleButton(_) => 287usize,
            Block::AcaciaButton(_) => 288usize,
            Block::DarkOakButton(_) => 289usize,
            Block::SkeletonWallSkull(_) => 290usize,
            Block::SkeletonSkull(_) => 291usize,
            Block::WitherSkeletonWallSkull(_) => 292usize,
            Block::WitherSkeletonSkull(_) => 293usize,
            Block::ZombieWallHead(_) => 294usize,
            Block::ZombieHead(_) => 295usize,
            Block::PlayerWallHead(_) => 296usize,
            Block::PlayerHead(_) => 297usize,
            Block::CreeperWallHead(_) => 298usize,
            Block::CreeperHead(_) => 299usize,
            Block::DragonWallHead(_) => 300usize,
            Block::DragonHead(_) => 301usize,
            Block::Anvil(_) => 302usize,
            Block::ChippedAnvil(_) => 303usize,
            Block::DamagedAnvil(_) => 304usize,
            Block::TrappedChest(_) => 305usize,
            Block::LightWeightedPressurePlate(_) => 306usize,
            Block::HeavyWeightedPressurePlate(_) => 307usize,
            Block::Comparator(_) => 308usize,
            Block::DaylightDetector(_) => 309usize,
            Block::RedstoneBlock => 310usize,
            Block::NetherQuartzOre => 311usize,
            Block::Hopper(_) => 312usize,
            Block::QuartzBlock => 313usize,
            Block::ChiseledQuartzBlock => 314usize,
            Block::QuartzPillar(_) => 315usize,
            Block::QuartzStairs(_) => 316usize,
            Block::ActivatorRail(_) => 317usize,
            Block::Dropper(_) => 318usize,
            Block::WhiteTerracotta => 319usize,
            Block::OrangeTerracotta => 320usize,
            Block::MagentaTerracotta => 321usize,
            Block::LightBlueTerracotta => 322usize,
            Block::YellowTerracotta => 323usize,
            Block::LimeTerracotta => 324usize,
            Block::PinkTerracotta => 325usize,
            Block::GrayTerracotta => 326usize,
            Block::LightGrayTerracotta => 327usize,
            Block::CyanTerracotta => 328usize,
            Block::PurpleTerracotta => 329usize,
            Block::BlueTerracotta => 330usize,
            Block::BrownTerracotta => 331usize,
            Block::GreenTerracotta => 332usize,
            Block::RedTerracotta => 333usize,
            Block::BlackTerracotta => 334usize,
            Block::WhiteStainedGlassPane(_) => 335usize,
            Block::OrangeStainedGlassPane(_) => 336usize,
            Block::MagentaStainedGlassPane(_) => 337usize,
            Block::LightBlueStainedGlassPane(_) => 338usize,
            Block::YellowStainedGlassPane(_) => 339usize,
            Block::LimeStainedGlassPane(_) => 340usize,
            Block::PinkStainedGlassPane(_) => 341usize,
            Block::GrayStainedGlassPane(_) => 342usize,
            Block::LightGrayStainedGlassPane(_) => 343usize,
            Block::CyanStainedGlassPane(_) => 344usize,
            Block::PurpleStainedGlassPane(_) => 345usize,
            Block::BlueStainedGlassPane(_) => 346usize,
            Block::BrownStainedGlassPane(_) => 347usize,
            Block::GreenStainedGlassPane(_) => 348usize,
            Block::RedStainedGlassPane(_) => 349usize,
            Block::BlackStainedGlassPane(_) => 350usize,
            Block::AcaciaStairs(_) => 351usize,
            Block::DarkOakStairs(_) => 352usize,
            Block::SlimeBlock => 353usize,
            Block::Barrier => 354usize,
            Block::IronTrapdoor(_) => 355usize,
            Block::Prismarine => 356usize,
            Block::PrismarineBricks => 357usize,
            Block::DarkPrismarine => 358usize,
            Block::PrismarineStairs(_) => 359usize,
            Block::PrismarineBrickStairs(_) => 360usize,
            Block::DarkPrismarineStairs(_) => 361usize,
            Block::PrismarineSlab(_) => 362usize,
            Block::PrismarineBrickSlab(_) => 363usize,
            Block::DarkPrismarineSlab(_) => 364usize,
            Block::SeaLantern => 365usize,
            Block::HayBlock(_) => 366usize,
            Block::WhiteCarpet => 367usize,
            Block::OrangeCarpet => 368usize,
            Block::MagentaCarpet => 369usize,
            Block::LightBlueCarpet => 370usize,
            Block::YellowCarpet => 371usize,
            Block::LimeCarpet => 372usize,
            Block::PinkCarpet => 373usize,
            Block::GrayCarpet => 374usize,
            Block::LightGrayCarpet => 375usize,
            Block::CyanCarpet => 376usize,
            Block::PurpleCarpet => 377usize,
            Block::BlueCarpet => 378usize,
            Block::BrownCarpet => 379usize,
            Block::GreenCarpet => 380usize,
            Block::RedCarpet => 381usize,
            Block::BlackCarpet => 382usize,
            Block::Terracotta => 383usize,
            Block::CoalBlock => 384usize,
            Block::PackedIce => 385usize,
            Block::Sunflower(_) => 386usize,
            Block::Lilac(_) => 387usize,
            Block::RoseBush(_) => 388usize,
            Block::Peony(_) => 389usize,
            Block::TallGrass(_) => 390usize,
            Block::LargeFern(_) => 391usize,
            Block::WhiteBanner(_) => 392usize,
            Block::OrangeBanner(_) => 393usize,
            Block::MagentaBanner(_) => 394usize,
            Block::LightBlueBanner(_) => 395usize,
            Block::YellowBanner(_) => 396usize,
            Block::LimeBanner(_) => 397usize,
            Block::PinkBanner(_) => 398usize,
            Block::GrayBanner(_) => 399usize,
            Block::LightGrayBanner(_) => 400usize,
            Block::CyanBanner(_) => 401usize,
            Block::PurpleBanner(_) => 402usize,
            Block::BlueBanner(_) => 403usize,
            Block::BrownBanner(_) => 404usize,
            Block::GreenBanner(_) => 405usize,
            Block::RedBanner(_) => 406usize,
            Block::BlackBanner(_) => 407usize,
            Block::WhiteWallBanner(_) => 408usize,
            Block::OrangeWallBanner(_) => 409usize,
            Block::MagentaWallBanner(_) => 410usize,
            Block::LightBlueWallBanner(_) => 411usize,
            Block::YellowWallBanner(_) => 412usize,
            Block::LimeWallBanner(_) => 413usize,
            Block::PinkWallBanner(_) => 414usize,
            Block::GrayWallBanner(_) => 415usize,
            Block::LightGrayWallBanner(_) => 416usize,
            Block::CyanWallBanner(_) => 417usize,
            Block::PurpleWallBanner(_) => 418usize,
            Block::BlueWallBanner(_) => 419usize,
            Block::BrownWallBanner(_) => 420usize,
            Block::GreenWallBanner(_) => 421usize,
            Block::RedWallBanner(_) => 422usize,
            Block::BlackWallBanner(_) => 423usize,
            Block::RedSandstone => 424usize,
            Block::ChiseledRedSandstone => 425usize,
            Block::CutRedSandstone => 426usize,
            Block::RedSandstoneStairs(_) => 427usize,
            Block::OakSlab(_) => 428usize,
            Block::SpruceSlab(_) => 429usize,
            Block::BirchSlab(_) => 430usize,
            Block::JungleSlab(_) => 431usize,
            Block::AcaciaSlab(_) => 432usize,
            Block::DarkOakSlab(_) => 433usize,
            Block::StoneSlab(_) => 434usize,
            Block::SandstoneSlab(_) => 435usize,
            Block::PetrifiedOakSlab(_) => 436usize,
            Block::CobblestoneSlab(_) => 437usize,
            Block::BrickSlab(_) => 438usize,
            Block::StoneBrickSlab(_) => 439usize,
            Block::NetherBrickSlab(_) => 440usize,
            Block::QuartzSlab(_) => 441usize,
            Block::RedSandstoneSlab(_) => 442usize,
            Block::PurpurSlab(_) => 443usize,
            Block::SmoothStone => 444usize,
            Block::SmoothSandstone => 445usize,
            Block::SmoothQuartz => 446usize,
            Block::SmoothRedSandstone => 447usize,
            Block::SpruceFenceGate(_) => 448usize,
            Block::BirchFenceGate(_) => 449usize,
            Block::JungleFenceGate(_) => 450usize,
            Block::AcaciaFenceGate(_) => 451usize,
            Block::DarkOakFenceGate(_) => 452usize,
            Block::SpruceFence(_) => 453usize,
            Block::BirchFence(_) => 454usize,
            Block::JungleFence(_) => 455usize,
            Block::AcaciaFence(_) => 456usize,
            Block::DarkOakFence(_) => 457usize,
            Block::SpruceDoor(_) => 458usize,
            Block::BirchDoor(_) => 459usize,
            Block::JungleDoor(_) => 460usize,
            Block::AcaciaDoor(_) => 461usize,
            Block::DarkOakDoor(_) => 462usize,
            Block::EndRod(_) => 463usize,
            Block::ChorusPlant(_) => 464usize,
            Block::ChorusFlower(_) => 465usize,
            Block::PurpurBlock => 466usize,
            Block::PurpurPillar(_) => 467usize,
            Block::PurpurStairs(_) => 468usize,
            Block::EndStoneBricks => 469usize,
            Block::Beetroots(_) => 470usize,
            Block::GrassPath => 471usize,
            Block::EndGateway => 472usize,
            Block::RepeatingCommandBlock(_) => 473usize,
            Block::ChainCommandBlock(_) => 474usize,
            Block::FrostedIce(_) => 475usize,
            Block::MagmaBlock => 476usize,
            Block::NetherWartBlock => 477usize,
            Block::RedNetherBricks => 478usize,
            Block::BoneBlock(_) => 479usize,
            Block::StructureVoid => 480usize,
            Block::Observer(_) => 481usize,
            Block::ShulkerBox(_) => 482usize,
            Block::WhiteShulkerBox(_) => 483usize,
            Block::OrangeShulkerBox(_) => 484usize,
            Block::MagentaShulkerBox(_) => 485usize,
            Block::LightBlueShulkerBox(_) => 486usize,
            Block::YellowShulkerBox(_) => 487usize,
            Block::LimeShulkerBox(_) => 488usize,
            Block::PinkShulkerBox(_) => 489usize,
            Block::GrayShulkerBox(_) => 490usize,
            Block::LightGrayShulkerBox(_) => 491usize,
            Block::CyanShulkerBox(_) => 492usize,
            Block::PurpleShulkerBox(_) => 493usize,
            Block::BlueShulkerBox(_) => 494usize,
            Block::BrownShulkerBox(_) => 495usize,
            Block::GreenShulkerBox(_) => 496usize,
            Block::RedShulkerBox(_) => 497usize,
            Block::BlackShulkerBox(_) => 498usize,
            Block::WhiteGlazedTerracotta(_) => 499usize,
            Block::OrangeGlazedTerracotta(_) => 500usize,
            Block::MagentaGlazedTerracotta(_) => 501usize,
            Block::LightBlueGlazedTerracotta(_) => 502usize,
            Block::YellowGlazedTerracotta(_) => 503usize,
            Block::LimeGlazedTerracotta(_) => 504usize,
            Block::PinkGlazedTerracotta(_) => 505usize,
            Block::GrayGlazedTerracotta(_) => 506usize,
            Block::LightGrayGlazedTerracotta(_) => 507usize,
            Block::CyanGlazedTerracotta(_) => 508usize,
            Block::PurpleGlazedTerracotta(_) => 509usize,
            Block::BlueGlazedTerracotta(_) => 510usize,
            Block::BrownGlazedTerracotta(_) => 511usize,
            Block::GreenGlazedTerracotta(_) => 512usize,
            Block::RedGlazedTerracotta(_) => 513usize,
            Block::BlackGlazedTerracotta(_) => 514usize,
            Block::WhiteConcrete => 515usize,
            Block::OrangeConcrete => 516usize,
            Block::MagentaConcrete => 517usize,
            Block::LightBlueConcrete => 518usize,
            Block::YellowConcrete => 519usize,
            Block::LimeConcrete => 520usize,
            Block::PinkConcrete => 521usize,
            Block::GrayConcrete => 522usize,
            Block::LightGrayConcrete => 523usize,
            Block::CyanConcrete => 524usize,
            Block::PurpleConcrete => 525usize,
            Block::BlueConcrete => 526usize,
            Block::BrownConcrete => 527usize,
            Block::GreenConcrete => 528usize,
            Block::RedConcrete => 529usize,
            Block::BlackConcrete => 530usize,
            Block::WhiteConcretePowder => 531usize,
            Block::OrangeConcretePowder => 532usize,
            Block::MagentaConcretePowder => 533usize,
            Block::LightBlueConcretePowder => 534usize,
            Block::YellowConcretePowder => 535usize,
            Block::LimeConcretePowder => 536usize,
            Block::PinkConcretePowder => 537usize,
            Block::GrayConcretePowder => 538usize,
            Block::LightGrayConcretePowder => 539usize,
            Block::CyanConcretePowder => 540usize,
            Block::PurpleConcretePowder => 541usize,
            Block::BlueConcretePowder => 542usize,
            Block::BrownConcretePowder => 543usize,
            Block::GreenConcretePowder => 544usize,
            Block::RedConcretePowder => 545usize,
            Block::BlackConcretePowder => 546usize,
            Block::Kelp(_) => 547usize,
            Block::KelpPlant => 548usize,
            Block::DriedKelpBlock => 549usize,
            Block::TurtleEgg(_) => 550usize,
            Block::DeadTubeCoralBlock => 551usize,
            Block::DeadBrainCoralBlock => 552usize,
            Block::DeadBubbleCoralBlock => 553usize,
            Block::DeadFireCoralBlock => 554usize,
            Block::DeadHornCoralBlock => 555usize,
            Block::TubeCoralBlock => 556usize,
            Block::BrainCoralBlock => 557usize,
            Block::BubbleCoralBlock => 558usize,
            Block::FireCoralBlock => 559usize,
            Block::HornCoralBlock => 560usize,
            Block::DeadTubeCoral(_) => 561usize,
            Block::DeadBrainCoral(_) => 562usize,
            Block::DeadBubbleCoral(_) => 563usize,
            Block::DeadFireCoral(_) => 564usize,
            Block::DeadHornCoral(_) => 565usize,
            Block::TubeCoral(_) => 566usize,
            Block::BrainCoral(_) => 567usize,
            Block::BubbleCoral(_) => 568usize,
            Block::FireCoral(_) => 569usize,
            Block::HornCoral(_) => 570usize,
            Block::DeadTubeCoralWallFan(_) => 571usize,
            Block::DeadBrainCoralWallFan(_) => 572usize,
            Block::DeadBubbleCoralWallFan(_) => 573usize,
            Block::DeadFireCoralWallFan(_) => 574usize,
            Block::DeadHornCoralWallFan(_) => 575usize,
            Block::TubeCoralWallFan(_) => 576usize,
            Block::BrainCoralWallFan(_) => 577usize,
            Block::BubbleCoralWallFan(_) => 578usize,
            Block::FireCoralWallFan(_) => 579usize,
            Block::HornCoralWallFan(_) => 580usize,
            Block::DeadTubeCoralFan(_) => 581usize,
            Block::DeadBrainCoralFan(_) => 582usize,
            Block::DeadBubbleCoralFan(_) => 583usize,
            Block::DeadFireCoralFan(_) => 584usize,
            Block::DeadHornCoralFan(_) => 585usize,
            Block::TubeCoralFan(_) => 586usize,
            Block::BrainCoralFan(_) => 587usize,
            Block::BubbleCoralFan(_) => 588usize,
            Block::FireCoralFan(_) => 589usize,
            Block::HornCoralFan(_) => 590usize,
            Block::SeaPickle(_) => 591usize,
            Block::BlueIce => 592usize,
            Block::Conduit(_) => 593usize,
            Block::VoidAir => 594usize,
            Block::CaveAir => 595usize,
            Block::BubbleColumn(_) => 596usize,
            Block::StructureBlock(_) => 597usize,
        }
    }
    fn internal_id_data_offset(&self) -> usize {
        match self {
            Block::Air => 0,
            Block::Stone => 0,
            Block::Granite => 0,
            Block::PolishedGranite => 0,
            Block::Diorite => 0,
            Block::PolishedDiorite => 0,
            Block::Andesite => 0,
            Block::PolishedAndesite => 0,
            Block::GrassBlock(data) => data.value(),
            Block::Dirt => 0,
            Block::CoarseDirt => 0,
            Block::Podzol(data) => data.value(),
            Block::Cobblestone => 0,
            Block::OakPlanks => 0,
            Block::SprucePlanks => 0,
            Block::BirchPlanks => 0,
            Block::JunglePlanks => 0,
            Block::AcaciaPlanks => 0,
            Block::DarkOakPlanks => 0,
            Block::OakSapling(data) => data.value(),
            Block::SpruceSapling(data) => data.value(),
            Block::BirchSapling(data) => data.value(),
            Block::JungleSapling(data) => data.value(),
            Block::AcaciaSapling(data) => data.value(),
            Block::DarkOakSapling(data) => data.value(),
            Block::Bedrock => 0,
            Block::Water(data) => data.value(),
            Block::Lava(data) => data.value(),
            Block::Sand => 0,
            Block::RedSand => 0,
            Block::Gravel => 0,
            Block::GoldOre => 0,
            Block::IronOre => 0,
            Block::CoalOre => 0,
            Block::OakLog(data) => data.value(),
            Block::SpruceLog(data) => data.value(),
            Block::BirchLog(data) => data.value(),
            Block::JungleLog(data) => data.value(),
            Block::AcaciaLog(data) => data.value(),
            Block::DarkOakLog(data) => data.value(),
            Block::StrippedSpruceLog(data) => data.value(),
            Block::StrippedBirchLog(data) => data.value(),
            Block::StrippedJungleLog(data) => data.value(),
            Block::StrippedAcaciaLog(data) => data.value(),
            Block::StrippedDarkOakLog(data) => data.value(),
            Block::StrippedOakLog(data) => data.value(),
            Block::OakWood(data) => data.value(),
            Block::SpruceWood(data) => data.value(),
            Block::BirchWood(data) => data.value(),
            Block::JungleWood(data) => data.value(),
            Block::AcaciaWood(data) => data.value(),
            Block::DarkOakWood(data) => data.value(),
            Block::StrippedOakWood(data) => data.value(),
            Block::StrippedSpruceWood(data) => data.value(),
            Block::StrippedBirchWood(data) => data.value(),
            Block::StrippedJungleWood(data) => data.value(),
            Block::StrippedAcaciaWood(data) => data.value(),
            Block::StrippedDarkOakWood(data) => data.value(),
            Block::OakLeaves(data) => data.value(),
            Block::SpruceLeaves(data) => data.value(),
            Block::BirchLeaves(data) => data.value(),
            Block::JungleLeaves(data) => data.value(),
            Block::AcaciaLeaves(data) => data.value(),
            Block::DarkOakLeaves(data) => data.value(),
            Block::Sponge => 0,
            Block::WetSponge => 0,
            Block::Glass => 0,
            Block::LapisOre => 0,
            Block::LapisBlock => 0,
            Block::Dispenser(data) => data.value(),
            Block::Sandstone => 0,
            Block::ChiseledSandstone => 0,
            Block::CutSandstone => 0,
            Block::NoteBlock(data) => data.value(),
            Block::WhiteBed(data) => data.value(),
            Block::OrangeBed(data) => data.value(),
            Block::MagentaBed(data) => data.value(),
            Block::LightBlueBed(data) => data.value(),
            Block::YellowBed(data) => data.value(),
            Block::LimeBed(data) => data.value(),
            Block::PinkBed(data) => data.value(),
            Block::GrayBed(data) => data.value(),
            Block::LightGrayBed(data) => data.value(),
            Block::CyanBed(data) => data.value(),
            Block::PurpleBed(data) => data.value(),
            Block::BlueBed(data) => data.value(),
            Block::BrownBed(data) => data.value(),
            Block::GreenBed(data) => data.value(),
            Block::RedBed(data) => data.value(),
            Block::BlackBed(data) => data.value(),
            Block::PoweredRail(data) => data.value(),
            Block::DetectorRail(data) => data.value(),
            Block::StickyPiston(data) => data.value(),
            Block::Cobweb => 0,
            Block::Grass => 0,
            Block::Fern => 0,
            Block::DeadBush => 0,
            Block::Seagrass => 0,
            Block::TallSeagrass(data) => data.value(),
            Block::Piston(data) => data.value(),
            Block::PistonHead(data) => data.value(),
            Block::WhiteWool => 0,
            Block::OrangeWool => 0,
            Block::MagentaWool => 0,
            Block::LightBlueWool => 0,
            Block::YellowWool => 0,
            Block::LimeWool => 0,
            Block::PinkWool => 0,
            Block::GrayWool => 0,
            Block::LightGrayWool => 0,
            Block::CyanWool => 0,
            Block::PurpleWool => 0,
            Block::BlueWool => 0,
            Block::BrownWool => 0,
            Block::GreenWool => 0,
            Block::RedWool => 0,
            Block::BlackWool => 0,
            Block::MovingPiston(data) => data.value(),
            Block::Dandelion => 0,
            Block::Poppy => 0,
            Block::BlueOrchid => 0,
            Block::Allium => 0,
            Block::AzureBluet => 0,
            Block::RedTulip => 0,
            Block::OrangeTulip => 0,
            Block::WhiteTulip => 0,
            Block::PinkTulip => 0,
            Block::OxeyeDaisy => 0,
            Block::BrownMushroom => 0,
            Block::RedMushroom => 0,
            Block::GoldBlock => 0,
            Block::IronBlock => 0,
            Block::Bricks => 0,
            Block::Tnt(data) => data.value(),
            Block::Bookshelf => 0,
            Block::MossyCobblestone => 0,
            Block::Obsidian => 0,
            Block::Torch => 0,
            Block::WallTorch(data) => data.value(),
            Block::Fire(data) => data.value(),
            Block::Spawner => 0,
            Block::OakStairs(data) => data.value(),
            Block::Chest(data) => data.value(),
            Block::RedstoneWire(data) => data.value(),
            Block::DiamondOre => 0,
            Block::DiamondBlock => 0,
            Block::CraftingTable => 0,
            Block::Wheat(data) => data.value(),
            Block::Farmland(data) => data.value(),
            Block::Furnace(data) => data.value(),
            Block::Sign(data) => data.value(),
            Block::OakDoor(data) => data.value(),
            Block::Ladder(data) => data.value(),
            Block::Rail(data) => data.value(),
            Block::CobblestoneStairs(data) => data.value(),
            Block::WallSign(data) => data.value(),
            Block::Lever(data) => data.value(),
            Block::StonePressurePlate(data) => data.value(),
            Block::IronDoor(data) => data.value(),
            Block::OakPressurePlate(data) => data.value(),
            Block::SprucePressurePlate(data) => data.value(),
            Block::BirchPressurePlate(data) => data.value(),
            Block::JunglePressurePlate(data) => data.value(),
            Block::AcaciaPressurePlate(data) => data.value(),
            Block::DarkOakPressurePlate(data) => data.value(),
            Block::RedstoneOre(data) => data.value(),
            Block::RedstoneTorch(data) => data.value(),
            Block::RedstoneWallTorch(data) => data.value(),
            Block::StoneButton(data) => data.value(),
            Block::Snow(data) => data.value(),
            Block::Ice => 0,
            Block::SnowBlock => 0,
            Block::Cactus(data) => data.value(),
            Block::Clay => 0,
            Block::SugarCane(data) => data.value(),
            Block::Jukebox(data) => data.value(),
            Block::OakFence(data) => data.value(),
            Block::Pumpkin => 0,
            Block::Netherrack => 0,
            Block::SoulSand => 0,
            Block::Glowstone => 0,
            Block::NetherPortal(data) => data.value(),
            Block::CarvedPumpkin(data) => data.value(),
            Block::JackOLantern(data) => data.value(),
            Block::Cake(data) => data.value(),
            Block::Repeater(data) => data.value(),
            Block::WhiteStainedGlass => 0,
            Block::OrangeStainedGlass => 0,
            Block::MagentaStainedGlass => 0,
            Block::LightBlueStainedGlass => 0,
            Block::YellowStainedGlass => 0,
            Block::LimeStainedGlass => 0,
            Block::PinkStainedGlass => 0,
            Block::GrayStainedGlass => 0,
            Block::LightGrayStainedGlass => 0,
            Block::CyanStainedGlass => 0,
            Block::PurpleStainedGlass => 0,
            Block::BlueStainedGlass => 0,
            Block::BrownStainedGlass => 0,
            Block::GreenStainedGlass => 0,
            Block::RedStainedGlass => 0,
            Block::BlackStainedGlass => 0,
            Block::OakTrapdoor(data) => data.value(),
            Block::SpruceTrapdoor(data) => data.value(),
            Block::BirchTrapdoor(data) => data.value(),
            Block::JungleTrapdoor(data) => data.value(),
            Block::AcaciaTrapdoor(data) => data.value(),
            Block::DarkOakTrapdoor(data) => data.value(),
            Block::InfestedStone => 0,
            Block::InfestedCobblestone => 0,
            Block::InfestedStoneBricks => 0,
            Block::InfestedMossyStoneBricks => 0,
            Block::InfestedCrackedStoneBricks => 0,
            Block::InfestedChiseledStoneBricks => 0,
            Block::StoneBricks => 0,
            Block::MossyStoneBricks => 0,
            Block::CrackedStoneBricks => 0,
            Block::ChiseledStoneBricks => 0,
            Block::BrownMushroomBlock(data) => data.value(),
            Block::RedMushroomBlock(data) => data.value(),
            Block::MushroomStem(data) => data.value(),
            Block::IronBars(data) => data.value(),
            Block::GlassPane(data) => data.value(),
            Block::Melon => 0,
            Block::AttachedPumpkinStem(data) => data.value(),
            Block::AttachedMelonStem(data) => data.value(),
            Block::PumpkinStem(data) => data.value(),
            Block::MelonStem(data) => data.value(),
            Block::Vine(data) => data.value(),
            Block::OakFenceGate(data) => data.value(),
            Block::BrickStairs(data) => data.value(),
            Block::StoneBrickStairs(data) => data.value(),
            Block::Mycelium(data) => data.value(),
            Block::LilyPad => 0,
            Block::NetherBricks => 0,
            Block::NetherBrickFence(data) => data.value(),
            Block::NetherBrickStairs(data) => data.value(),
            Block::NetherWart(data) => data.value(),
            Block::EnchantingTable => 0,
            Block::BrewingStand(data) => data.value(),
            Block::Cauldron(data) => data.value(),
            Block::EndPortal => 0,
            Block::EndPortalFrame(data) => data.value(),
            Block::EndStone => 0,
            Block::DragonEgg => 0,
            Block::RedstoneLamp(data) => data.value(),
            Block::Cocoa(data) => data.value(),
            Block::SandstoneStairs(data) => data.value(),
            Block::EmeraldOre => 0,
            Block::EnderChest(data) => data.value(),
            Block::TripwireHook(data) => data.value(),
            Block::Tripwire(data) => data.value(),
            Block::EmeraldBlock => 0,
            Block::SpruceStairs(data) => data.value(),
            Block::BirchStairs(data) => data.value(),
            Block::JungleStairs(data) => data.value(),
            Block::CommandBlock(data) => data.value(),
            Block::Beacon => 0,
            Block::CobblestoneWall(data) => data.value(),
            Block::MossyCobblestoneWall(data) => data.value(),
            Block::FlowerPot => 0,
            Block::PottedOakSapling => 0,
            Block::PottedSpruceSapling => 0,
            Block::PottedBirchSapling => 0,
            Block::PottedJungleSapling => 0,
            Block::PottedAcaciaSapling => 0,
            Block::PottedDarkOakSapling => 0,
            Block::PottedFern => 0,
            Block::PottedDandelion => 0,
            Block::PottedPoppy => 0,
            Block::PottedBlueOrchid => 0,
            Block::PottedAllium => 0,
            Block::PottedAzureBluet => 0,
            Block::PottedRedTulip => 0,
            Block::PottedOrangeTulip => 0,
            Block::PottedWhiteTulip => 0,
            Block::PottedPinkTulip => 0,
            Block::PottedOxeyeDaisy => 0,
            Block::PottedRedMushroom => 0,
            Block::PottedBrownMushroom => 0,
            Block::PottedDeadBush => 0,
            Block::PottedCactus => 0,
            Block::Carrots(data) => data.value(),
            Block::Potatoes(data) => data.value(),
            Block::OakButton(data) => data.value(),
            Block::SpruceButton(data) => data.value(),
            Block::BirchButton(data) => data.value(),
            Block::JungleButton(data) => data.value(),
            Block::AcaciaButton(data) => data.value(),
            Block::DarkOakButton(data) => data.value(),
            Block::SkeletonWallSkull(data) => data.value(),
            Block::SkeletonSkull(data) => data.value(),
            Block::WitherSkeletonWallSkull(data) => data.value(),
            Block::WitherSkeletonSkull(data) => data.value(),
            Block::ZombieWallHead(data) => data.value(),
            Block::ZombieHead(data) => data.value(),
            Block::PlayerWallHead(data) => data.value(),
            Block::PlayerHead(data) => data.value(),
            Block::CreeperWallHead(data) => data.value(),
            Block::CreeperHead(data) => data.value(),
            Block::DragonWallHead(data) => data.value(),
            Block::DragonHead(data) => data.value(),
            Block::Anvil(data) => data.value(),
            Block::ChippedAnvil(data) => data.value(),
            Block::DamagedAnvil(data) => data.value(),
            Block::TrappedChest(data) => data.value(),
            Block::LightWeightedPressurePlate(data) => data.value(),
            Block::HeavyWeightedPressurePlate(data) => data.value(),
            Block::Comparator(data) => data.value(),
            Block::DaylightDetector(data) => data.value(),
            Block::RedstoneBlock => 0,
            Block::NetherQuartzOre => 0,
            Block::Hopper(data) => data.value(),
            Block::QuartzBlock => 0,
            Block::ChiseledQuartzBlock => 0,
            Block::QuartzPillar(data) => data.value(),
            Block::QuartzStairs(data) => data.value(),
            Block::ActivatorRail(data) => data.value(),
            Block::Dropper(data) => data.value(),
            Block::WhiteTerracotta => 0,
            Block::OrangeTerracotta => 0,
            Block::MagentaTerracotta => 0,
            Block::LightBlueTerracotta => 0,
            Block::YellowTerracotta => 0,
            Block::LimeTerracotta => 0,
            Block::PinkTerracotta => 0,
            Block::GrayTerracotta => 0,
            Block::LightGrayTerracotta => 0,
            Block::CyanTerracotta => 0,
            Block::PurpleTerracotta => 0,
            Block::BlueTerracotta => 0,
            Block::BrownTerracotta => 0,
            Block::GreenTerracotta => 0,
            Block::RedTerracotta => 0,
            Block::BlackTerracotta => 0,
            Block::WhiteStainedGlassPane(data) => data.value(),
            Block::OrangeStainedGlassPane(data) => data.value(),
            Block::MagentaStainedGlassPane(data) => data.value(),
            Block::LightBlueStainedGlassPane(data) => data.value(),
            Block::YellowStainedGlassPane(data) => data.value(),
            Block::LimeStainedGlassPane(data) => data.value(),
            Block::PinkStainedGlassPane(data) => data.value(),
            Block::GrayStainedGlassPane(data) => data.value(),
            Block::LightGrayStainedGlassPane(data) => data.value(),
            Block::CyanStainedGlassPane(data) => data.value(),
            Block::PurpleStainedGlassPane(data) => data.value(),
            Block::BlueStainedGlassPane(data) => data.value(),
            Block::BrownStainedGlassPane(data) => data.value(),
            Block::GreenStainedGlassPane(data) => data.value(),
            Block::RedStainedGlassPane(data) => data.value(),
            Block::BlackStainedGlassPane(data) => data.value(),
            Block::AcaciaStairs(data) => data.value(),
            Block::DarkOakStairs(data) => data.value(),
            Block::SlimeBlock => 0,
            Block::Barrier => 0,
            Block::IronTrapdoor(data) => data.value(),
            Block::Prismarine => 0,
            Block::PrismarineBricks => 0,
            Block::DarkPrismarine => 0,
            Block::PrismarineStairs(data) => data.value(),
            Block::PrismarineBrickStairs(data) => data.value(),
            Block::DarkPrismarineStairs(data) => data.value(),
            Block::PrismarineSlab(data) => data.value(),
            Block::PrismarineBrickSlab(data) => data.value(),
            Block::DarkPrismarineSlab(data) => data.value(),
            Block::SeaLantern => 0,
            Block::HayBlock(data) => data.value(),
            Block::WhiteCarpet => 0,
            Block::OrangeCarpet => 0,
            Block::MagentaCarpet => 0,
            Block::LightBlueCarpet => 0,
            Block::YellowCarpet => 0,
            Block::LimeCarpet => 0,
            Block::PinkCarpet => 0,
            Block::GrayCarpet => 0,
            Block::LightGrayCarpet => 0,
            Block::CyanCarpet => 0,
            Block::PurpleCarpet => 0,
            Block::BlueCarpet => 0,
            Block::BrownCarpet => 0,
            Block::GreenCarpet => 0,
            Block::RedCarpet => 0,
            Block::BlackCarpet => 0,
            Block::Terracotta => 0,
            Block::CoalBlock => 0,
            Block::PackedIce => 0,
            Block::Sunflower(data) => data.value(),
            Block::Lilac(data) => data.value(),
            Block::RoseBush(data) => data.value(),
            Block::Peony(data) => data.value(),
            Block::TallGrass(data) => data.value(),
            Block::LargeFern(data) => data.value(),
            Block::WhiteBanner(data) => data.value(),
            Block::OrangeBanner(data) => data.value(),
            Block::MagentaBanner(data) => data.value(),
            Block::LightBlueBanner(data) => data.value(),
            Block::YellowBanner(data) => data.value(),
            Block::LimeBanner(data) => data.value(),
            Block::PinkBanner(data) => data.value(),
            Block::GrayBanner(data) => data.value(),
            Block::LightGrayBanner(data) => data.value(),
            Block::CyanBanner(data) => data.value(),
            Block::PurpleBanner(data) => data.value(),
            Block::BlueBanner(data) => data.value(),
            Block::BrownBanner(data) => data.value(),
            Block::GreenBanner(data) => data.value(),
            Block::RedBanner(data) => data.value(),
            Block::BlackBanner(data) => data.value(),
            Block::WhiteWallBanner(data) => data.value(),
            Block::OrangeWallBanner(data) => data.value(),
            Block::MagentaWallBanner(data) => data.value(),
            Block::LightBlueWallBanner(data) => data.value(),
            Block::YellowWallBanner(data) => data.value(),
            Block::LimeWallBanner(data) => data.value(),
            Block::PinkWallBanner(data) => data.value(),
            Block::GrayWallBanner(data) => data.value(),
            Block::LightGrayWallBanner(data) => data.value(),
            Block::CyanWallBanner(data) => data.value(),
            Block::PurpleWallBanner(data) => data.value(),
            Block::BlueWallBanner(data) => data.value(),
            Block::BrownWallBanner(data) => data.value(),
            Block::GreenWallBanner(data) => data.value(),
            Block::RedWallBanner(data) => data.value(),
            Block::BlackWallBanner(data) => data.value(),
            Block::RedSandstone => 0,
            Block::ChiseledRedSandstone => 0,
            Block::CutRedSandstone => 0,
            Block::RedSandstoneStairs(data) => data.value(),
            Block::OakSlab(data) => data.value(),
            Block::SpruceSlab(data) => data.value(),
            Block::BirchSlab(data) => data.value(),
            Block::JungleSlab(data) => data.value(),
            Block::AcaciaSlab(data) => data.value(),
            Block::DarkOakSlab(data) => data.value(),
            Block::StoneSlab(data) => data.value(),
            Block::SandstoneSlab(data) => data.value(),
            Block::PetrifiedOakSlab(data) => data.value(),
            Block::CobblestoneSlab(data) => data.value(),
            Block::BrickSlab(data) => data.value(),
            Block::StoneBrickSlab(data) => data.value(),
            Block::NetherBrickSlab(data) => data.value(),
            Block::QuartzSlab(data) => data.value(),
            Block::RedSandstoneSlab(data) => data.value(),
            Block::PurpurSlab(data) => data.value(),
            Block::SmoothStone => 0,
            Block::SmoothSandstone => 0,
            Block::SmoothQuartz => 0,
            Block::SmoothRedSandstone => 0,
            Block::SpruceFenceGate(data) => data.value(),
            Block::BirchFenceGate(data) => data.value(),
            Block::JungleFenceGate(data) => data.value(),
            Block::AcaciaFenceGate(data) => data.value(),
            Block::DarkOakFenceGate(data) => data.value(),
            Block::SpruceFence(data) => data.value(),
            Block::BirchFence(data) => data.value(),
            Block::JungleFence(data) => data.value(),
            Block::AcaciaFence(data) => data.value(),
            Block::DarkOakFence(data) => data.value(),
            Block::SpruceDoor(data) => data.value(),
            Block::BirchDoor(data) => data.value(),
            Block::JungleDoor(data) => data.value(),
            Block::AcaciaDoor(data) => data.value(),
            Block::DarkOakDoor(data) => data.value(),
            Block::EndRod(data) => data.value(),
            Block::ChorusPlant(data) => data.value(),
            Block::ChorusFlower(data) => data.value(),
            Block::PurpurBlock => 0,
            Block::PurpurPillar(data) => data.value(),
            Block::PurpurStairs(data) => data.value(),
            Block::EndStoneBricks => 0,
            Block::Beetroots(data) => data.value(),
            Block::GrassPath => 0,
            Block::EndGateway => 0,
            Block::RepeatingCommandBlock(data) => data.value(),
            Block::ChainCommandBlock(data) => data.value(),
            Block::FrostedIce(data) => data.value(),
            Block::MagmaBlock => 0,
            Block::NetherWartBlock => 0,
            Block::RedNetherBricks => 0,
            Block::BoneBlock(data) => data.value(),
            Block::StructureVoid => 0,
            Block::Observer(data) => data.value(),
            Block::ShulkerBox(data) => data.value(),
            Block::WhiteShulkerBox(data) => data.value(),
            Block::OrangeShulkerBox(data) => data.value(),
            Block::MagentaShulkerBox(data) => data.value(),
            Block::LightBlueShulkerBox(data) => data.value(),
            Block::YellowShulkerBox(data) => data.value(),
            Block::LimeShulkerBox(data) => data.value(),
            Block::PinkShulkerBox(data) => data.value(),
            Block::GrayShulkerBox(data) => data.value(),
            Block::LightGrayShulkerBox(data) => data.value(),
            Block::CyanShulkerBox(data) => data.value(),
            Block::PurpleShulkerBox(data) => data.value(),
            Block::BlueShulkerBox(data) => data.value(),
            Block::BrownShulkerBox(data) => data.value(),
            Block::GreenShulkerBox(data) => data.value(),
            Block::RedShulkerBox(data) => data.value(),
            Block::BlackShulkerBox(data) => data.value(),
            Block::WhiteGlazedTerracotta(data) => data.value(),
            Block::OrangeGlazedTerracotta(data) => data.value(),
            Block::MagentaGlazedTerracotta(data) => data.value(),
            Block::LightBlueGlazedTerracotta(data) => data.value(),
            Block::YellowGlazedTerracotta(data) => data.value(),
            Block::LimeGlazedTerracotta(data) => data.value(),
            Block::PinkGlazedTerracotta(data) => data.value(),
            Block::GrayGlazedTerracotta(data) => data.value(),
            Block::LightGrayGlazedTerracotta(data) => data.value(),
            Block::CyanGlazedTerracotta(data) => data.value(),
            Block::PurpleGlazedTerracotta(data) => data.value(),
            Block::BlueGlazedTerracotta(data) => data.value(),
            Block::BrownGlazedTerracotta(data) => data.value(),
            Block::GreenGlazedTerracotta(data) => data.value(),
            Block::RedGlazedTerracotta(data) => data.value(),
            Block::BlackGlazedTerracotta(data) => data.value(),
            Block::WhiteConcrete => 0,
            Block::OrangeConcrete => 0,
            Block::MagentaConcrete => 0,
            Block::LightBlueConcrete => 0,
            Block::YellowConcrete => 0,
            Block::LimeConcrete => 0,
            Block::PinkConcrete => 0,
            Block::GrayConcrete => 0,
            Block::LightGrayConcrete => 0,
            Block::CyanConcrete => 0,
            Block::PurpleConcrete => 0,
            Block::BlueConcrete => 0,
            Block::BrownConcrete => 0,
            Block::GreenConcrete => 0,
            Block::RedConcrete => 0,
            Block::BlackConcrete => 0,
            Block::WhiteConcretePowder => 0,
            Block::OrangeConcretePowder => 0,
            Block::MagentaConcretePowder => 0,
            Block::LightBlueConcretePowder => 0,
            Block::YellowConcretePowder => 0,
            Block::LimeConcretePowder => 0,
            Block::PinkConcretePowder => 0,
            Block::GrayConcretePowder => 0,
            Block::LightGrayConcretePowder => 0,
            Block::CyanConcretePowder => 0,
            Block::PurpleConcretePowder => 0,
            Block::BlueConcretePowder => 0,
            Block::BrownConcretePowder => 0,
            Block::GreenConcretePowder => 0,
            Block::RedConcretePowder => 0,
            Block::BlackConcretePowder => 0,
            Block::Kelp(data) => data.value(),
            Block::KelpPlant => 0,
            Block::DriedKelpBlock => 0,
            Block::TurtleEgg(data) => data.value(),
            Block::DeadTubeCoralBlock => 0,
            Block::DeadBrainCoralBlock => 0,
            Block::DeadBubbleCoralBlock => 0,
            Block::DeadFireCoralBlock => 0,
            Block::DeadHornCoralBlock => 0,
            Block::TubeCoralBlock => 0,
            Block::BrainCoralBlock => 0,
            Block::BubbleCoralBlock => 0,
            Block::FireCoralBlock => 0,
            Block::HornCoralBlock => 0,
            Block::DeadTubeCoral(data) => data.value(),
            Block::DeadBrainCoral(data) => data.value(),
            Block::DeadBubbleCoral(data) => data.value(),
            Block::DeadFireCoral(data) => data.value(),
            Block::DeadHornCoral(data) => data.value(),
            Block::TubeCoral(data) => data.value(),
            Block::BrainCoral(data) => data.value(),
            Block::BubbleCoral(data) => data.value(),
            Block::FireCoral(data) => data.value(),
            Block::HornCoral(data) => data.value(),
            Block::DeadTubeCoralWallFan(data) => data.value(),
            Block::DeadBrainCoralWallFan(data) => data.value(),
            Block::DeadBubbleCoralWallFan(data) => data.value(),
            Block::DeadFireCoralWallFan(data) => data.value(),
            Block::DeadHornCoralWallFan(data) => data.value(),
            Block::TubeCoralWallFan(data) => data.value(),
            Block::BrainCoralWallFan(data) => data.value(),
            Block::BubbleCoralWallFan(data) => data.value(),
            Block::FireCoralWallFan(data) => data.value(),
            Block::HornCoralWallFan(data) => data.value(),
            Block::DeadTubeCoralFan(data) => data.value(),
            Block::DeadBrainCoralFan(data) => data.value(),
            Block::DeadBubbleCoralFan(data) => data.value(),
            Block::DeadFireCoralFan(data) => data.value(),
            Block::DeadHornCoralFan(data) => data.value(),
            Block::TubeCoralFan(data) => data.value(),
            Block::BrainCoralFan(data) => data.value(),
            Block::BubbleCoralFan(data) => data.value(),
            Block::FireCoralFan(data) => data.value(),
            Block::HornCoralFan(data) => data.value(),
            Block::SeaPickle(data) => data.value(),
            Block::BlueIce => 0,
            Block::Conduit(data) => data.value(),
            Block::VoidAir => 0,
            Block::CaveAir => 0,
            Block::BubbleColumn(data) => data.value(),
            Block::StructureBlock(data) => data.value(),
        }
    }
    pub fn internal_state_id(&self) -> usize {
        let type_offset = INTERNAL_ID_OFFSETS[self.internal_type_id()];
        let data_offset = self.internal_id_data_offset();
        type_offset + data_offset
    }
    pub fn from_name_and_props(name: &str, props: &HashMap<String, String>) -> Option<Self> {
        match name {
            "minecraft:air" => Some(Block::Air),
            "minecraft:stone" => Some(Block::Stone),
            "minecraft:granite" => Some(Block::Granite),
            "minecraft:polished_granite" => Some(Block::PolishedGranite),
            "minecraft:diorite" => Some(Block::Diorite),
            "minecraft:polished_diorite" => Some(Block::PolishedDiorite),
            "minecraft:andesite" => Some(Block::Andesite),
            "minecraft:polished_andesite" => Some(Block::PolishedAndesite),
            "minecraft:grass_block" => {
                let data = GrassBlockData::from_map(props)?;
                Some(Block::GrassBlock(data))
            }
            "minecraft:dirt" => Some(Block::Dirt),
            "minecraft:coarse_dirt" => Some(Block::CoarseDirt),
            "minecraft:podzol" => {
                let data = PodzolData::from_map(props)?;
                Some(Block::Podzol(data))
            }
            "minecraft:cobblestone" => Some(Block::Cobblestone),
            "minecraft:oak_planks" => Some(Block::OakPlanks),
            "minecraft:spruce_planks" => Some(Block::SprucePlanks),
            "minecraft:birch_planks" => Some(Block::BirchPlanks),
            "minecraft:jungle_planks" => Some(Block::JunglePlanks),
            "minecraft:acacia_planks" => Some(Block::AcaciaPlanks),
            "minecraft:dark_oak_planks" => Some(Block::DarkOakPlanks),
            "minecraft:oak_sapling" => {
                let data = OakSaplingData::from_map(props)?;
                Some(Block::OakSapling(data))
            }
            "minecraft:spruce_sapling" => {
                let data = SpruceSaplingData::from_map(props)?;
                Some(Block::SpruceSapling(data))
            }
            "minecraft:birch_sapling" => {
                let data = BirchSaplingData::from_map(props)?;
                Some(Block::BirchSapling(data))
            }
            "minecraft:jungle_sapling" => {
                let data = JungleSaplingData::from_map(props)?;
                Some(Block::JungleSapling(data))
            }
            "minecraft:acacia_sapling" => {
                let data = AcaciaSaplingData::from_map(props)?;
                Some(Block::AcaciaSapling(data))
            }
            "minecraft:dark_oak_sapling" => {
                let data = DarkOakSaplingData::from_map(props)?;
                Some(Block::DarkOakSapling(data))
            }
            "minecraft:bedrock" => Some(Block::Bedrock),
            "minecraft:water" => {
                let data = WaterData::from_map(props)?;
                Some(Block::Water(data))
            }
            "minecraft:lava" => {
                let data = LavaData::from_map(props)?;
                Some(Block::Lava(data))
            }
            "minecraft:sand" => Some(Block::Sand),
            "minecraft:red_sand" => Some(Block::RedSand),
            "minecraft:gravel" => Some(Block::Gravel),
            "minecraft:gold_ore" => Some(Block::GoldOre),
            "minecraft:iron_ore" => Some(Block::IronOre),
            "minecraft:coal_ore" => Some(Block::CoalOre),
            "minecraft:oak_log" => {
                let data = OakLogData::from_map(props)?;
                Some(Block::OakLog(data))
            }
            "minecraft:spruce_log" => {
                let data = SpruceLogData::from_map(props)?;
                Some(Block::SpruceLog(data))
            }
            "minecraft:birch_log" => {
                let data = BirchLogData::from_map(props)?;
                Some(Block::BirchLog(data))
            }
            "minecraft:jungle_log" => {
                let data = JungleLogData::from_map(props)?;
                Some(Block::JungleLog(data))
            }
            "minecraft:acacia_log" => {
                let data = AcaciaLogData::from_map(props)?;
                Some(Block::AcaciaLog(data))
            }
            "minecraft:dark_oak_log" => {
                let data = DarkOakLogData::from_map(props)?;
                Some(Block::DarkOakLog(data))
            }
            "minecraft:stripped_spruce_log" => {
                let data = StrippedSpruceLogData::from_map(props)?;
                Some(Block::StrippedSpruceLog(data))
            }
            "minecraft:stripped_birch_log" => {
                let data = StrippedBirchLogData::from_map(props)?;
                Some(Block::StrippedBirchLog(data))
            }
            "minecraft:stripped_jungle_log" => {
                let data = StrippedJungleLogData::from_map(props)?;
                Some(Block::StrippedJungleLog(data))
            }
            "minecraft:stripped_acacia_log" => {
                let data = StrippedAcaciaLogData::from_map(props)?;
                Some(Block::StrippedAcaciaLog(data))
            }
            "minecraft:stripped_dark_oak_log" => {
                let data = StrippedDarkOakLogData::from_map(props)?;
                Some(Block::StrippedDarkOakLog(data))
            }
            "minecraft:stripped_oak_log" => {
                let data = StrippedOakLogData::from_map(props)?;
                Some(Block::StrippedOakLog(data))
            }
            "minecraft:oak_wood" => {
                let data = OakWoodData::from_map(props)?;
                Some(Block::OakWood(data))
            }
            "minecraft:spruce_wood" => {
                let data = SpruceWoodData::from_map(props)?;
                Some(Block::SpruceWood(data))
            }
            "minecraft:birch_wood" => {
                let data = BirchWoodData::from_map(props)?;
                Some(Block::BirchWood(data))
            }
            "minecraft:jungle_wood" => {
                let data = JungleWoodData::from_map(props)?;
                Some(Block::JungleWood(data))
            }
            "minecraft:acacia_wood" => {
                let data = AcaciaWoodData::from_map(props)?;
                Some(Block::AcaciaWood(data))
            }
            "minecraft:dark_oak_wood" => {
                let data = DarkOakWoodData::from_map(props)?;
                Some(Block::DarkOakWood(data))
            }
            "minecraft:stripped_oak_wood" => {
                let data = StrippedOakWoodData::from_map(props)?;
                Some(Block::StrippedOakWood(data))
            }
            "minecraft:stripped_spruce_wood" => {
                let data = StrippedSpruceWoodData::from_map(props)?;
                Some(Block::StrippedSpruceWood(data))
            }
            "minecraft:stripped_birch_wood" => {
                let data = StrippedBirchWoodData::from_map(props)?;
                Some(Block::StrippedBirchWood(data))
            }
            "minecraft:stripped_jungle_wood" => {
                let data = StrippedJungleWoodData::from_map(props)?;
                Some(Block::StrippedJungleWood(data))
            }
            "minecraft:stripped_acacia_wood" => {
                let data = StrippedAcaciaWoodData::from_map(props)?;
                Some(Block::StrippedAcaciaWood(data))
            }
            "minecraft:stripped_dark_oak_wood" => {
                let data = StrippedDarkOakWoodData::from_map(props)?;
                Some(Block::StrippedDarkOakWood(data))
            }
            "minecraft:oak_leaves" => {
                let data = OakLeavesData::from_map(props)?;
                Some(Block::OakLeaves(data))
            }
            "minecraft:spruce_leaves" => {
                let data = SpruceLeavesData::from_map(props)?;
                Some(Block::SpruceLeaves(data))
            }
            "minecraft:birch_leaves" => {
                let data = BirchLeavesData::from_map(props)?;
                Some(Block::BirchLeaves(data))
            }
            "minecraft:jungle_leaves" => {
                let data = JungleLeavesData::from_map(props)?;
                Some(Block::JungleLeaves(data))
            }
            "minecraft:acacia_leaves" => {
                let data = AcaciaLeavesData::from_map(props)?;
                Some(Block::AcaciaLeaves(data))
            }
            "minecraft:dark_oak_leaves" => {
                let data = DarkOakLeavesData::from_map(props)?;
                Some(Block::DarkOakLeaves(data))
            }
            "minecraft:sponge" => Some(Block::Sponge),
            "minecraft:wet_sponge" => Some(Block::WetSponge),
            "minecraft:glass" => Some(Block::Glass),
            "minecraft:lapis_ore" => Some(Block::LapisOre),
            "minecraft:lapis_block" => Some(Block::LapisBlock),
            "minecraft:dispenser" => {
                let data = DispenserData::from_map(props)?;
                Some(Block::Dispenser(data))
            }
            "minecraft:sandstone" => Some(Block::Sandstone),
            "minecraft:chiseled_sandstone" => Some(Block::ChiseledSandstone),
            "minecraft:cut_sandstone" => Some(Block::CutSandstone),
            "minecraft:note_block" => {
                let data = NoteBlockData::from_map(props)?;
                Some(Block::NoteBlock(data))
            }
            "minecraft:white_bed" => {
                let data = WhiteBedData::from_map(props)?;
                Some(Block::WhiteBed(data))
            }
            "minecraft:orange_bed" => {
                let data = OrangeBedData::from_map(props)?;
                Some(Block::OrangeBed(data))
            }
            "minecraft:magenta_bed" => {
                let data = MagentaBedData::from_map(props)?;
                Some(Block::MagentaBed(data))
            }
            "minecraft:light_blue_bed" => {
                let data = LightBlueBedData::from_map(props)?;
                Some(Block::LightBlueBed(data))
            }
            "minecraft:yellow_bed" => {
                let data = YellowBedData::from_map(props)?;
                Some(Block::YellowBed(data))
            }
            "minecraft:lime_bed" => {
                let data = LimeBedData::from_map(props)?;
                Some(Block::LimeBed(data))
            }
            "minecraft:pink_bed" => {
                let data = PinkBedData::from_map(props)?;
                Some(Block::PinkBed(data))
            }
            "minecraft:gray_bed" => {
                let data = GrayBedData::from_map(props)?;
                Some(Block::GrayBed(data))
            }
            "minecraft:light_gray_bed" => {
                let data = LightGrayBedData::from_map(props)?;
                Some(Block::LightGrayBed(data))
            }
            "minecraft:cyan_bed" => {
                let data = CyanBedData::from_map(props)?;
                Some(Block::CyanBed(data))
            }
            "minecraft:purple_bed" => {
                let data = PurpleBedData::from_map(props)?;
                Some(Block::PurpleBed(data))
            }
            "minecraft:blue_bed" => {
                let data = BlueBedData::from_map(props)?;
                Some(Block::BlueBed(data))
            }
            "minecraft:brown_bed" => {
                let data = BrownBedData::from_map(props)?;
                Some(Block::BrownBed(data))
            }
            "minecraft:green_bed" => {
                let data = GreenBedData::from_map(props)?;
                Some(Block::GreenBed(data))
            }
            "minecraft:red_bed" => {
                let data = RedBedData::from_map(props)?;
                Some(Block::RedBed(data))
            }
            "minecraft:black_bed" => {
                let data = BlackBedData::from_map(props)?;
                Some(Block::BlackBed(data))
            }
            "minecraft:powered_rail" => {
                let data = PoweredRailData::from_map(props)?;
                Some(Block::PoweredRail(data))
            }
            "minecraft:detector_rail" => {
                let data = DetectorRailData::from_map(props)?;
                Some(Block::DetectorRail(data))
            }
            "minecraft:sticky_piston" => {
                let data = StickyPistonData::from_map(props)?;
                Some(Block::StickyPiston(data))
            }
            "minecraft:cobweb" => Some(Block::Cobweb),
            "minecraft:grass" => Some(Block::Grass),
            "minecraft:fern" => Some(Block::Fern),
            "minecraft:dead_bush" => Some(Block::DeadBush),
            "minecraft:seagrass" => Some(Block::Seagrass),
            "minecraft:tall_seagrass" => {
                let data = TallSeagrassData::from_map(props)?;
                Some(Block::TallSeagrass(data))
            }
            "minecraft:piston" => {
                let data = PistonData::from_map(props)?;
                Some(Block::Piston(data))
            }
            "minecraft:piston_head" => {
                let data = PistonHeadData::from_map(props)?;
                Some(Block::PistonHead(data))
            }
            "minecraft:white_wool" => Some(Block::WhiteWool),
            "minecraft:orange_wool" => Some(Block::OrangeWool),
            "minecraft:magenta_wool" => Some(Block::MagentaWool),
            "minecraft:light_blue_wool" => Some(Block::LightBlueWool),
            "minecraft:yellow_wool" => Some(Block::YellowWool),
            "minecraft:lime_wool" => Some(Block::LimeWool),
            "minecraft:pink_wool" => Some(Block::PinkWool),
            "minecraft:gray_wool" => Some(Block::GrayWool),
            "minecraft:light_gray_wool" => Some(Block::LightGrayWool),
            "minecraft:cyan_wool" => Some(Block::CyanWool),
            "minecraft:purple_wool" => Some(Block::PurpleWool),
            "minecraft:blue_wool" => Some(Block::BlueWool),
            "minecraft:brown_wool" => Some(Block::BrownWool),
            "minecraft:green_wool" => Some(Block::GreenWool),
            "minecraft:red_wool" => Some(Block::RedWool),
            "minecraft:black_wool" => Some(Block::BlackWool),
            "minecraft:moving_piston" => {
                let data = MovingPistonData::from_map(props)?;
                Some(Block::MovingPiston(data))
            }
            "minecraft:dandelion" => Some(Block::Dandelion),
            "minecraft:poppy" => Some(Block::Poppy),
            "minecraft:blue_orchid" => Some(Block::BlueOrchid),
            "minecraft:allium" => Some(Block::Allium),
            "minecraft:azure_bluet" => Some(Block::AzureBluet),
            "minecraft:red_tulip" => Some(Block::RedTulip),
            "minecraft:orange_tulip" => Some(Block::OrangeTulip),
            "minecraft:white_tulip" => Some(Block::WhiteTulip),
            "minecraft:pink_tulip" => Some(Block::PinkTulip),
            "minecraft:oxeye_daisy" => Some(Block::OxeyeDaisy),
            "minecraft:brown_mushroom" => Some(Block::BrownMushroom),
            "minecraft:red_mushroom" => Some(Block::RedMushroom),
            "minecraft:gold_block" => Some(Block::GoldBlock),
            "minecraft:iron_block" => Some(Block::IronBlock),
            "minecraft:bricks" => Some(Block::Bricks),
            "minecraft:tnt" => {
                let data = TntData::from_map(props)?;
                Some(Block::Tnt(data))
            }
            "minecraft:bookshelf" => Some(Block::Bookshelf),
            "minecraft:mossy_cobblestone" => Some(Block::MossyCobblestone),
            "minecraft:obsidian" => Some(Block::Obsidian),
            "minecraft:torch" => Some(Block::Torch),
            "minecraft:wall_torch" => {
                let data = WallTorchData::from_map(props)?;
                Some(Block::WallTorch(data))
            }
            "minecraft:fire" => {
                let data = FireData::from_map(props)?;
                Some(Block::Fire(data))
            }
            "minecraft:spawner" => Some(Block::Spawner),
            "minecraft:oak_stairs" => {
                let data = OakStairsData::from_map(props)?;
                Some(Block::OakStairs(data))
            }
            "minecraft:chest" => {
                let data = ChestData::from_map(props)?;
                Some(Block::Chest(data))
            }
            "minecraft:redstone_wire" => {
                let data = RedstoneWireData::from_map(props)?;
                Some(Block::RedstoneWire(data))
            }
            "minecraft:diamond_ore" => Some(Block::DiamondOre),
            "minecraft:diamond_block" => Some(Block::DiamondBlock),
            "minecraft:crafting_table" => Some(Block::CraftingTable),
            "minecraft:wheat" => {
                let data = WheatData::from_map(props)?;
                Some(Block::Wheat(data))
            }
            "minecraft:farmland" => {
                let data = FarmlandData::from_map(props)?;
                Some(Block::Farmland(data))
            }
            "minecraft:furnace" => {
                let data = FurnaceData::from_map(props)?;
                Some(Block::Furnace(data))
            }
            "minecraft:sign" => {
                let data = SignData::from_map(props)?;
                Some(Block::Sign(data))
            }
            "minecraft:oak_door" => {
                let data = OakDoorData::from_map(props)?;
                Some(Block::OakDoor(data))
            }
            "minecraft:ladder" => {
                let data = LadderData::from_map(props)?;
                Some(Block::Ladder(data))
            }
            "minecraft:rail" => {
                let data = RailData::from_map(props)?;
                Some(Block::Rail(data))
            }
            "minecraft:cobblestone_stairs" => {
                let data = CobblestoneStairsData::from_map(props)?;
                Some(Block::CobblestoneStairs(data))
            }
            "minecraft:wall_sign" => {
                let data = WallSignData::from_map(props)?;
                Some(Block::WallSign(data))
            }
            "minecraft:lever" => {
                let data = LeverData::from_map(props)?;
                Some(Block::Lever(data))
            }
            "minecraft:stone_pressure_plate" => {
                let data = StonePressurePlateData::from_map(props)?;
                Some(Block::StonePressurePlate(data))
            }
            "minecraft:iron_door" => {
                let data = IronDoorData::from_map(props)?;
                Some(Block::IronDoor(data))
            }
            "minecraft:oak_pressure_plate" => {
                let data = OakPressurePlateData::from_map(props)?;
                Some(Block::OakPressurePlate(data))
            }
            "minecraft:spruce_pressure_plate" => {
                let data = SprucePressurePlateData::from_map(props)?;
                Some(Block::SprucePressurePlate(data))
            }
            "minecraft:birch_pressure_plate" => {
                let data = BirchPressurePlateData::from_map(props)?;
                Some(Block::BirchPressurePlate(data))
            }
            "minecraft:jungle_pressure_plate" => {
                let data = JunglePressurePlateData::from_map(props)?;
                Some(Block::JunglePressurePlate(data))
            }
            "minecraft:acacia_pressure_plate" => {
                let data = AcaciaPressurePlateData::from_map(props)?;
                Some(Block::AcaciaPressurePlate(data))
            }
            "minecraft:dark_oak_pressure_plate" => {
                let data = DarkOakPressurePlateData::from_map(props)?;
                Some(Block::DarkOakPressurePlate(data))
            }
            "minecraft:redstone_ore" => {
                let data = RedstoneOreData::from_map(props)?;
                Some(Block::RedstoneOre(data))
            }
            "minecraft:redstone_torch" => {
                let data = RedstoneTorchData::from_map(props)?;
                Some(Block::RedstoneTorch(data))
            }
            "minecraft:redstone_wall_torch" => {
                let data = RedstoneWallTorchData::from_map(props)?;
                Some(Block::RedstoneWallTorch(data))
            }
            "minecraft:stone_button" => {
                let data = StoneButtonData::from_map(props)?;
                Some(Block::StoneButton(data))
            }
            "minecraft:snow" => {
                let data = SnowData::from_map(props)?;
                Some(Block::Snow(data))
            }
            "minecraft:ice" => Some(Block::Ice),
            "minecraft:snow_block" => Some(Block::SnowBlock),
            "minecraft:cactus" => {
                let data = CactusData::from_map(props)?;
                Some(Block::Cactus(data))
            }
            "minecraft:clay" => Some(Block::Clay),
            "minecraft:sugar_cane" => {
                let data = SugarCaneData::from_map(props)?;
                Some(Block::SugarCane(data))
            }
            "minecraft:jukebox" => {
                let data = JukeboxData::from_map(props)?;
                Some(Block::Jukebox(data))
            }
            "minecraft:oak_fence" => {
                let data = OakFenceData::from_map(props)?;
                Some(Block::OakFence(data))
            }
            "minecraft:pumpkin" => Some(Block::Pumpkin),
            "minecraft:netherrack" => Some(Block::Netherrack),
            "minecraft:soul_sand" => Some(Block::SoulSand),
            "minecraft:glowstone" => Some(Block::Glowstone),
            "minecraft:nether_portal" => {
                let data = NetherPortalData::from_map(props)?;
                Some(Block::NetherPortal(data))
            }
            "minecraft:carved_pumpkin" => {
                let data = CarvedPumpkinData::from_map(props)?;
                Some(Block::CarvedPumpkin(data))
            }
            "minecraft:jack_o_lantern" => {
                let data = JackOLanternData::from_map(props)?;
                Some(Block::JackOLantern(data))
            }
            "minecraft:cake" => {
                let data = CakeData::from_map(props)?;
                Some(Block::Cake(data))
            }
            "minecraft:repeater" => {
                let data = RepeaterData::from_map(props)?;
                Some(Block::Repeater(data))
            }
            "minecraft:white_stained_glass" => Some(Block::WhiteStainedGlass),
            "minecraft:orange_stained_glass" => Some(Block::OrangeStainedGlass),
            "minecraft:magenta_stained_glass" => Some(Block::MagentaStainedGlass),
            "minecraft:light_blue_stained_glass" => Some(Block::LightBlueStainedGlass),
            "minecraft:yellow_stained_glass" => Some(Block::YellowStainedGlass),
            "minecraft:lime_stained_glass" => Some(Block::LimeStainedGlass),
            "minecraft:pink_stained_glass" => Some(Block::PinkStainedGlass),
            "minecraft:gray_stained_glass" => Some(Block::GrayStainedGlass),
            "minecraft:light_gray_stained_glass" => Some(Block::LightGrayStainedGlass),
            "minecraft:cyan_stained_glass" => Some(Block::CyanStainedGlass),
            "minecraft:purple_stained_glass" => Some(Block::PurpleStainedGlass),
            "minecraft:blue_stained_glass" => Some(Block::BlueStainedGlass),
            "minecraft:brown_stained_glass" => Some(Block::BrownStainedGlass),
            "minecraft:green_stained_glass" => Some(Block::GreenStainedGlass),
            "minecraft:red_stained_glass" => Some(Block::RedStainedGlass),
            "minecraft:black_stained_glass" => Some(Block::BlackStainedGlass),
            "minecraft:oak_trapdoor" => {
                let data = OakTrapdoorData::from_map(props)?;
                Some(Block::OakTrapdoor(data))
            }
            "minecraft:spruce_trapdoor" => {
                let data = SpruceTrapdoorData::from_map(props)?;
                Some(Block::SpruceTrapdoor(data))
            }
            "minecraft:birch_trapdoor" => {
                let data = BirchTrapdoorData::from_map(props)?;
                Some(Block::BirchTrapdoor(data))
            }
            "minecraft:jungle_trapdoor" => {
                let data = JungleTrapdoorData::from_map(props)?;
                Some(Block::JungleTrapdoor(data))
            }
            "minecraft:acacia_trapdoor" => {
                let data = AcaciaTrapdoorData::from_map(props)?;
                Some(Block::AcaciaTrapdoor(data))
            }
            "minecraft:dark_oak_trapdoor" => {
                let data = DarkOakTrapdoorData::from_map(props)?;
                Some(Block::DarkOakTrapdoor(data))
            }
            "minecraft:infested_stone" => Some(Block::InfestedStone),
            "minecraft:infested_cobblestone" => Some(Block::InfestedCobblestone),
            "minecraft:infested_stone_bricks" => Some(Block::InfestedStoneBricks),
            "minecraft:infested_mossy_stone_bricks" => Some(Block::InfestedMossyStoneBricks),
            "minecraft:infested_cracked_stone_bricks" => Some(Block::InfestedCrackedStoneBricks),
            "minecraft:infested_chiseled_stone_bricks" => Some(Block::InfestedChiseledStoneBricks),
            "minecraft:stone_bricks" => Some(Block::StoneBricks),
            "minecraft:mossy_stone_bricks" => Some(Block::MossyStoneBricks),
            "minecraft:cracked_stone_bricks" => Some(Block::CrackedStoneBricks),
            "minecraft:chiseled_stone_bricks" => Some(Block::ChiseledStoneBricks),
            "minecraft:brown_mushroom_block" => {
                let data = BrownMushroomBlockData::from_map(props)?;
                Some(Block::BrownMushroomBlock(data))
            }
            "minecraft:red_mushroom_block" => {
                let data = RedMushroomBlockData::from_map(props)?;
                Some(Block::RedMushroomBlock(data))
            }
            "minecraft:mushroom_stem" => {
                let data = MushroomStemData::from_map(props)?;
                Some(Block::MushroomStem(data))
            }
            "minecraft:iron_bars" => {
                let data = IronBarsData::from_map(props)?;
                Some(Block::IronBars(data))
            }
            "minecraft:glass_pane" => {
                let data = GlassPaneData::from_map(props)?;
                Some(Block::GlassPane(data))
            }
            "minecraft:melon" => Some(Block::Melon),
            "minecraft:attached_pumpkin_stem" => {
                let data = AttachedPumpkinStemData::from_map(props)?;
                Some(Block::AttachedPumpkinStem(data))
            }
            "minecraft:attached_melon_stem" => {
                let data = AttachedMelonStemData::from_map(props)?;
                Some(Block::AttachedMelonStem(data))
            }
            "minecraft:pumpkin_stem" => {
                let data = PumpkinStemData::from_map(props)?;
                Some(Block::PumpkinStem(data))
            }
            "minecraft:melon_stem" => {
                let data = MelonStemData::from_map(props)?;
                Some(Block::MelonStem(data))
            }
            "minecraft:vine" => {
                let data = VineData::from_map(props)?;
                Some(Block::Vine(data))
            }
            "minecraft:oak_fence_gate" => {
                let data = OakFenceGateData::from_map(props)?;
                Some(Block::OakFenceGate(data))
            }
            "minecraft:brick_stairs" => {
                let data = BrickStairsData::from_map(props)?;
                Some(Block::BrickStairs(data))
            }
            "minecraft:stone_brick_stairs" => {
                let data = StoneBrickStairsData::from_map(props)?;
                Some(Block::StoneBrickStairs(data))
            }
            "minecraft:mycelium" => {
                let data = MyceliumData::from_map(props)?;
                Some(Block::Mycelium(data))
            }
            "minecraft:lily_pad" => Some(Block::LilyPad),
            "minecraft:nether_bricks" => Some(Block::NetherBricks),
            "minecraft:nether_brick_fence" => {
                let data = NetherBrickFenceData::from_map(props)?;
                Some(Block::NetherBrickFence(data))
            }
            "minecraft:nether_brick_stairs" => {
                let data = NetherBrickStairsData::from_map(props)?;
                Some(Block::NetherBrickStairs(data))
            }
            "minecraft:nether_wart" => {
                let data = NetherWartData::from_map(props)?;
                Some(Block::NetherWart(data))
            }
            "minecraft:enchanting_table" => Some(Block::EnchantingTable),
            "minecraft:brewing_stand" => {
                let data = BrewingStandData::from_map(props)?;
                Some(Block::BrewingStand(data))
            }
            "minecraft:cauldron" => {
                let data = CauldronData::from_map(props)?;
                Some(Block::Cauldron(data))
            }
            "minecraft:end_portal" => Some(Block::EndPortal),
            "minecraft:end_portal_frame" => {
                let data = EndPortalFrameData::from_map(props)?;
                Some(Block::EndPortalFrame(data))
            }
            "minecraft:end_stone" => Some(Block::EndStone),
            "minecraft:dragon_egg" => Some(Block::DragonEgg),
            "minecraft:redstone_lamp" => {
                let data = RedstoneLampData::from_map(props)?;
                Some(Block::RedstoneLamp(data))
            }
            "minecraft:cocoa" => {
                let data = CocoaData::from_map(props)?;
                Some(Block::Cocoa(data))
            }
            "minecraft:sandstone_stairs" => {
                let data = SandstoneStairsData::from_map(props)?;
                Some(Block::SandstoneStairs(data))
            }
            "minecraft:emerald_ore" => Some(Block::EmeraldOre),
            "minecraft:ender_chest" => {
                let data = EnderChestData::from_map(props)?;
                Some(Block::EnderChest(data))
            }
            "minecraft:tripwire_hook" => {
                let data = TripwireHookData::from_map(props)?;
                Some(Block::TripwireHook(data))
            }
            "minecraft:tripwire" => {
                let data = TripwireData::from_map(props)?;
                Some(Block::Tripwire(data))
            }
            "minecraft:emerald_block" => Some(Block::EmeraldBlock),
            "minecraft:spruce_stairs" => {
                let data = SpruceStairsData::from_map(props)?;
                Some(Block::SpruceStairs(data))
            }
            "minecraft:birch_stairs" => {
                let data = BirchStairsData::from_map(props)?;
                Some(Block::BirchStairs(data))
            }
            "minecraft:jungle_stairs" => {
                let data = JungleStairsData::from_map(props)?;
                Some(Block::JungleStairs(data))
            }
            "minecraft:command_block" => {
                let data = CommandBlockData::from_map(props)?;
                Some(Block::CommandBlock(data))
            }
            "minecraft:beacon" => Some(Block::Beacon),
            "minecraft:cobblestone_wall" => {
                let data = CobblestoneWallData::from_map(props)?;
                Some(Block::CobblestoneWall(data))
            }
            "minecraft:mossy_cobblestone_wall" => {
                let data = MossyCobblestoneWallData::from_map(props)?;
                Some(Block::MossyCobblestoneWall(data))
            }
            "minecraft:flower_pot" => Some(Block::FlowerPot),
            "minecraft:potted_oak_sapling" => Some(Block::PottedOakSapling),
            "minecraft:potted_spruce_sapling" => Some(Block::PottedSpruceSapling),
            "minecraft:potted_birch_sapling" => Some(Block::PottedBirchSapling),
            "minecraft:potted_jungle_sapling" => Some(Block::PottedJungleSapling),
            "minecraft:potted_acacia_sapling" => Some(Block::PottedAcaciaSapling),
            "minecraft:potted_dark_oak_sapling" => Some(Block::PottedDarkOakSapling),
            "minecraft:potted_fern" => Some(Block::PottedFern),
            "minecraft:potted_dandelion" => Some(Block::PottedDandelion),
            "minecraft:potted_poppy" => Some(Block::PottedPoppy),
            "minecraft:potted_blue_orchid" => Some(Block::PottedBlueOrchid),
            "minecraft:potted_allium" => Some(Block::PottedAllium),
            "minecraft:potted_azure_bluet" => Some(Block::PottedAzureBluet),
            "minecraft:potted_red_tulip" => Some(Block::PottedRedTulip),
            "minecraft:potted_orange_tulip" => Some(Block::PottedOrangeTulip),
            "minecraft:potted_white_tulip" => Some(Block::PottedWhiteTulip),
            "minecraft:potted_pink_tulip" => Some(Block::PottedPinkTulip),
            "minecraft:potted_oxeye_daisy" => Some(Block::PottedOxeyeDaisy),
            "minecraft:potted_red_mushroom" => Some(Block::PottedRedMushroom),
            "minecraft:potted_brown_mushroom" => Some(Block::PottedBrownMushroom),
            "minecraft:potted_dead_bush" => Some(Block::PottedDeadBush),
            "minecraft:potted_cactus" => Some(Block::PottedCactus),
            "minecraft:carrots" => {
                let data = CarrotsData::from_map(props)?;
                Some(Block::Carrots(data))
            }
            "minecraft:potatoes" => {
                let data = PotatoesData::from_map(props)?;
                Some(Block::Potatoes(data))
            }
            "minecraft:oak_button" => {
                let data = OakButtonData::from_map(props)?;
                Some(Block::OakButton(data))
            }
            "minecraft:spruce_button" => {
                let data = SpruceButtonData::from_map(props)?;
                Some(Block::SpruceButton(data))
            }
            "minecraft:birch_button" => {
                let data = BirchButtonData::from_map(props)?;
                Some(Block::BirchButton(data))
            }
            "minecraft:jungle_button" => {
                let data = JungleButtonData::from_map(props)?;
                Some(Block::JungleButton(data))
            }
            "minecraft:acacia_button" => {
                let data = AcaciaButtonData::from_map(props)?;
                Some(Block::AcaciaButton(data))
            }
            "minecraft:dark_oak_button" => {
                let data = DarkOakButtonData::from_map(props)?;
                Some(Block::DarkOakButton(data))
            }
            "minecraft:skeleton_wall_skull" => {
                let data = SkeletonWallSkullData::from_map(props)?;
                Some(Block::SkeletonWallSkull(data))
            }
            "minecraft:skeleton_skull" => {
                let data = SkeletonSkullData::from_map(props)?;
                Some(Block::SkeletonSkull(data))
            }
            "minecraft:wither_skeleton_wall_skull" => {
                let data = WitherSkeletonWallSkullData::from_map(props)?;
                Some(Block::WitherSkeletonWallSkull(data))
            }
            "minecraft:wither_skeleton_skull" => {
                let data = WitherSkeletonSkullData::from_map(props)?;
                Some(Block::WitherSkeletonSkull(data))
            }
            "minecraft:zombie_wall_head" => {
                let data = ZombieWallHeadData::from_map(props)?;
                Some(Block::ZombieWallHead(data))
            }
            "minecraft:zombie_head" => {
                let data = ZombieHeadData::from_map(props)?;
                Some(Block::ZombieHead(data))
            }
            "minecraft:player_wall_head" => {
                let data = PlayerWallHeadData::from_map(props)?;
                Some(Block::PlayerWallHead(data))
            }
            "minecraft:player_head" => {
                let data = PlayerHeadData::from_map(props)?;
                Some(Block::PlayerHead(data))
            }
            "minecraft:creeper_wall_head" => {
                let data = CreeperWallHeadData::from_map(props)?;
                Some(Block::CreeperWallHead(data))
            }
            "minecraft:creeper_head" => {
                let data = CreeperHeadData::from_map(props)?;
                Some(Block::CreeperHead(data))
            }
            "minecraft:dragon_wall_head" => {
                let data = DragonWallHeadData::from_map(props)?;
                Some(Block::DragonWallHead(data))
            }
            "minecraft:dragon_head" => {
                let data = DragonHeadData::from_map(props)?;
                Some(Block::DragonHead(data))
            }
            "minecraft:anvil" => {
                let data = AnvilData::from_map(props)?;
                Some(Block::Anvil(data))
            }
            "minecraft:chipped_anvil" => {
                let data = ChippedAnvilData::from_map(props)?;
                Some(Block::ChippedAnvil(data))
            }
            "minecraft:damaged_anvil" => {
                let data = DamagedAnvilData::from_map(props)?;
                Some(Block::DamagedAnvil(data))
            }
            "minecraft:trapped_chest" => {
                let data = TrappedChestData::from_map(props)?;
                Some(Block::TrappedChest(data))
            }
            "minecraft:light_weighted_pressure_plate" => {
                let data = LightWeightedPressurePlateData::from_map(props)?;
                Some(Block::LightWeightedPressurePlate(data))
            }
            "minecraft:heavy_weighted_pressure_plate" => {
                let data = HeavyWeightedPressurePlateData::from_map(props)?;
                Some(Block::HeavyWeightedPressurePlate(data))
            }
            "minecraft:comparator" => {
                let data = ComparatorData::from_map(props)?;
                Some(Block::Comparator(data))
            }
            "minecraft:daylight_detector" => {
                let data = DaylightDetectorData::from_map(props)?;
                Some(Block::DaylightDetector(data))
            }
            "minecraft:redstone_block" => Some(Block::RedstoneBlock),
            "minecraft:nether_quartz_ore" => Some(Block::NetherQuartzOre),
            "minecraft:hopper" => {
                let data = HopperData::from_map(props)?;
                Some(Block::Hopper(data))
            }
            "minecraft:quartz_block" => Some(Block::QuartzBlock),
            "minecraft:chiseled_quartz_block" => Some(Block::ChiseledQuartzBlock),
            "minecraft:quartz_pillar" => {
                let data = QuartzPillarData::from_map(props)?;
                Some(Block::QuartzPillar(data))
            }
            "minecraft:quartz_stairs" => {
                let data = QuartzStairsData::from_map(props)?;
                Some(Block::QuartzStairs(data))
            }
            "minecraft:activator_rail" => {
                let data = ActivatorRailData::from_map(props)?;
                Some(Block::ActivatorRail(data))
            }
            "minecraft:dropper" => {
                let data = DropperData::from_map(props)?;
                Some(Block::Dropper(data))
            }
            "minecraft:white_terracotta" => Some(Block::WhiteTerracotta),
            "minecraft:orange_terracotta" => Some(Block::OrangeTerracotta),
            "minecraft:magenta_terracotta" => Some(Block::MagentaTerracotta),
            "minecraft:light_blue_terracotta" => Some(Block::LightBlueTerracotta),
            "minecraft:yellow_terracotta" => Some(Block::YellowTerracotta),
            "minecraft:lime_terracotta" => Some(Block::LimeTerracotta),
            "minecraft:pink_terracotta" => Some(Block::PinkTerracotta),
            "minecraft:gray_terracotta" => Some(Block::GrayTerracotta),
            "minecraft:light_gray_terracotta" => Some(Block::LightGrayTerracotta),
            "minecraft:cyan_terracotta" => Some(Block::CyanTerracotta),
            "minecraft:purple_terracotta" => Some(Block::PurpleTerracotta),
            "minecraft:blue_terracotta" => Some(Block::BlueTerracotta),
            "minecraft:brown_terracotta" => Some(Block::BrownTerracotta),
            "minecraft:green_terracotta" => Some(Block::GreenTerracotta),
            "minecraft:red_terracotta" => Some(Block::RedTerracotta),
            "minecraft:black_terracotta" => Some(Block::BlackTerracotta),
            "minecraft:white_stained_glass_pane" => {
                let data = WhiteStainedGlassPaneData::from_map(props)?;
                Some(Block::WhiteStainedGlassPane(data))
            }
            "minecraft:orange_stained_glass_pane" => {
                let data = OrangeStainedGlassPaneData::from_map(props)?;
                Some(Block::OrangeStainedGlassPane(data))
            }
            "minecraft:magenta_stained_glass_pane" => {
                let data = MagentaStainedGlassPaneData::from_map(props)?;
                Some(Block::MagentaStainedGlassPane(data))
            }
            "minecraft:light_blue_stained_glass_pane" => {
                let data = LightBlueStainedGlassPaneData::from_map(props)?;
                Some(Block::LightBlueStainedGlassPane(data))
            }
            "minecraft:yellow_stained_glass_pane" => {
                let data = YellowStainedGlassPaneData::from_map(props)?;
                Some(Block::YellowStainedGlassPane(data))
            }
            "minecraft:lime_stained_glass_pane" => {
                let data = LimeStainedGlassPaneData::from_map(props)?;
                Some(Block::LimeStainedGlassPane(data))
            }
            "minecraft:pink_stained_glass_pane" => {
                let data = PinkStainedGlassPaneData::from_map(props)?;
                Some(Block::PinkStainedGlassPane(data))
            }
            "minecraft:gray_stained_glass_pane" => {
                let data = GrayStainedGlassPaneData::from_map(props)?;
                Some(Block::GrayStainedGlassPane(data))
            }
            "minecraft:light_gray_stained_glass_pane" => {
                let data = LightGrayStainedGlassPaneData::from_map(props)?;
                Some(Block::LightGrayStainedGlassPane(data))
            }
            "minecraft:cyan_stained_glass_pane" => {
                let data = CyanStainedGlassPaneData::from_map(props)?;
                Some(Block::CyanStainedGlassPane(data))
            }
            "minecraft:purple_stained_glass_pane" => {
                let data = PurpleStainedGlassPaneData::from_map(props)?;
                Some(Block::PurpleStainedGlassPane(data))
            }
            "minecraft:blue_stained_glass_pane" => {
                let data = BlueStainedGlassPaneData::from_map(props)?;
                Some(Block::BlueStainedGlassPane(data))
            }
            "minecraft:brown_stained_glass_pane" => {
                let data = BrownStainedGlassPaneData::from_map(props)?;
                Some(Block::BrownStainedGlassPane(data))
            }
            "minecraft:green_stained_glass_pane" => {
                let data = GreenStainedGlassPaneData::from_map(props)?;
                Some(Block::GreenStainedGlassPane(data))
            }
            "minecraft:red_stained_glass_pane" => {
                let data = RedStainedGlassPaneData::from_map(props)?;
                Some(Block::RedStainedGlassPane(data))
            }
            "minecraft:black_stained_glass_pane" => {
                let data = BlackStainedGlassPaneData::from_map(props)?;
                Some(Block::BlackStainedGlassPane(data))
            }
            "minecraft:acacia_stairs" => {
                let data = AcaciaStairsData::from_map(props)?;
                Some(Block::AcaciaStairs(data))
            }
            "minecraft:dark_oak_stairs" => {
                let data = DarkOakStairsData::from_map(props)?;
                Some(Block::DarkOakStairs(data))
            }
            "minecraft:slime_block" => Some(Block::SlimeBlock),
            "minecraft:barrier" => Some(Block::Barrier),
            "minecraft:iron_trapdoor" => {
                let data = IronTrapdoorData::from_map(props)?;
                Some(Block::IronTrapdoor(data))
            }
            "minecraft:prismarine" => Some(Block::Prismarine),
            "minecraft:prismarine_bricks" => Some(Block::PrismarineBricks),
            "minecraft:dark_prismarine" => Some(Block::DarkPrismarine),
            "minecraft:prismarine_stairs" => {
                let data = PrismarineStairsData::from_map(props)?;
                Some(Block::PrismarineStairs(data))
            }
            "minecraft:prismarine_brick_stairs" => {
                let data = PrismarineBrickStairsData::from_map(props)?;
                Some(Block::PrismarineBrickStairs(data))
            }
            "minecraft:dark_prismarine_stairs" => {
                let data = DarkPrismarineStairsData::from_map(props)?;
                Some(Block::DarkPrismarineStairs(data))
            }
            "minecraft:prismarine_slab" => {
                let data = PrismarineSlabData::from_map(props)?;
                Some(Block::PrismarineSlab(data))
            }
            "minecraft:prismarine_brick_slab" => {
                let data = PrismarineBrickSlabData::from_map(props)?;
                Some(Block::PrismarineBrickSlab(data))
            }
            "minecraft:dark_prismarine_slab" => {
                let data = DarkPrismarineSlabData::from_map(props)?;
                Some(Block::DarkPrismarineSlab(data))
            }
            "minecraft:sea_lantern" => Some(Block::SeaLantern),
            "minecraft:hay_block" => {
                let data = HayBlockData::from_map(props)?;
                Some(Block::HayBlock(data))
            }
            "minecraft:white_carpet" => Some(Block::WhiteCarpet),
            "minecraft:orange_carpet" => Some(Block::OrangeCarpet),
            "minecraft:magenta_carpet" => Some(Block::MagentaCarpet),
            "minecraft:light_blue_carpet" => Some(Block::LightBlueCarpet),
            "minecraft:yellow_carpet" => Some(Block::YellowCarpet),
            "minecraft:lime_carpet" => Some(Block::LimeCarpet),
            "minecraft:pink_carpet" => Some(Block::PinkCarpet),
            "minecraft:gray_carpet" => Some(Block::GrayCarpet),
            "minecraft:light_gray_carpet" => Some(Block::LightGrayCarpet),
            "minecraft:cyan_carpet" => Some(Block::CyanCarpet),
            "minecraft:purple_carpet" => Some(Block::PurpleCarpet),
            "minecraft:blue_carpet" => Some(Block::BlueCarpet),
            "minecraft:brown_carpet" => Some(Block::BrownCarpet),
            "minecraft:green_carpet" => Some(Block::GreenCarpet),
            "minecraft:red_carpet" => Some(Block::RedCarpet),
            "minecraft:black_carpet" => Some(Block::BlackCarpet),
            "minecraft:terracotta" => Some(Block::Terracotta),
            "minecraft:coal_block" => Some(Block::CoalBlock),
            "minecraft:packed_ice" => Some(Block::PackedIce),
            "minecraft:sunflower" => {
                let data = SunflowerData::from_map(props)?;
                Some(Block::Sunflower(data))
            }
            "minecraft:lilac" => {
                let data = LilacData::from_map(props)?;
                Some(Block::Lilac(data))
            }
            "minecraft:rose_bush" => {
                let data = RoseBushData::from_map(props)?;
                Some(Block::RoseBush(data))
            }
            "minecraft:peony" => {
                let data = PeonyData::from_map(props)?;
                Some(Block::Peony(data))
            }
            "minecraft:tall_grass" => {
                let data = TallGrassData::from_map(props)?;
                Some(Block::TallGrass(data))
            }
            "minecraft:large_fern" => {
                let data = LargeFernData::from_map(props)?;
                Some(Block::LargeFern(data))
            }
            "minecraft:white_banner" => {
                let data = WhiteBannerData::from_map(props)?;
                Some(Block::WhiteBanner(data))
            }
            "minecraft:orange_banner" => {
                let data = OrangeBannerData::from_map(props)?;
                Some(Block::OrangeBanner(data))
            }
            "minecraft:magenta_banner" => {
                let data = MagentaBannerData::from_map(props)?;
                Some(Block::MagentaBanner(data))
            }
            "minecraft:light_blue_banner" => {
                let data = LightBlueBannerData::from_map(props)?;
                Some(Block::LightBlueBanner(data))
            }
            "minecraft:yellow_banner" => {
                let data = YellowBannerData::from_map(props)?;
                Some(Block::YellowBanner(data))
            }
            "minecraft:lime_banner" => {
                let data = LimeBannerData::from_map(props)?;
                Some(Block::LimeBanner(data))
            }
            "minecraft:pink_banner" => {
                let data = PinkBannerData::from_map(props)?;
                Some(Block::PinkBanner(data))
            }
            "minecraft:gray_banner" => {
                let data = GrayBannerData::from_map(props)?;
                Some(Block::GrayBanner(data))
            }
            "minecraft:light_gray_banner" => {
                let data = LightGrayBannerData::from_map(props)?;
                Some(Block::LightGrayBanner(data))
            }
            "minecraft:cyan_banner" => {
                let data = CyanBannerData::from_map(props)?;
                Some(Block::CyanBanner(data))
            }
            "minecraft:purple_banner" => {
                let data = PurpleBannerData::from_map(props)?;
                Some(Block::PurpleBanner(data))
            }
            "minecraft:blue_banner" => {
                let data = BlueBannerData::from_map(props)?;
                Some(Block::BlueBanner(data))
            }
            "minecraft:brown_banner" => {
                let data = BrownBannerData::from_map(props)?;
                Some(Block::BrownBanner(data))
            }
            "minecraft:green_banner" => {
                let data = GreenBannerData::from_map(props)?;
                Some(Block::GreenBanner(data))
            }
            "minecraft:red_banner" => {
                let data = RedBannerData::from_map(props)?;
                Some(Block::RedBanner(data))
            }
            "minecraft:black_banner" => {
                let data = BlackBannerData::from_map(props)?;
                Some(Block::BlackBanner(data))
            }
            "minecraft:white_wall_banner" => {
                let data = WhiteWallBannerData::from_map(props)?;
                Some(Block::WhiteWallBanner(data))
            }
            "minecraft:orange_wall_banner" => {
                let data = OrangeWallBannerData::from_map(props)?;
                Some(Block::OrangeWallBanner(data))
            }
            "minecraft:magenta_wall_banner" => {
                let data = MagentaWallBannerData::from_map(props)?;
                Some(Block::MagentaWallBanner(data))
            }
            "minecraft:light_blue_wall_banner" => {
                let data = LightBlueWallBannerData::from_map(props)?;
                Some(Block::LightBlueWallBanner(data))
            }
            "minecraft:yellow_wall_banner" => {
                let data = YellowWallBannerData::from_map(props)?;
                Some(Block::YellowWallBanner(data))
            }
            "minecraft:lime_wall_banner" => {
                let data = LimeWallBannerData::from_map(props)?;
                Some(Block::LimeWallBanner(data))
            }
            "minecraft:pink_wall_banner" => {
                let data = PinkWallBannerData::from_map(props)?;
                Some(Block::PinkWallBanner(data))
            }
            "minecraft:gray_wall_banner" => {
                let data = GrayWallBannerData::from_map(props)?;
                Some(Block::GrayWallBanner(data))
            }
            "minecraft:light_gray_wall_banner" => {
                let data = LightGrayWallBannerData::from_map(props)?;
                Some(Block::LightGrayWallBanner(data))
            }
            "minecraft:cyan_wall_banner" => {
                let data = CyanWallBannerData::from_map(props)?;
                Some(Block::CyanWallBanner(data))
            }
            "minecraft:purple_wall_banner" => {
                let data = PurpleWallBannerData::from_map(props)?;
                Some(Block::PurpleWallBanner(data))
            }
            "minecraft:blue_wall_banner" => {
                let data = BlueWallBannerData::from_map(props)?;
                Some(Block::BlueWallBanner(data))
            }
            "minecraft:brown_wall_banner" => {
                let data = BrownWallBannerData::from_map(props)?;
                Some(Block::BrownWallBanner(data))
            }
            "minecraft:green_wall_banner" => {
                let data = GreenWallBannerData::from_map(props)?;
                Some(Block::GreenWallBanner(data))
            }
            "minecraft:red_wall_banner" => {
                let data = RedWallBannerData::from_map(props)?;
                Some(Block::RedWallBanner(data))
            }
            "minecraft:black_wall_banner" => {
                let data = BlackWallBannerData::from_map(props)?;
                Some(Block::BlackWallBanner(data))
            }
            "minecraft:red_sandstone" => Some(Block::RedSandstone),
            "minecraft:chiseled_red_sandstone" => Some(Block::ChiseledRedSandstone),
            "minecraft:cut_red_sandstone" => Some(Block::CutRedSandstone),
            "minecraft:red_sandstone_stairs" => {
                let data = RedSandstoneStairsData::from_map(props)?;
                Some(Block::RedSandstoneStairs(data))
            }
            "minecraft:oak_slab" => {
                let data = OakSlabData::from_map(props)?;
                Some(Block::OakSlab(data))
            }
            "minecraft:spruce_slab" => {
                let data = SpruceSlabData::from_map(props)?;
                Some(Block::SpruceSlab(data))
            }
            "minecraft:birch_slab" => {
                let data = BirchSlabData::from_map(props)?;
                Some(Block::BirchSlab(data))
            }
            "minecraft:jungle_slab" => {
                let data = JungleSlabData::from_map(props)?;
                Some(Block::JungleSlab(data))
            }
            "minecraft:acacia_slab" => {
                let data = AcaciaSlabData::from_map(props)?;
                Some(Block::AcaciaSlab(data))
            }
            "minecraft:dark_oak_slab" => {
                let data = DarkOakSlabData::from_map(props)?;
                Some(Block::DarkOakSlab(data))
            }
            "minecraft:stone_slab" => {
                let data = StoneSlabData::from_map(props)?;
                Some(Block::StoneSlab(data))
            }
            "minecraft:sandstone_slab" => {
                let data = SandstoneSlabData::from_map(props)?;
                Some(Block::SandstoneSlab(data))
            }
            "minecraft:petrified_oak_slab" => {
                let data = PetrifiedOakSlabData::from_map(props)?;
                Some(Block::PetrifiedOakSlab(data))
            }
            "minecraft:cobblestone_slab" => {
                let data = CobblestoneSlabData::from_map(props)?;
                Some(Block::CobblestoneSlab(data))
            }
            "minecraft:brick_slab" => {
                let data = BrickSlabData::from_map(props)?;
                Some(Block::BrickSlab(data))
            }
            "minecraft:stone_brick_slab" => {
                let data = StoneBrickSlabData::from_map(props)?;
                Some(Block::StoneBrickSlab(data))
            }
            "minecraft:nether_brick_slab" => {
                let data = NetherBrickSlabData::from_map(props)?;
                Some(Block::NetherBrickSlab(data))
            }
            "minecraft:quartz_slab" => {
                let data = QuartzSlabData::from_map(props)?;
                Some(Block::QuartzSlab(data))
            }
            "minecraft:red_sandstone_slab" => {
                let data = RedSandstoneSlabData::from_map(props)?;
                Some(Block::RedSandstoneSlab(data))
            }
            "minecraft:purpur_slab" => {
                let data = PurpurSlabData::from_map(props)?;
                Some(Block::PurpurSlab(data))
            }
            "minecraft:smooth_stone" => Some(Block::SmoothStone),
            "minecraft:smooth_sandstone" => Some(Block::SmoothSandstone),
            "minecraft:smooth_quartz" => Some(Block::SmoothQuartz),
            "minecraft:smooth_red_sandstone" => Some(Block::SmoothRedSandstone),
            "minecraft:spruce_fence_gate" => {
                let data = SpruceFenceGateData::from_map(props)?;
                Some(Block::SpruceFenceGate(data))
            }
            "minecraft:birch_fence_gate" => {
                let data = BirchFenceGateData::from_map(props)?;
                Some(Block::BirchFenceGate(data))
            }
            "minecraft:jungle_fence_gate" => {
                let data = JungleFenceGateData::from_map(props)?;
                Some(Block::JungleFenceGate(data))
            }
            "minecraft:acacia_fence_gate" => {
                let data = AcaciaFenceGateData::from_map(props)?;
                Some(Block::AcaciaFenceGate(data))
            }
            "minecraft:dark_oak_fence_gate" => {
                let data = DarkOakFenceGateData::from_map(props)?;
                Some(Block::DarkOakFenceGate(data))
            }
            "minecraft:spruce_fence" => {
                let data = SpruceFenceData::from_map(props)?;
                Some(Block::SpruceFence(data))
            }
            "minecraft:birch_fence" => {
                let data = BirchFenceData::from_map(props)?;
                Some(Block::BirchFence(data))
            }
            "minecraft:jungle_fence" => {
                let data = JungleFenceData::from_map(props)?;
                Some(Block::JungleFence(data))
            }
            "minecraft:acacia_fence" => {
                let data = AcaciaFenceData::from_map(props)?;
                Some(Block::AcaciaFence(data))
            }
            "minecraft:dark_oak_fence" => {
                let data = DarkOakFenceData::from_map(props)?;
                Some(Block::DarkOakFence(data))
            }
            "minecraft:spruce_door" => {
                let data = SpruceDoorData::from_map(props)?;
                Some(Block::SpruceDoor(data))
            }
            "minecraft:birch_door" => {
                let data = BirchDoorData::from_map(props)?;
                Some(Block::BirchDoor(data))
            }
            "minecraft:jungle_door" => {
                let data = JungleDoorData::from_map(props)?;
                Some(Block::JungleDoor(data))
            }
            "minecraft:acacia_door" => {
                let data = AcaciaDoorData::from_map(props)?;
                Some(Block::AcaciaDoor(data))
            }
            "minecraft:dark_oak_door" => {
                let data = DarkOakDoorData::from_map(props)?;
                Some(Block::DarkOakDoor(data))
            }
            "minecraft:end_rod" => {
                let data = EndRodData::from_map(props)?;
                Some(Block::EndRod(data))
            }
            "minecraft:chorus_plant" => {
                let data = ChorusPlantData::from_map(props)?;
                Some(Block::ChorusPlant(data))
            }
            "minecraft:chorus_flower" => {
                let data = ChorusFlowerData::from_map(props)?;
                Some(Block::ChorusFlower(data))
            }
            "minecraft:purpur_block" => Some(Block::PurpurBlock),
            "minecraft:purpur_pillar" => {
                let data = PurpurPillarData::from_map(props)?;
                Some(Block::PurpurPillar(data))
            }
            "minecraft:purpur_stairs" => {
                let data = PurpurStairsData::from_map(props)?;
                Some(Block::PurpurStairs(data))
            }
            "minecraft:end_stone_bricks" => Some(Block::EndStoneBricks),
            "minecraft:beetroots" => {
                let data = BeetrootsData::from_map(props)?;
                Some(Block::Beetroots(data))
            }
            "minecraft:grass_path" => Some(Block::GrassPath),
            "minecraft:end_gateway" => Some(Block::EndGateway),
            "minecraft:repeating_command_block" => {
                let data = RepeatingCommandBlockData::from_map(props)?;
                Some(Block::RepeatingCommandBlock(data))
            }
            "minecraft:chain_command_block" => {
                let data = ChainCommandBlockData::from_map(props)?;
                Some(Block::ChainCommandBlock(data))
            }
            "minecraft:frosted_ice" => {
                let data = FrostedIceData::from_map(props)?;
                Some(Block::FrostedIce(data))
            }
            "minecraft:magma_block" => Some(Block::MagmaBlock),
            "minecraft:nether_wart_block" => Some(Block::NetherWartBlock),
            "minecraft:red_nether_bricks" => Some(Block::RedNetherBricks),
            "minecraft:bone_block" => {
                let data = BoneBlockData::from_map(props)?;
                Some(Block::BoneBlock(data))
            }
            "minecraft:structure_void" => Some(Block::StructureVoid),
            "minecraft:observer" => {
                let data = ObserverData::from_map(props)?;
                Some(Block::Observer(data))
            }
            "minecraft:shulker_box" => {
                let data = ShulkerBoxData::from_map(props)?;
                Some(Block::ShulkerBox(data))
            }
            "minecraft:white_shulker_box" => {
                let data = WhiteShulkerBoxData::from_map(props)?;
                Some(Block::WhiteShulkerBox(data))
            }
            "minecraft:orange_shulker_box" => {
                let data = OrangeShulkerBoxData::from_map(props)?;
                Some(Block::OrangeShulkerBox(data))
            }
            "minecraft:magenta_shulker_box" => {
                let data = MagentaShulkerBoxData::from_map(props)?;
                Some(Block::MagentaShulkerBox(data))
            }
            "minecraft:light_blue_shulker_box" => {
                let data = LightBlueShulkerBoxData::from_map(props)?;
                Some(Block::LightBlueShulkerBox(data))
            }
            "minecraft:yellow_shulker_box" => {
                let data = YellowShulkerBoxData::from_map(props)?;
                Some(Block::YellowShulkerBox(data))
            }
            "minecraft:lime_shulker_box" => {
                let data = LimeShulkerBoxData::from_map(props)?;
                Some(Block::LimeShulkerBox(data))
            }
            "minecraft:pink_shulker_box" => {
                let data = PinkShulkerBoxData::from_map(props)?;
                Some(Block::PinkShulkerBox(data))
            }
            "minecraft:gray_shulker_box" => {
                let data = GrayShulkerBoxData::from_map(props)?;
                Some(Block::GrayShulkerBox(data))
            }
            "minecraft:light_gray_shulker_box" => {
                let data = LightGrayShulkerBoxData::from_map(props)?;
                Some(Block::LightGrayShulkerBox(data))
            }
            "minecraft:cyan_shulker_box" => {
                let data = CyanShulkerBoxData::from_map(props)?;
                Some(Block::CyanShulkerBox(data))
            }
            "minecraft:purple_shulker_box" => {
                let data = PurpleShulkerBoxData::from_map(props)?;
                Some(Block::PurpleShulkerBox(data))
            }
            "minecraft:blue_shulker_box" => {
                let data = BlueShulkerBoxData::from_map(props)?;
                Some(Block::BlueShulkerBox(data))
            }
            "minecraft:brown_shulker_box" => {
                let data = BrownShulkerBoxData::from_map(props)?;
                Some(Block::BrownShulkerBox(data))
            }
            "minecraft:green_shulker_box" => {
                let data = GreenShulkerBoxData::from_map(props)?;
                Some(Block::GreenShulkerBox(data))
            }
            "minecraft:red_shulker_box" => {
                let data = RedShulkerBoxData::from_map(props)?;
                Some(Block::RedShulkerBox(data))
            }
            "minecraft:black_shulker_box" => {
                let data = BlackShulkerBoxData::from_map(props)?;
                Some(Block::BlackShulkerBox(data))
            }
            "minecraft:white_glazed_terracotta" => {
                let data = WhiteGlazedTerracottaData::from_map(props)?;
                Some(Block::WhiteGlazedTerracotta(data))
            }
            "minecraft:orange_glazed_terracotta" => {
                let data = OrangeGlazedTerracottaData::from_map(props)?;
                Some(Block::OrangeGlazedTerracotta(data))
            }
            "minecraft:magenta_glazed_terracotta" => {
                let data = MagentaGlazedTerracottaData::from_map(props)?;
                Some(Block::MagentaGlazedTerracotta(data))
            }
            "minecraft:light_blue_glazed_terracotta" => {
                let data = LightBlueGlazedTerracottaData::from_map(props)?;
                Some(Block::LightBlueGlazedTerracotta(data))
            }
            "minecraft:yellow_glazed_terracotta" => {
                let data = YellowGlazedTerracottaData::from_map(props)?;
                Some(Block::YellowGlazedTerracotta(data))
            }
            "minecraft:lime_glazed_terracotta" => {
                let data = LimeGlazedTerracottaData::from_map(props)?;
                Some(Block::LimeGlazedTerracotta(data))
            }
            "minecraft:pink_glazed_terracotta" => {
                let data = PinkGlazedTerracottaData::from_map(props)?;
                Some(Block::PinkGlazedTerracotta(data))
            }
            "minecraft:gray_glazed_terracotta" => {
                let data = GrayGlazedTerracottaData::from_map(props)?;
                Some(Block::GrayGlazedTerracotta(data))
            }
            "minecraft:light_gray_glazed_terracotta" => {
                let data = LightGrayGlazedTerracottaData::from_map(props)?;
                Some(Block::LightGrayGlazedTerracotta(data))
            }
            "minecraft:cyan_glazed_terracotta" => {
                let data = CyanGlazedTerracottaData::from_map(props)?;
                Some(Block::CyanGlazedTerracotta(data))
            }
            "minecraft:purple_glazed_terracotta" => {
                let data = PurpleGlazedTerracottaData::from_map(props)?;
                Some(Block::PurpleGlazedTerracotta(data))
            }
            "minecraft:blue_glazed_terracotta" => {
                let data = BlueGlazedTerracottaData::from_map(props)?;
                Some(Block::BlueGlazedTerracotta(data))
            }
            "minecraft:brown_glazed_terracotta" => {
                let data = BrownGlazedTerracottaData::from_map(props)?;
                Some(Block::BrownGlazedTerracotta(data))
            }
            "minecraft:green_glazed_terracotta" => {
                let data = GreenGlazedTerracottaData::from_map(props)?;
                Some(Block::GreenGlazedTerracotta(data))
            }
            "minecraft:red_glazed_terracotta" => {
                let data = RedGlazedTerracottaData::from_map(props)?;
                Some(Block::RedGlazedTerracotta(data))
            }
            "minecraft:black_glazed_terracotta" => {
                let data = BlackGlazedTerracottaData::from_map(props)?;
                Some(Block::BlackGlazedTerracotta(data))
            }
            "minecraft:white_concrete" => Some(Block::WhiteConcrete),
            "minecraft:orange_concrete" => Some(Block::OrangeConcrete),
            "minecraft:magenta_concrete" => Some(Block::MagentaConcrete),
            "minecraft:light_blue_concrete" => Some(Block::LightBlueConcrete),
            "minecraft:yellow_concrete" => Some(Block::YellowConcrete),
            "minecraft:lime_concrete" => Some(Block::LimeConcrete),
            "minecraft:pink_concrete" => Some(Block::PinkConcrete),
            "minecraft:gray_concrete" => Some(Block::GrayConcrete),
            "minecraft:light_gray_concrete" => Some(Block::LightGrayConcrete),
            "minecraft:cyan_concrete" => Some(Block::CyanConcrete),
            "minecraft:purple_concrete" => Some(Block::PurpleConcrete),
            "minecraft:blue_concrete" => Some(Block::BlueConcrete),
            "minecraft:brown_concrete" => Some(Block::BrownConcrete),
            "minecraft:green_concrete" => Some(Block::GreenConcrete),
            "minecraft:red_concrete" => Some(Block::RedConcrete),
            "minecraft:black_concrete" => Some(Block::BlackConcrete),
            "minecraft:white_concrete_powder" => Some(Block::WhiteConcretePowder),
            "minecraft:orange_concrete_powder" => Some(Block::OrangeConcretePowder),
            "minecraft:magenta_concrete_powder" => Some(Block::MagentaConcretePowder),
            "minecraft:light_blue_concrete_powder" => Some(Block::LightBlueConcretePowder),
            "minecraft:yellow_concrete_powder" => Some(Block::YellowConcretePowder),
            "minecraft:lime_concrete_powder" => Some(Block::LimeConcretePowder),
            "minecraft:pink_concrete_powder" => Some(Block::PinkConcretePowder),
            "minecraft:gray_concrete_powder" => Some(Block::GrayConcretePowder),
            "minecraft:light_gray_concrete_powder" => Some(Block::LightGrayConcretePowder),
            "minecraft:cyan_concrete_powder" => Some(Block::CyanConcretePowder),
            "minecraft:purple_concrete_powder" => Some(Block::PurpleConcretePowder),
            "minecraft:blue_concrete_powder" => Some(Block::BlueConcretePowder),
            "minecraft:brown_concrete_powder" => Some(Block::BrownConcretePowder),
            "minecraft:green_concrete_powder" => Some(Block::GreenConcretePowder),
            "minecraft:red_concrete_powder" => Some(Block::RedConcretePowder),
            "minecraft:black_concrete_powder" => Some(Block::BlackConcretePowder),
            "minecraft:kelp" => {
                let data = KelpData::from_map(props)?;
                Some(Block::Kelp(data))
            }
            "minecraft:kelp_plant" => Some(Block::KelpPlant),
            "minecraft:dried_kelp_block" => Some(Block::DriedKelpBlock),
            "minecraft:turtle_egg" => {
                let data = TurtleEggData::from_map(props)?;
                Some(Block::TurtleEgg(data))
            }
            "minecraft:dead_tube_coral_block" => Some(Block::DeadTubeCoralBlock),
            "minecraft:dead_brain_coral_block" => Some(Block::DeadBrainCoralBlock),
            "minecraft:dead_bubble_coral_block" => Some(Block::DeadBubbleCoralBlock),
            "minecraft:dead_fire_coral_block" => Some(Block::DeadFireCoralBlock),
            "minecraft:dead_horn_coral_block" => Some(Block::DeadHornCoralBlock),
            "minecraft:tube_coral_block" => Some(Block::TubeCoralBlock),
            "minecraft:brain_coral_block" => Some(Block::BrainCoralBlock),
            "minecraft:bubble_coral_block" => Some(Block::BubbleCoralBlock),
            "minecraft:fire_coral_block" => Some(Block::FireCoralBlock),
            "minecraft:horn_coral_block" => Some(Block::HornCoralBlock),
            "minecraft:dead_tube_coral" => {
                let data = DeadTubeCoralData::from_map(props)?;
                Some(Block::DeadTubeCoral(data))
            }
            "minecraft:dead_brain_coral" => {
                let data = DeadBrainCoralData::from_map(props)?;
                Some(Block::DeadBrainCoral(data))
            }
            "minecraft:dead_bubble_coral" => {
                let data = DeadBubbleCoralData::from_map(props)?;
                Some(Block::DeadBubbleCoral(data))
            }
            "minecraft:dead_fire_coral" => {
                let data = DeadFireCoralData::from_map(props)?;
                Some(Block::DeadFireCoral(data))
            }
            "minecraft:dead_horn_coral" => {
                let data = DeadHornCoralData::from_map(props)?;
                Some(Block::DeadHornCoral(data))
            }
            "minecraft:tube_coral" => {
                let data = TubeCoralData::from_map(props)?;
                Some(Block::TubeCoral(data))
            }
            "minecraft:brain_coral" => {
                let data = BrainCoralData::from_map(props)?;
                Some(Block::BrainCoral(data))
            }
            "minecraft:bubble_coral" => {
                let data = BubbleCoralData::from_map(props)?;
                Some(Block::BubbleCoral(data))
            }
            "minecraft:fire_coral" => {
                let data = FireCoralData::from_map(props)?;
                Some(Block::FireCoral(data))
            }
            "minecraft:horn_coral" => {
                let data = HornCoralData::from_map(props)?;
                Some(Block::HornCoral(data))
            }
            "minecraft:dead_tube_coral_wall_fan" => {
                let data = DeadTubeCoralWallFanData::from_map(props)?;
                Some(Block::DeadTubeCoralWallFan(data))
            }
            "minecraft:dead_brain_coral_wall_fan" => {
                let data = DeadBrainCoralWallFanData::from_map(props)?;
                Some(Block::DeadBrainCoralWallFan(data))
            }
            "minecraft:dead_bubble_coral_wall_fan" => {
                let data = DeadBubbleCoralWallFanData::from_map(props)?;
                Some(Block::DeadBubbleCoralWallFan(data))
            }
            "minecraft:dead_fire_coral_wall_fan" => {
                let data = DeadFireCoralWallFanData::from_map(props)?;
                Some(Block::DeadFireCoralWallFan(data))
            }
            "minecraft:dead_horn_coral_wall_fan" => {
                let data = DeadHornCoralWallFanData::from_map(props)?;
                Some(Block::DeadHornCoralWallFan(data))
            }
            "minecraft:tube_coral_wall_fan" => {
                let data = TubeCoralWallFanData::from_map(props)?;
                Some(Block::TubeCoralWallFan(data))
            }
            "minecraft:brain_coral_wall_fan" => {
                let data = BrainCoralWallFanData::from_map(props)?;
                Some(Block::BrainCoralWallFan(data))
            }
            "minecraft:bubble_coral_wall_fan" => {
                let data = BubbleCoralWallFanData::from_map(props)?;
                Some(Block::BubbleCoralWallFan(data))
            }
            "minecraft:fire_coral_wall_fan" => {
                let data = FireCoralWallFanData::from_map(props)?;
                Some(Block::FireCoralWallFan(data))
            }
            "minecraft:horn_coral_wall_fan" => {
                let data = HornCoralWallFanData::from_map(props)?;
                Some(Block::HornCoralWallFan(data))
            }
            "minecraft:dead_tube_coral_fan" => {
                let data = DeadTubeCoralFanData::from_map(props)?;
                Some(Block::DeadTubeCoralFan(data))
            }
            "minecraft:dead_brain_coral_fan" => {
                let data = DeadBrainCoralFanData::from_map(props)?;
                Some(Block::DeadBrainCoralFan(data))
            }
            "minecraft:dead_bubble_coral_fan" => {
                let data = DeadBubbleCoralFanData::from_map(props)?;
                Some(Block::DeadBubbleCoralFan(data))
            }
            "minecraft:dead_fire_coral_fan" => {
                let data = DeadFireCoralFanData::from_map(props)?;
                Some(Block::DeadFireCoralFan(data))
            }
            "minecraft:dead_horn_coral_fan" => {
                let data = DeadHornCoralFanData::from_map(props)?;
                Some(Block::DeadHornCoralFan(data))
            }
            "minecraft:tube_coral_fan" => {
                let data = TubeCoralFanData::from_map(props)?;
                Some(Block::TubeCoralFan(data))
            }
            "minecraft:brain_coral_fan" => {
                let data = BrainCoralFanData::from_map(props)?;
                Some(Block::BrainCoralFan(data))
            }
            "minecraft:bubble_coral_fan" => {
                let data = BubbleCoralFanData::from_map(props)?;
                Some(Block::BubbleCoralFan(data))
            }
            "minecraft:fire_coral_fan" => {
                let data = FireCoralFanData::from_map(props)?;
                Some(Block::FireCoralFan(data))
            }
            "minecraft:horn_coral_fan" => {
                let data = HornCoralFanData::from_map(props)?;
                Some(Block::HornCoralFan(data))
            }
            "minecraft:sea_pickle" => {
                let data = SeaPickleData::from_map(props)?;
                Some(Block::SeaPickle(data))
            }
            "minecraft:blue_ice" => Some(Block::BlueIce),
            "minecraft:conduit" => {
                let data = ConduitData::from_map(props)?;
                Some(Block::Conduit(data))
            }
            "minecraft:void_air" => Some(Block::VoidAir),
            "minecraft:cave_air" => Some(Block::CaveAir),
            "minecraft:bubble_column" => {
                let data = BubbleColumnData::from_map(props)?;
                Some(Block::BubbleColumn(data))
            }
            "minecraft:structure_block" => {
                let data = StructureBlockData::from_map(props)?;
                Some(Block::StructureBlock(data))
            }
            _ => None,
        }
    }
    pub fn from_name_and_default_props(name: &str) -> Option<Self> {
        match name {
            "minecraft:air" => Some(Block::Air),
            "minecraft:stone" => Some(Block::Stone),
            "minecraft:granite" => Some(Block::Granite),
            "minecraft:polished_granite" => Some(Block::PolishedGranite),
            "minecraft:diorite" => Some(Block::Diorite),
            "minecraft:polished_diorite" => Some(Block::PolishedDiorite),
            "minecraft:andesite" => Some(Block::Andesite),
            "minecraft:polished_andesite" => Some(Block::PolishedAndesite),
            "minecraft:grass_block" => {
                let data = GrassBlockData::default();
                Some(Block::GrassBlock(data))
            }
            "minecraft:dirt" => Some(Block::Dirt),
            "minecraft:coarse_dirt" => Some(Block::CoarseDirt),
            "minecraft:podzol" => {
                let data = PodzolData::default();
                Some(Block::Podzol(data))
            }
            "minecraft:cobblestone" => Some(Block::Cobblestone),
            "minecraft:oak_planks" => Some(Block::OakPlanks),
            "minecraft:spruce_planks" => Some(Block::SprucePlanks),
            "minecraft:birch_planks" => Some(Block::BirchPlanks),
            "minecraft:jungle_planks" => Some(Block::JunglePlanks),
            "minecraft:acacia_planks" => Some(Block::AcaciaPlanks),
            "minecraft:dark_oak_planks" => Some(Block::DarkOakPlanks),
            "minecraft:oak_sapling" => {
                let data = OakSaplingData::default();
                Some(Block::OakSapling(data))
            }
            "minecraft:spruce_sapling" => {
                let data = SpruceSaplingData::default();
                Some(Block::SpruceSapling(data))
            }
            "minecraft:birch_sapling" => {
                let data = BirchSaplingData::default();
                Some(Block::BirchSapling(data))
            }
            "minecraft:jungle_sapling" => {
                let data = JungleSaplingData::default();
                Some(Block::JungleSapling(data))
            }
            "minecraft:acacia_sapling" => {
                let data = AcaciaSaplingData::default();
                Some(Block::AcaciaSapling(data))
            }
            "minecraft:dark_oak_sapling" => {
                let data = DarkOakSaplingData::default();
                Some(Block::DarkOakSapling(data))
            }
            "minecraft:bedrock" => Some(Block::Bedrock),
            "minecraft:water" => {
                let data = WaterData::default();
                Some(Block::Water(data))
            }
            "minecraft:lava" => {
                let data = LavaData::default();
                Some(Block::Lava(data))
            }
            "minecraft:sand" => Some(Block::Sand),
            "minecraft:red_sand" => Some(Block::RedSand),
            "minecraft:gravel" => Some(Block::Gravel),
            "minecraft:gold_ore" => Some(Block::GoldOre),
            "minecraft:iron_ore" => Some(Block::IronOre),
            "minecraft:coal_ore" => Some(Block::CoalOre),
            "minecraft:oak_log" => {
                let data = OakLogData::default();
                Some(Block::OakLog(data))
            }
            "minecraft:spruce_log" => {
                let data = SpruceLogData::default();
                Some(Block::SpruceLog(data))
            }
            "minecraft:birch_log" => {
                let data = BirchLogData::default();
                Some(Block::BirchLog(data))
            }
            "minecraft:jungle_log" => {
                let data = JungleLogData::default();
                Some(Block::JungleLog(data))
            }
            "minecraft:acacia_log" => {
                let data = AcaciaLogData::default();
                Some(Block::AcaciaLog(data))
            }
            "minecraft:dark_oak_log" => {
                let data = DarkOakLogData::default();
                Some(Block::DarkOakLog(data))
            }
            "minecraft:stripped_spruce_log" => {
                let data = StrippedSpruceLogData::default();
                Some(Block::StrippedSpruceLog(data))
            }
            "minecraft:stripped_birch_log" => {
                let data = StrippedBirchLogData::default();
                Some(Block::StrippedBirchLog(data))
            }
            "minecraft:stripped_jungle_log" => {
                let data = StrippedJungleLogData::default();
                Some(Block::StrippedJungleLog(data))
            }
            "minecraft:stripped_acacia_log" => {
                let data = StrippedAcaciaLogData::default();
                Some(Block::StrippedAcaciaLog(data))
            }
            "minecraft:stripped_dark_oak_log" => {
                let data = StrippedDarkOakLogData::default();
                Some(Block::StrippedDarkOakLog(data))
            }
            "minecraft:stripped_oak_log" => {
                let data = StrippedOakLogData::default();
                Some(Block::StrippedOakLog(data))
            }
            "minecraft:oak_wood" => {
                let data = OakWoodData::default();
                Some(Block::OakWood(data))
            }
            "minecraft:spruce_wood" => {
                let data = SpruceWoodData::default();
                Some(Block::SpruceWood(data))
            }
            "minecraft:birch_wood" => {
                let data = BirchWoodData::default();
                Some(Block::BirchWood(data))
            }
            "minecraft:jungle_wood" => {
                let data = JungleWoodData::default();
                Some(Block::JungleWood(data))
            }
            "minecraft:acacia_wood" => {
                let data = AcaciaWoodData::default();
                Some(Block::AcaciaWood(data))
            }
            "minecraft:dark_oak_wood" => {
                let data = DarkOakWoodData::default();
                Some(Block::DarkOakWood(data))
            }
            "minecraft:stripped_oak_wood" => {
                let data = StrippedOakWoodData::default();
                Some(Block::StrippedOakWood(data))
            }
            "minecraft:stripped_spruce_wood" => {
                let data = StrippedSpruceWoodData::default();
                Some(Block::StrippedSpruceWood(data))
            }
            "minecraft:stripped_birch_wood" => {
                let data = StrippedBirchWoodData::default();
                Some(Block::StrippedBirchWood(data))
            }
            "minecraft:stripped_jungle_wood" => {
                let data = StrippedJungleWoodData::default();
                Some(Block::StrippedJungleWood(data))
            }
            "minecraft:stripped_acacia_wood" => {
                let data = StrippedAcaciaWoodData::default();
                Some(Block::StrippedAcaciaWood(data))
            }
            "minecraft:stripped_dark_oak_wood" => {
                let data = StrippedDarkOakWoodData::default();
                Some(Block::StrippedDarkOakWood(data))
            }
            "minecraft:oak_leaves" => {
                let data = OakLeavesData::default();
                Some(Block::OakLeaves(data))
            }
            "minecraft:spruce_leaves" => {
                let data = SpruceLeavesData::default();
                Some(Block::SpruceLeaves(data))
            }
            "minecraft:birch_leaves" => {
                let data = BirchLeavesData::default();
                Some(Block::BirchLeaves(data))
            }
            "minecraft:jungle_leaves" => {
                let data = JungleLeavesData::default();
                Some(Block::JungleLeaves(data))
            }
            "minecraft:acacia_leaves" => {
                let data = AcaciaLeavesData::default();
                Some(Block::AcaciaLeaves(data))
            }
            "minecraft:dark_oak_leaves" => {
                let data = DarkOakLeavesData::default();
                Some(Block::DarkOakLeaves(data))
            }
            "minecraft:sponge" => Some(Block::Sponge),
            "minecraft:wet_sponge" => Some(Block::WetSponge),
            "minecraft:glass" => Some(Block::Glass),
            "minecraft:lapis_ore" => Some(Block::LapisOre),
            "minecraft:lapis_block" => Some(Block::LapisBlock),
            "minecraft:dispenser" => {
                let data = DispenserData::default();
                Some(Block::Dispenser(data))
            }
            "minecraft:sandstone" => Some(Block::Sandstone),
            "minecraft:chiseled_sandstone" => Some(Block::ChiseledSandstone),
            "minecraft:cut_sandstone" => Some(Block::CutSandstone),
            "minecraft:note_block" => {
                let data = NoteBlockData::default();
                Some(Block::NoteBlock(data))
            }
            "minecraft:white_bed" => {
                let data = WhiteBedData::default();
                Some(Block::WhiteBed(data))
            }
            "minecraft:orange_bed" => {
                let data = OrangeBedData::default();
                Some(Block::OrangeBed(data))
            }
            "minecraft:magenta_bed" => {
                let data = MagentaBedData::default();
                Some(Block::MagentaBed(data))
            }
            "minecraft:light_blue_bed" => {
                let data = LightBlueBedData::default();
                Some(Block::LightBlueBed(data))
            }
            "minecraft:yellow_bed" => {
                let data = YellowBedData::default();
                Some(Block::YellowBed(data))
            }
            "minecraft:lime_bed" => {
                let data = LimeBedData::default();
                Some(Block::LimeBed(data))
            }
            "minecraft:pink_bed" => {
                let data = PinkBedData::default();
                Some(Block::PinkBed(data))
            }
            "minecraft:gray_bed" => {
                let data = GrayBedData::default();
                Some(Block::GrayBed(data))
            }
            "minecraft:light_gray_bed" => {
                let data = LightGrayBedData::default();
                Some(Block::LightGrayBed(data))
            }
            "minecraft:cyan_bed" => {
                let data = CyanBedData::default();
                Some(Block::CyanBed(data))
            }
            "minecraft:purple_bed" => {
                let data = PurpleBedData::default();
                Some(Block::PurpleBed(data))
            }
            "minecraft:blue_bed" => {
                let data = BlueBedData::default();
                Some(Block::BlueBed(data))
            }
            "minecraft:brown_bed" => {
                let data = BrownBedData::default();
                Some(Block::BrownBed(data))
            }
            "minecraft:green_bed" => {
                let data = GreenBedData::default();
                Some(Block::GreenBed(data))
            }
            "minecraft:red_bed" => {
                let data = RedBedData::default();
                Some(Block::RedBed(data))
            }
            "minecraft:black_bed" => {
                let data = BlackBedData::default();
                Some(Block::BlackBed(data))
            }
            "minecraft:powered_rail" => {
                let data = PoweredRailData::default();
                Some(Block::PoweredRail(data))
            }
            "minecraft:detector_rail" => {
                let data = DetectorRailData::default();
                Some(Block::DetectorRail(data))
            }
            "minecraft:sticky_piston" => {
                let data = StickyPistonData::default();
                Some(Block::StickyPiston(data))
            }
            "minecraft:cobweb" => Some(Block::Cobweb),
            "minecraft:grass" => Some(Block::Grass),
            "minecraft:fern" => Some(Block::Fern),
            "minecraft:dead_bush" => Some(Block::DeadBush),
            "minecraft:seagrass" => Some(Block::Seagrass),
            "minecraft:tall_seagrass" => {
                let data = TallSeagrassData::default();
                Some(Block::TallSeagrass(data))
            }
            "minecraft:piston" => {
                let data = PistonData::default();
                Some(Block::Piston(data))
            }
            "minecraft:piston_head" => {
                let data = PistonHeadData::default();
                Some(Block::PistonHead(data))
            }
            "minecraft:white_wool" => Some(Block::WhiteWool),
            "minecraft:orange_wool" => Some(Block::OrangeWool),
            "minecraft:magenta_wool" => Some(Block::MagentaWool),
            "minecraft:light_blue_wool" => Some(Block::LightBlueWool),
            "minecraft:yellow_wool" => Some(Block::YellowWool),
            "minecraft:lime_wool" => Some(Block::LimeWool),
            "minecraft:pink_wool" => Some(Block::PinkWool),
            "minecraft:gray_wool" => Some(Block::GrayWool),
            "minecraft:light_gray_wool" => Some(Block::LightGrayWool),
            "minecraft:cyan_wool" => Some(Block::CyanWool),
            "minecraft:purple_wool" => Some(Block::PurpleWool),
            "minecraft:blue_wool" => Some(Block::BlueWool),
            "minecraft:brown_wool" => Some(Block::BrownWool),
            "minecraft:green_wool" => Some(Block::GreenWool),
            "minecraft:red_wool" => Some(Block::RedWool),
            "minecraft:black_wool" => Some(Block::BlackWool),
            "minecraft:moving_piston" => {
                let data = MovingPistonData::default();
                Some(Block::MovingPiston(data))
            }
            "minecraft:dandelion" => Some(Block::Dandelion),
            "minecraft:poppy" => Some(Block::Poppy),
            "minecraft:blue_orchid" => Some(Block::BlueOrchid),
            "minecraft:allium" => Some(Block::Allium),
            "minecraft:azure_bluet" => Some(Block::AzureBluet),
            "minecraft:red_tulip" => Some(Block::RedTulip),
            "minecraft:orange_tulip" => Some(Block::OrangeTulip),
            "minecraft:white_tulip" => Some(Block::WhiteTulip),
            "minecraft:pink_tulip" => Some(Block::PinkTulip),
            "minecraft:oxeye_daisy" => Some(Block::OxeyeDaisy),
            "minecraft:brown_mushroom" => Some(Block::BrownMushroom),
            "minecraft:red_mushroom" => Some(Block::RedMushroom),
            "minecraft:gold_block" => Some(Block::GoldBlock),
            "minecraft:iron_block" => Some(Block::IronBlock),
            "minecraft:bricks" => Some(Block::Bricks),
            "minecraft:tnt" => {
                let data = TntData::default();
                Some(Block::Tnt(data))
            }
            "minecraft:bookshelf" => Some(Block::Bookshelf),
            "minecraft:mossy_cobblestone" => Some(Block::MossyCobblestone),
            "minecraft:obsidian" => Some(Block::Obsidian),
            "minecraft:torch" => Some(Block::Torch),
            "minecraft:wall_torch" => {
                let data = WallTorchData::default();
                Some(Block::WallTorch(data))
            }
            "minecraft:fire" => {
                let data = FireData::default();
                Some(Block::Fire(data))
            }
            "minecraft:spawner" => Some(Block::Spawner),
            "minecraft:oak_stairs" => {
                let data = OakStairsData::default();
                Some(Block::OakStairs(data))
            }
            "minecraft:chest" => {
                let data = ChestData::default();
                Some(Block::Chest(data))
            }
            "minecraft:redstone_wire" => {
                let data = RedstoneWireData::default();
                Some(Block::RedstoneWire(data))
            }
            "minecraft:diamond_ore" => Some(Block::DiamondOre),
            "minecraft:diamond_block" => Some(Block::DiamondBlock),
            "minecraft:crafting_table" => Some(Block::CraftingTable),
            "minecraft:wheat" => {
                let data = WheatData::default();
                Some(Block::Wheat(data))
            }
            "minecraft:farmland" => {
                let data = FarmlandData::default();
                Some(Block::Farmland(data))
            }
            "minecraft:furnace" => {
                let data = FurnaceData::default();
                Some(Block::Furnace(data))
            }
            "minecraft:sign" => {
                let data = SignData::default();
                Some(Block::Sign(data))
            }
            "minecraft:oak_door" => {
                let data = OakDoorData::default();
                Some(Block::OakDoor(data))
            }
            "minecraft:ladder" => {
                let data = LadderData::default();
                Some(Block::Ladder(data))
            }
            "minecraft:rail" => {
                let data = RailData::default();
                Some(Block::Rail(data))
            }
            "minecraft:cobblestone_stairs" => {
                let data = CobblestoneStairsData::default();
                Some(Block::CobblestoneStairs(data))
            }
            "minecraft:wall_sign" => {
                let data = WallSignData::default();
                Some(Block::WallSign(data))
            }
            "minecraft:lever" => {
                let data = LeverData::default();
                Some(Block::Lever(data))
            }
            "minecraft:stone_pressure_plate" => {
                let data = StonePressurePlateData::default();
                Some(Block::StonePressurePlate(data))
            }
            "minecraft:iron_door" => {
                let data = IronDoorData::default();
                Some(Block::IronDoor(data))
            }
            "minecraft:oak_pressure_plate" => {
                let data = OakPressurePlateData::default();
                Some(Block::OakPressurePlate(data))
            }
            "minecraft:spruce_pressure_plate" => {
                let data = SprucePressurePlateData::default();
                Some(Block::SprucePressurePlate(data))
            }
            "minecraft:birch_pressure_plate" => {
                let data = BirchPressurePlateData::default();
                Some(Block::BirchPressurePlate(data))
            }
            "minecraft:jungle_pressure_plate" => {
                let data = JunglePressurePlateData::default();
                Some(Block::JunglePressurePlate(data))
            }
            "minecraft:acacia_pressure_plate" => {
                let data = AcaciaPressurePlateData::default();
                Some(Block::AcaciaPressurePlate(data))
            }
            "minecraft:dark_oak_pressure_plate" => {
                let data = DarkOakPressurePlateData::default();
                Some(Block::DarkOakPressurePlate(data))
            }
            "minecraft:redstone_ore" => {
                let data = RedstoneOreData::default();
                Some(Block::RedstoneOre(data))
            }
            "minecraft:redstone_torch" => {
                let data = RedstoneTorchData::default();
                Some(Block::RedstoneTorch(data))
            }
            "minecraft:redstone_wall_torch" => {
                let data = RedstoneWallTorchData::default();
                Some(Block::RedstoneWallTorch(data))
            }
            "minecraft:stone_button" => {
                let data = StoneButtonData::default();
                Some(Block::StoneButton(data))
            }
            "minecraft:snow" => {
                let data = SnowData::default();
                Some(Block::Snow(data))
            }
            "minecraft:ice" => Some(Block::Ice),
            "minecraft:snow_block" => Some(Block::SnowBlock),
            "minecraft:cactus" => {
                let data = CactusData::default();
                Some(Block::Cactus(data))
            }
            "minecraft:clay" => Some(Block::Clay),
            "minecraft:sugar_cane" => {
                let data = SugarCaneData::default();
                Some(Block::SugarCane(data))
            }
            "minecraft:jukebox" => {
                let data = JukeboxData::default();
                Some(Block::Jukebox(data))
            }
            "minecraft:oak_fence" => {
                let data = OakFenceData::default();
                Some(Block::OakFence(data))
            }
            "minecraft:pumpkin" => Some(Block::Pumpkin),
            "minecraft:netherrack" => Some(Block::Netherrack),
            "minecraft:soul_sand" => Some(Block::SoulSand),
            "minecraft:glowstone" => Some(Block::Glowstone),
            "minecraft:nether_portal" => {
                let data = NetherPortalData::default();
                Some(Block::NetherPortal(data))
            }
            "minecraft:carved_pumpkin" => {
                let data = CarvedPumpkinData::default();
                Some(Block::CarvedPumpkin(data))
            }
            "minecraft:jack_o_lantern" => {
                let data = JackOLanternData::default();
                Some(Block::JackOLantern(data))
            }
            "minecraft:cake" => {
                let data = CakeData::default();
                Some(Block::Cake(data))
            }
            "minecraft:repeater" => {
                let data = RepeaterData::default();
                Some(Block::Repeater(data))
            }
            "minecraft:white_stained_glass" => Some(Block::WhiteStainedGlass),
            "minecraft:orange_stained_glass" => Some(Block::OrangeStainedGlass),
            "minecraft:magenta_stained_glass" => Some(Block::MagentaStainedGlass),
            "minecraft:light_blue_stained_glass" => Some(Block::LightBlueStainedGlass),
            "minecraft:yellow_stained_glass" => Some(Block::YellowStainedGlass),
            "minecraft:lime_stained_glass" => Some(Block::LimeStainedGlass),
            "minecraft:pink_stained_glass" => Some(Block::PinkStainedGlass),
            "minecraft:gray_stained_glass" => Some(Block::GrayStainedGlass),
            "minecraft:light_gray_stained_glass" => Some(Block::LightGrayStainedGlass),
            "minecraft:cyan_stained_glass" => Some(Block::CyanStainedGlass),
            "minecraft:purple_stained_glass" => Some(Block::PurpleStainedGlass),
            "minecraft:blue_stained_glass" => Some(Block::BlueStainedGlass),
            "minecraft:brown_stained_glass" => Some(Block::BrownStainedGlass),
            "minecraft:green_stained_glass" => Some(Block::GreenStainedGlass),
            "minecraft:red_stained_glass" => Some(Block::RedStainedGlass),
            "minecraft:black_stained_glass" => Some(Block::BlackStainedGlass),
            "minecraft:oak_trapdoor" => {
                let data = OakTrapdoorData::default();
                Some(Block::OakTrapdoor(data))
            }
            "minecraft:spruce_trapdoor" => {
                let data = SpruceTrapdoorData::default();
                Some(Block::SpruceTrapdoor(data))
            }
            "minecraft:birch_trapdoor" => {
                let data = BirchTrapdoorData::default();
                Some(Block::BirchTrapdoor(data))
            }
            "minecraft:jungle_trapdoor" => {
                let data = JungleTrapdoorData::default();
                Some(Block::JungleTrapdoor(data))
            }
            "minecraft:acacia_trapdoor" => {
                let data = AcaciaTrapdoorData::default();
                Some(Block::AcaciaTrapdoor(data))
            }
            "minecraft:dark_oak_trapdoor" => {
                let data = DarkOakTrapdoorData::default();
                Some(Block::DarkOakTrapdoor(data))
            }
            "minecraft:infested_stone" => Some(Block::InfestedStone),
            "minecraft:infested_cobblestone" => Some(Block::InfestedCobblestone),
            "minecraft:infested_stone_bricks" => Some(Block::InfestedStoneBricks),
            "minecraft:infested_mossy_stone_bricks" => Some(Block::InfestedMossyStoneBricks),
            "minecraft:infested_cracked_stone_bricks" => Some(Block::InfestedCrackedStoneBricks),
            "minecraft:infested_chiseled_stone_bricks" => Some(Block::InfestedChiseledStoneBricks),
            "minecraft:stone_bricks" => Some(Block::StoneBricks),
            "minecraft:mossy_stone_bricks" => Some(Block::MossyStoneBricks),
            "minecraft:cracked_stone_bricks" => Some(Block::CrackedStoneBricks),
            "minecraft:chiseled_stone_bricks" => Some(Block::ChiseledStoneBricks),
            "minecraft:brown_mushroom_block" => {
                let data = BrownMushroomBlockData::default();
                Some(Block::BrownMushroomBlock(data))
            }
            "minecraft:red_mushroom_block" => {
                let data = RedMushroomBlockData::default();
                Some(Block::RedMushroomBlock(data))
            }
            "minecraft:mushroom_stem" => {
                let data = MushroomStemData::default();
                Some(Block::MushroomStem(data))
            }
            "minecraft:iron_bars" => {
                let data = IronBarsData::default();
                Some(Block::IronBars(data))
            }
            "minecraft:glass_pane" => {
                let data = GlassPaneData::default();
                Some(Block::GlassPane(data))
            }
            "minecraft:melon" => Some(Block::Melon),
            "minecraft:attached_pumpkin_stem" => {
                let data = AttachedPumpkinStemData::default();
                Some(Block::AttachedPumpkinStem(data))
            }
            "minecraft:attached_melon_stem" => {
                let data = AttachedMelonStemData::default();
                Some(Block::AttachedMelonStem(data))
            }
            "minecraft:pumpkin_stem" => {
                let data = PumpkinStemData::default();
                Some(Block::PumpkinStem(data))
            }
            "minecraft:melon_stem" => {
                let data = MelonStemData::default();
                Some(Block::MelonStem(data))
            }
            "minecraft:vine" => {
                let data = VineData::default();
                Some(Block::Vine(data))
            }
            "minecraft:oak_fence_gate" => {
                let data = OakFenceGateData::default();
                Some(Block::OakFenceGate(data))
            }
            "minecraft:brick_stairs" => {
                let data = BrickStairsData::default();
                Some(Block::BrickStairs(data))
            }
            "minecraft:stone_brick_stairs" => {
                let data = StoneBrickStairsData::default();
                Some(Block::StoneBrickStairs(data))
            }
            "minecraft:mycelium" => {
                let data = MyceliumData::default();
                Some(Block::Mycelium(data))
            }
            "minecraft:lily_pad" => Some(Block::LilyPad),
            "minecraft:nether_bricks" => Some(Block::NetherBricks),
            "minecraft:nether_brick_fence" => {
                let data = NetherBrickFenceData::default();
                Some(Block::NetherBrickFence(data))
            }
            "minecraft:nether_brick_stairs" => {
                let data = NetherBrickStairsData::default();
                Some(Block::NetherBrickStairs(data))
            }
            "minecraft:nether_wart" => {
                let data = NetherWartData::default();
                Some(Block::NetherWart(data))
            }
            "minecraft:enchanting_table" => Some(Block::EnchantingTable),
            "minecraft:brewing_stand" => {
                let data = BrewingStandData::default();
                Some(Block::BrewingStand(data))
            }
            "minecraft:cauldron" => {
                let data = CauldronData::default();
                Some(Block::Cauldron(data))
            }
            "minecraft:end_portal" => Some(Block::EndPortal),
            "minecraft:end_portal_frame" => {
                let data = EndPortalFrameData::default();
                Some(Block::EndPortalFrame(data))
            }
            "minecraft:end_stone" => Some(Block::EndStone),
            "minecraft:dragon_egg" => Some(Block::DragonEgg),
            "minecraft:redstone_lamp" => {
                let data = RedstoneLampData::default();
                Some(Block::RedstoneLamp(data))
            }
            "minecraft:cocoa" => {
                let data = CocoaData::default();
                Some(Block::Cocoa(data))
            }
            "minecraft:sandstone_stairs" => {
                let data = SandstoneStairsData::default();
                Some(Block::SandstoneStairs(data))
            }
            "minecraft:emerald_ore" => Some(Block::EmeraldOre),
            "minecraft:ender_chest" => {
                let data = EnderChestData::default();
                Some(Block::EnderChest(data))
            }
            "minecraft:tripwire_hook" => {
                let data = TripwireHookData::default();
                Some(Block::TripwireHook(data))
            }
            "minecraft:tripwire" => {
                let data = TripwireData::default();
                Some(Block::Tripwire(data))
            }
            "minecraft:emerald_block" => Some(Block::EmeraldBlock),
            "minecraft:spruce_stairs" => {
                let data = SpruceStairsData::default();
                Some(Block::SpruceStairs(data))
            }
            "minecraft:birch_stairs" => {
                let data = BirchStairsData::default();
                Some(Block::BirchStairs(data))
            }
            "minecraft:jungle_stairs" => {
                let data = JungleStairsData::default();
                Some(Block::JungleStairs(data))
            }
            "minecraft:command_block" => {
                let data = CommandBlockData::default();
                Some(Block::CommandBlock(data))
            }
            "minecraft:beacon" => Some(Block::Beacon),
            "minecraft:cobblestone_wall" => {
                let data = CobblestoneWallData::default();
                Some(Block::CobblestoneWall(data))
            }
            "minecraft:mossy_cobblestone_wall" => {
                let data = MossyCobblestoneWallData::default();
                Some(Block::MossyCobblestoneWall(data))
            }
            "minecraft:flower_pot" => Some(Block::FlowerPot),
            "minecraft:potted_oak_sapling" => Some(Block::PottedOakSapling),
            "minecraft:potted_spruce_sapling" => Some(Block::PottedSpruceSapling),
            "minecraft:potted_birch_sapling" => Some(Block::PottedBirchSapling),
            "minecraft:potted_jungle_sapling" => Some(Block::PottedJungleSapling),
            "minecraft:potted_acacia_sapling" => Some(Block::PottedAcaciaSapling),
            "minecraft:potted_dark_oak_sapling" => Some(Block::PottedDarkOakSapling),
            "minecraft:potted_fern" => Some(Block::PottedFern),
            "minecraft:potted_dandelion" => Some(Block::PottedDandelion),
            "minecraft:potted_poppy" => Some(Block::PottedPoppy),
            "minecraft:potted_blue_orchid" => Some(Block::PottedBlueOrchid),
            "minecraft:potted_allium" => Some(Block::PottedAllium),
            "minecraft:potted_azure_bluet" => Some(Block::PottedAzureBluet),
            "minecraft:potted_red_tulip" => Some(Block::PottedRedTulip),
            "minecraft:potted_orange_tulip" => Some(Block::PottedOrangeTulip),
            "minecraft:potted_white_tulip" => Some(Block::PottedWhiteTulip),
            "minecraft:potted_pink_tulip" => Some(Block::PottedPinkTulip),
            "minecraft:potted_oxeye_daisy" => Some(Block::PottedOxeyeDaisy),
            "minecraft:potted_red_mushroom" => Some(Block::PottedRedMushroom),
            "minecraft:potted_brown_mushroom" => Some(Block::PottedBrownMushroom),
            "minecraft:potted_dead_bush" => Some(Block::PottedDeadBush),
            "minecraft:potted_cactus" => Some(Block::PottedCactus),
            "minecraft:carrots" => {
                let data = CarrotsData::default();
                Some(Block::Carrots(data))
            }
            "minecraft:potatoes" => {
                let data = PotatoesData::default();
                Some(Block::Potatoes(data))
            }
            "minecraft:oak_button" => {
                let data = OakButtonData::default();
                Some(Block::OakButton(data))
            }
            "minecraft:spruce_button" => {
                let data = SpruceButtonData::default();
                Some(Block::SpruceButton(data))
            }
            "minecraft:birch_button" => {
                let data = BirchButtonData::default();
                Some(Block::BirchButton(data))
            }
            "minecraft:jungle_button" => {
                let data = JungleButtonData::default();
                Some(Block::JungleButton(data))
            }
            "minecraft:acacia_button" => {
                let data = AcaciaButtonData::default();
                Some(Block::AcaciaButton(data))
            }
            "minecraft:dark_oak_button" => {
                let data = DarkOakButtonData::default();
                Some(Block::DarkOakButton(data))
            }
            "minecraft:skeleton_wall_skull" => {
                let data = SkeletonWallSkullData::default();
                Some(Block::SkeletonWallSkull(data))
            }
            "minecraft:skeleton_skull" => {
                let data = SkeletonSkullData::default();
                Some(Block::SkeletonSkull(data))
            }
            "minecraft:wither_skeleton_wall_skull" => {
                let data = WitherSkeletonWallSkullData::default();
                Some(Block::WitherSkeletonWallSkull(data))
            }
            "minecraft:wither_skeleton_skull" => {
                let data = WitherSkeletonSkullData::default();
                Some(Block::WitherSkeletonSkull(data))
            }
            "minecraft:zombie_wall_head" => {
                let data = ZombieWallHeadData::default();
                Some(Block::ZombieWallHead(data))
            }
            "minecraft:zombie_head" => {
                let data = ZombieHeadData::default();
                Some(Block::ZombieHead(data))
            }
            "minecraft:player_wall_head" => {
                let data = PlayerWallHeadData::default();
                Some(Block::PlayerWallHead(data))
            }
            "minecraft:player_head" => {
                let data = PlayerHeadData::default();
                Some(Block::PlayerHead(data))
            }
            "minecraft:creeper_wall_head" => {
                let data = CreeperWallHeadData::default();
                Some(Block::CreeperWallHead(data))
            }
            "minecraft:creeper_head" => {
                let data = CreeperHeadData::default();
                Some(Block::CreeperHead(data))
            }
            "minecraft:dragon_wall_head" => {
                let data = DragonWallHeadData::default();
                Some(Block::DragonWallHead(data))
            }
            "minecraft:dragon_head" => {
                let data = DragonHeadData::default();
                Some(Block::DragonHead(data))
            }
            "minecraft:anvil" => {
                let data = AnvilData::default();
                Some(Block::Anvil(data))
            }
            "minecraft:chipped_anvil" => {
                let data = ChippedAnvilData::default();
                Some(Block::ChippedAnvil(data))
            }
            "minecraft:damaged_anvil" => {
                let data = DamagedAnvilData::default();
                Some(Block::DamagedAnvil(data))
            }
            "minecraft:trapped_chest" => {
                let data = TrappedChestData::default();
                Some(Block::TrappedChest(data))
            }
            "minecraft:light_weighted_pressure_plate" => {
                let data = LightWeightedPressurePlateData::default();
                Some(Block::LightWeightedPressurePlate(data))
            }
            "minecraft:heavy_weighted_pressure_plate" => {
                let data = HeavyWeightedPressurePlateData::default();
                Some(Block::HeavyWeightedPressurePlate(data))
            }
            "minecraft:comparator" => {
                let data = ComparatorData::default();
                Some(Block::Comparator(data))
            }
            "minecraft:daylight_detector" => {
                let data = DaylightDetectorData::default();
                Some(Block::DaylightDetector(data))
            }
            "minecraft:redstone_block" => Some(Block::RedstoneBlock),
            "minecraft:nether_quartz_ore" => Some(Block::NetherQuartzOre),
            "minecraft:hopper" => {
                let data = HopperData::default();
                Some(Block::Hopper(data))
            }
            "minecraft:quartz_block" => Some(Block::QuartzBlock),
            "minecraft:chiseled_quartz_block" => Some(Block::ChiseledQuartzBlock),
            "minecraft:quartz_pillar" => {
                let data = QuartzPillarData::default();
                Some(Block::QuartzPillar(data))
            }
            "minecraft:quartz_stairs" => {
                let data = QuartzStairsData::default();
                Some(Block::QuartzStairs(data))
            }
            "minecraft:activator_rail" => {
                let data = ActivatorRailData::default();
                Some(Block::ActivatorRail(data))
            }
            "minecraft:dropper" => {
                let data = DropperData::default();
                Some(Block::Dropper(data))
            }
            "minecraft:white_terracotta" => Some(Block::WhiteTerracotta),
            "minecraft:orange_terracotta" => Some(Block::OrangeTerracotta),
            "minecraft:magenta_terracotta" => Some(Block::MagentaTerracotta),
            "minecraft:light_blue_terracotta" => Some(Block::LightBlueTerracotta),
            "minecraft:yellow_terracotta" => Some(Block::YellowTerracotta),
            "minecraft:lime_terracotta" => Some(Block::LimeTerracotta),
            "minecraft:pink_terracotta" => Some(Block::PinkTerracotta),
            "minecraft:gray_terracotta" => Some(Block::GrayTerracotta),
            "minecraft:light_gray_terracotta" => Some(Block::LightGrayTerracotta),
            "minecraft:cyan_terracotta" => Some(Block::CyanTerracotta),
            "minecraft:purple_terracotta" => Some(Block::PurpleTerracotta),
            "minecraft:blue_terracotta" => Some(Block::BlueTerracotta),
            "minecraft:brown_terracotta" => Some(Block::BrownTerracotta),
            "minecraft:green_terracotta" => Some(Block::GreenTerracotta),
            "minecraft:red_terracotta" => Some(Block::RedTerracotta),
            "minecraft:black_terracotta" => Some(Block::BlackTerracotta),
            "minecraft:white_stained_glass_pane" => {
                let data = WhiteStainedGlassPaneData::default();
                Some(Block::WhiteStainedGlassPane(data))
            }
            "minecraft:orange_stained_glass_pane" => {
                let data = OrangeStainedGlassPaneData::default();
                Some(Block::OrangeStainedGlassPane(data))
            }
            "minecraft:magenta_stained_glass_pane" => {
                let data = MagentaStainedGlassPaneData::default();
                Some(Block::MagentaStainedGlassPane(data))
            }
            "minecraft:light_blue_stained_glass_pane" => {
                let data = LightBlueStainedGlassPaneData::default();
                Some(Block::LightBlueStainedGlassPane(data))
            }
            "minecraft:yellow_stained_glass_pane" => {
                let data = YellowStainedGlassPaneData::default();
                Some(Block::YellowStainedGlassPane(data))
            }
            "minecraft:lime_stained_glass_pane" => {
                let data = LimeStainedGlassPaneData::default();
                Some(Block::LimeStainedGlassPane(data))
            }
            "minecraft:pink_stained_glass_pane" => {
                let data = PinkStainedGlassPaneData::default();
                Some(Block::PinkStainedGlassPane(data))
            }
            "minecraft:gray_stained_glass_pane" => {
                let data = GrayStainedGlassPaneData::default();
                Some(Block::GrayStainedGlassPane(data))
            }
            "minecraft:light_gray_stained_glass_pane" => {
                let data = LightGrayStainedGlassPaneData::default();
                Some(Block::LightGrayStainedGlassPane(data))
            }
            "minecraft:cyan_stained_glass_pane" => {
                let data = CyanStainedGlassPaneData::default();
                Some(Block::CyanStainedGlassPane(data))
            }
            "minecraft:purple_stained_glass_pane" => {
                let data = PurpleStainedGlassPaneData::default();
                Some(Block::PurpleStainedGlassPane(data))
            }
            "minecraft:blue_stained_glass_pane" => {
                let data = BlueStainedGlassPaneData::default();
                Some(Block::BlueStainedGlassPane(data))
            }
            "minecraft:brown_stained_glass_pane" => {
                let data = BrownStainedGlassPaneData::default();
                Some(Block::BrownStainedGlassPane(data))
            }
            "minecraft:green_stained_glass_pane" => {
                let data = GreenStainedGlassPaneData::default();
                Some(Block::GreenStainedGlassPane(data))
            }
            "minecraft:red_stained_glass_pane" => {
                let data = RedStainedGlassPaneData::default();
                Some(Block::RedStainedGlassPane(data))
            }
            "minecraft:black_stained_glass_pane" => {
                let data = BlackStainedGlassPaneData::default();
                Some(Block::BlackStainedGlassPane(data))
            }
            "minecraft:acacia_stairs" => {
                let data = AcaciaStairsData::default();
                Some(Block::AcaciaStairs(data))
            }
            "minecraft:dark_oak_stairs" => {
                let data = DarkOakStairsData::default();
                Some(Block::DarkOakStairs(data))
            }
            "minecraft:slime_block" => Some(Block::SlimeBlock),
            "minecraft:barrier" => Some(Block::Barrier),
            "minecraft:iron_trapdoor" => {
                let data = IronTrapdoorData::default();
                Some(Block::IronTrapdoor(data))
            }
            "minecraft:prismarine" => Some(Block::Prismarine),
            "minecraft:prismarine_bricks" => Some(Block::PrismarineBricks),
            "minecraft:dark_prismarine" => Some(Block::DarkPrismarine),
            "minecraft:prismarine_stairs" => {
                let data = PrismarineStairsData::default();
                Some(Block::PrismarineStairs(data))
            }
            "minecraft:prismarine_brick_stairs" => {
                let data = PrismarineBrickStairsData::default();
                Some(Block::PrismarineBrickStairs(data))
            }
            "minecraft:dark_prismarine_stairs" => {
                let data = DarkPrismarineStairsData::default();
                Some(Block::DarkPrismarineStairs(data))
            }
            "minecraft:prismarine_slab" => {
                let data = PrismarineSlabData::default();
                Some(Block::PrismarineSlab(data))
            }
            "minecraft:prismarine_brick_slab" => {
                let data = PrismarineBrickSlabData::default();
                Some(Block::PrismarineBrickSlab(data))
            }
            "minecraft:dark_prismarine_slab" => {
                let data = DarkPrismarineSlabData::default();
                Some(Block::DarkPrismarineSlab(data))
            }
            "minecraft:sea_lantern" => Some(Block::SeaLantern),
            "minecraft:hay_block" => {
                let data = HayBlockData::default();
                Some(Block::HayBlock(data))
            }
            "minecraft:white_carpet" => Some(Block::WhiteCarpet),
            "minecraft:orange_carpet" => Some(Block::OrangeCarpet),
            "minecraft:magenta_carpet" => Some(Block::MagentaCarpet),
            "minecraft:light_blue_carpet" => Some(Block::LightBlueCarpet),
            "minecraft:yellow_carpet" => Some(Block::YellowCarpet),
            "minecraft:lime_carpet" => Some(Block::LimeCarpet),
            "minecraft:pink_carpet" => Some(Block::PinkCarpet),
            "minecraft:gray_carpet" => Some(Block::GrayCarpet),
            "minecraft:light_gray_carpet" => Some(Block::LightGrayCarpet),
            "minecraft:cyan_carpet" => Some(Block::CyanCarpet),
            "minecraft:purple_carpet" => Some(Block::PurpleCarpet),
            "minecraft:blue_carpet" => Some(Block::BlueCarpet),
            "minecraft:brown_carpet" => Some(Block::BrownCarpet),
            "minecraft:green_carpet" => Some(Block::GreenCarpet),
            "minecraft:red_carpet" => Some(Block::RedCarpet),
            "minecraft:black_carpet" => Some(Block::BlackCarpet),
            "minecraft:terracotta" => Some(Block::Terracotta),
            "minecraft:coal_block" => Some(Block::CoalBlock),
            "minecraft:packed_ice" => Some(Block::PackedIce),
            "minecraft:sunflower" => {
                let data = SunflowerData::default();
                Some(Block::Sunflower(data))
            }
            "minecraft:lilac" => {
                let data = LilacData::default();
                Some(Block::Lilac(data))
            }
            "minecraft:rose_bush" => {
                let data = RoseBushData::default();
                Some(Block::RoseBush(data))
            }
            "minecraft:peony" => {
                let data = PeonyData::default();
                Some(Block::Peony(data))
            }
            "minecraft:tall_grass" => {
                let data = TallGrassData::default();
                Some(Block::TallGrass(data))
            }
            "minecraft:large_fern" => {
                let data = LargeFernData::default();
                Some(Block::LargeFern(data))
            }
            "minecraft:white_banner" => {
                let data = WhiteBannerData::default();
                Some(Block::WhiteBanner(data))
            }
            "minecraft:orange_banner" => {
                let data = OrangeBannerData::default();
                Some(Block::OrangeBanner(data))
            }
            "minecraft:magenta_banner" => {
                let data = MagentaBannerData::default();
                Some(Block::MagentaBanner(data))
            }
            "minecraft:light_blue_banner" => {
                let data = LightBlueBannerData::default();
                Some(Block::LightBlueBanner(data))
            }
            "minecraft:yellow_banner" => {
                let data = YellowBannerData::default();
                Some(Block::YellowBanner(data))
            }
            "minecraft:lime_banner" => {
                let data = LimeBannerData::default();
                Some(Block::LimeBanner(data))
            }
            "minecraft:pink_banner" => {
                let data = PinkBannerData::default();
                Some(Block::PinkBanner(data))
            }
            "minecraft:gray_banner" => {
                let data = GrayBannerData::default();
                Some(Block::GrayBanner(data))
            }
            "minecraft:light_gray_banner" => {
                let data = LightGrayBannerData::default();
                Some(Block::LightGrayBanner(data))
            }
            "minecraft:cyan_banner" => {
                let data = CyanBannerData::default();
                Some(Block::CyanBanner(data))
            }
            "minecraft:purple_banner" => {
                let data = PurpleBannerData::default();
                Some(Block::PurpleBanner(data))
            }
            "minecraft:blue_banner" => {
                let data = BlueBannerData::default();
                Some(Block::BlueBanner(data))
            }
            "minecraft:brown_banner" => {
                let data = BrownBannerData::default();
                Some(Block::BrownBanner(data))
            }
            "minecraft:green_banner" => {
                let data = GreenBannerData::default();
                Some(Block::GreenBanner(data))
            }
            "minecraft:red_banner" => {
                let data = RedBannerData::default();
                Some(Block::RedBanner(data))
            }
            "minecraft:black_banner" => {
                let data = BlackBannerData::default();
                Some(Block::BlackBanner(data))
            }
            "minecraft:white_wall_banner" => {
                let data = WhiteWallBannerData::default();
                Some(Block::WhiteWallBanner(data))
            }
            "minecraft:orange_wall_banner" => {
                let data = OrangeWallBannerData::default();
                Some(Block::OrangeWallBanner(data))
            }
            "minecraft:magenta_wall_banner" => {
                let data = MagentaWallBannerData::default();
                Some(Block::MagentaWallBanner(data))
            }
            "minecraft:light_blue_wall_banner" => {
                let data = LightBlueWallBannerData::default();
                Some(Block::LightBlueWallBanner(data))
            }
            "minecraft:yellow_wall_banner" => {
                let data = YellowWallBannerData::default();
                Some(Block::YellowWallBanner(data))
            }
            "minecraft:lime_wall_banner" => {
                let data = LimeWallBannerData::default();
                Some(Block::LimeWallBanner(data))
            }
            "minecraft:pink_wall_banner" => {
                let data = PinkWallBannerData::default();
                Some(Block::PinkWallBanner(data))
            }
            "minecraft:gray_wall_banner" => {
                let data = GrayWallBannerData::default();
                Some(Block::GrayWallBanner(data))
            }
            "minecraft:light_gray_wall_banner" => {
                let data = LightGrayWallBannerData::default();
                Some(Block::LightGrayWallBanner(data))
            }
            "minecraft:cyan_wall_banner" => {
                let data = CyanWallBannerData::default();
                Some(Block::CyanWallBanner(data))
            }
            "minecraft:purple_wall_banner" => {
                let data = PurpleWallBannerData::default();
                Some(Block::PurpleWallBanner(data))
            }
            "minecraft:blue_wall_banner" => {
                let data = BlueWallBannerData::default();
                Some(Block::BlueWallBanner(data))
            }
            "minecraft:brown_wall_banner" => {
                let data = BrownWallBannerData::default();
                Some(Block::BrownWallBanner(data))
            }
            "minecraft:green_wall_banner" => {
                let data = GreenWallBannerData::default();
                Some(Block::GreenWallBanner(data))
            }
            "minecraft:red_wall_banner" => {
                let data = RedWallBannerData::default();
                Some(Block::RedWallBanner(data))
            }
            "minecraft:black_wall_banner" => {
                let data = BlackWallBannerData::default();
                Some(Block::BlackWallBanner(data))
            }
            "minecraft:red_sandstone" => Some(Block::RedSandstone),
            "minecraft:chiseled_red_sandstone" => Some(Block::ChiseledRedSandstone),
            "minecraft:cut_red_sandstone" => Some(Block::CutRedSandstone),
            "minecraft:red_sandstone_stairs" => {
                let data = RedSandstoneStairsData::default();
                Some(Block::RedSandstoneStairs(data))
            }
            "minecraft:oak_slab" => {
                let data = OakSlabData::default();
                Some(Block::OakSlab(data))
            }
            "minecraft:spruce_slab" => {
                let data = SpruceSlabData::default();
                Some(Block::SpruceSlab(data))
            }
            "minecraft:birch_slab" => {
                let data = BirchSlabData::default();
                Some(Block::BirchSlab(data))
            }
            "minecraft:jungle_slab" => {
                let data = JungleSlabData::default();
                Some(Block::JungleSlab(data))
            }
            "minecraft:acacia_slab" => {
                let data = AcaciaSlabData::default();
                Some(Block::AcaciaSlab(data))
            }
            "minecraft:dark_oak_slab" => {
                let data = DarkOakSlabData::default();
                Some(Block::DarkOakSlab(data))
            }
            "minecraft:stone_slab" => {
                let data = StoneSlabData::default();
                Some(Block::StoneSlab(data))
            }
            "minecraft:sandstone_slab" => {
                let data = SandstoneSlabData::default();
                Some(Block::SandstoneSlab(data))
            }
            "minecraft:petrified_oak_slab" => {
                let data = PetrifiedOakSlabData::default();
                Some(Block::PetrifiedOakSlab(data))
            }
            "minecraft:cobblestone_slab" => {
                let data = CobblestoneSlabData::default();
                Some(Block::CobblestoneSlab(data))
            }
            "minecraft:brick_slab" => {
                let data = BrickSlabData::default();
                Some(Block::BrickSlab(data))
            }
            "minecraft:stone_brick_slab" => {
                let data = StoneBrickSlabData::default();
                Some(Block::StoneBrickSlab(data))
            }
            "minecraft:nether_brick_slab" => {
                let data = NetherBrickSlabData::default();
                Some(Block::NetherBrickSlab(data))
            }
            "minecraft:quartz_slab" => {
                let data = QuartzSlabData::default();
                Some(Block::QuartzSlab(data))
            }
            "minecraft:red_sandstone_slab" => {
                let data = RedSandstoneSlabData::default();
                Some(Block::RedSandstoneSlab(data))
            }
            "minecraft:purpur_slab" => {
                let data = PurpurSlabData::default();
                Some(Block::PurpurSlab(data))
            }
            "minecraft:smooth_stone" => Some(Block::SmoothStone),
            "minecraft:smooth_sandstone" => Some(Block::SmoothSandstone),
            "minecraft:smooth_quartz" => Some(Block::SmoothQuartz),
            "minecraft:smooth_red_sandstone" => Some(Block::SmoothRedSandstone),
            "minecraft:spruce_fence_gate" => {
                let data = SpruceFenceGateData::default();
                Some(Block::SpruceFenceGate(data))
            }
            "minecraft:birch_fence_gate" => {
                let data = BirchFenceGateData::default();
                Some(Block::BirchFenceGate(data))
            }
            "minecraft:jungle_fence_gate" => {
                let data = JungleFenceGateData::default();
                Some(Block::JungleFenceGate(data))
            }
            "minecraft:acacia_fence_gate" => {
                let data = AcaciaFenceGateData::default();
                Some(Block::AcaciaFenceGate(data))
            }
            "minecraft:dark_oak_fence_gate" => {
                let data = DarkOakFenceGateData::default();
                Some(Block::DarkOakFenceGate(data))
            }
            "minecraft:spruce_fence" => {
                let data = SpruceFenceData::default();
                Some(Block::SpruceFence(data))
            }
            "minecraft:birch_fence" => {
                let data = BirchFenceData::default();
                Some(Block::BirchFence(data))
            }
            "minecraft:jungle_fence" => {
                let data = JungleFenceData::default();
                Some(Block::JungleFence(data))
            }
            "minecraft:acacia_fence" => {
                let data = AcaciaFenceData::default();
                Some(Block::AcaciaFence(data))
            }
            "minecraft:dark_oak_fence" => {
                let data = DarkOakFenceData::default();
                Some(Block::DarkOakFence(data))
            }
            "minecraft:spruce_door" => {
                let data = SpruceDoorData::default();
                Some(Block::SpruceDoor(data))
            }
            "minecraft:birch_door" => {
                let data = BirchDoorData::default();
                Some(Block::BirchDoor(data))
            }
            "minecraft:jungle_door" => {
                let data = JungleDoorData::default();
                Some(Block::JungleDoor(data))
            }
            "minecraft:acacia_door" => {
                let data = AcaciaDoorData::default();
                Some(Block::AcaciaDoor(data))
            }
            "minecraft:dark_oak_door" => {
                let data = DarkOakDoorData::default();
                Some(Block::DarkOakDoor(data))
            }
            "minecraft:end_rod" => {
                let data = EndRodData::default();
                Some(Block::EndRod(data))
            }
            "minecraft:chorus_plant" => {
                let data = ChorusPlantData::default();
                Some(Block::ChorusPlant(data))
            }
            "minecraft:chorus_flower" => {
                let data = ChorusFlowerData::default();
                Some(Block::ChorusFlower(data))
            }
            "minecraft:purpur_block" => Some(Block::PurpurBlock),
            "minecraft:purpur_pillar" => {
                let data = PurpurPillarData::default();
                Some(Block::PurpurPillar(data))
            }
            "minecraft:purpur_stairs" => {
                let data = PurpurStairsData::default();
                Some(Block::PurpurStairs(data))
            }
            "minecraft:end_stone_bricks" => Some(Block::EndStoneBricks),
            "minecraft:beetroots" => {
                let data = BeetrootsData::default();
                Some(Block::Beetroots(data))
            }
            "minecraft:grass_path" => Some(Block::GrassPath),
            "minecraft:end_gateway" => Some(Block::EndGateway),
            "minecraft:repeating_command_block" => {
                let data = RepeatingCommandBlockData::default();
                Some(Block::RepeatingCommandBlock(data))
            }
            "minecraft:chain_command_block" => {
                let data = ChainCommandBlockData::default();
                Some(Block::ChainCommandBlock(data))
            }
            "minecraft:frosted_ice" => {
                let data = FrostedIceData::default();
                Some(Block::FrostedIce(data))
            }
            "minecraft:magma_block" => Some(Block::MagmaBlock),
            "minecraft:nether_wart_block" => Some(Block::NetherWartBlock),
            "minecraft:red_nether_bricks" => Some(Block::RedNetherBricks),
            "minecraft:bone_block" => {
                let data = BoneBlockData::default();
                Some(Block::BoneBlock(data))
            }
            "minecraft:structure_void" => Some(Block::StructureVoid),
            "minecraft:observer" => {
                let data = ObserverData::default();
                Some(Block::Observer(data))
            }
            "minecraft:shulker_box" => {
                let data = ShulkerBoxData::default();
                Some(Block::ShulkerBox(data))
            }
            "minecraft:white_shulker_box" => {
                let data = WhiteShulkerBoxData::default();
                Some(Block::WhiteShulkerBox(data))
            }
            "minecraft:orange_shulker_box" => {
                let data = OrangeShulkerBoxData::default();
                Some(Block::OrangeShulkerBox(data))
            }
            "minecraft:magenta_shulker_box" => {
                let data = MagentaShulkerBoxData::default();
                Some(Block::MagentaShulkerBox(data))
            }
            "minecraft:light_blue_shulker_box" => {
                let data = LightBlueShulkerBoxData::default();
                Some(Block::LightBlueShulkerBox(data))
            }
            "minecraft:yellow_shulker_box" => {
                let data = YellowShulkerBoxData::default();
                Some(Block::YellowShulkerBox(data))
            }
            "minecraft:lime_shulker_box" => {
                let data = LimeShulkerBoxData::default();
                Some(Block::LimeShulkerBox(data))
            }
            "minecraft:pink_shulker_box" => {
                let data = PinkShulkerBoxData::default();
                Some(Block::PinkShulkerBox(data))
            }
            "minecraft:gray_shulker_box" => {
                let data = GrayShulkerBoxData::default();
                Some(Block::GrayShulkerBox(data))
            }
            "minecraft:light_gray_shulker_box" => {
                let data = LightGrayShulkerBoxData::default();
                Some(Block::LightGrayShulkerBox(data))
            }
            "minecraft:cyan_shulker_box" => {
                let data = CyanShulkerBoxData::default();
                Some(Block::CyanShulkerBox(data))
            }
            "minecraft:purple_shulker_box" => {
                let data = PurpleShulkerBoxData::default();
                Some(Block::PurpleShulkerBox(data))
            }
            "minecraft:blue_shulker_box" => {
                let data = BlueShulkerBoxData::default();
                Some(Block::BlueShulkerBox(data))
            }
            "minecraft:brown_shulker_box" => {
                let data = BrownShulkerBoxData::default();
                Some(Block::BrownShulkerBox(data))
            }
            "minecraft:green_shulker_box" => {
                let data = GreenShulkerBoxData::default();
                Some(Block::GreenShulkerBox(data))
            }
            "minecraft:red_shulker_box" => {
                let data = RedShulkerBoxData::default();
                Some(Block::RedShulkerBox(data))
            }
            "minecraft:black_shulker_box" => {
                let data = BlackShulkerBoxData::default();
                Some(Block::BlackShulkerBox(data))
            }
            "minecraft:white_glazed_terracotta" => {
                let data = WhiteGlazedTerracottaData::default();
                Some(Block::WhiteGlazedTerracotta(data))
            }
            "minecraft:orange_glazed_terracotta" => {
                let data = OrangeGlazedTerracottaData::default();
                Some(Block::OrangeGlazedTerracotta(data))
            }
            "minecraft:magenta_glazed_terracotta" => {
                let data = MagentaGlazedTerracottaData::default();
                Some(Block::MagentaGlazedTerracotta(data))
            }
            "minecraft:light_blue_glazed_terracotta" => {
                let data = LightBlueGlazedTerracottaData::default();
                Some(Block::LightBlueGlazedTerracotta(data))
            }
            "minecraft:yellow_glazed_terracotta" => {
                let data = YellowGlazedTerracottaData::default();
                Some(Block::YellowGlazedTerracotta(data))
            }
            "minecraft:lime_glazed_terracotta" => {
                let data = LimeGlazedTerracottaData::default();
                Some(Block::LimeGlazedTerracotta(data))
            }
            "minecraft:pink_glazed_terracotta" => {
                let data = PinkGlazedTerracottaData::default();
                Some(Block::PinkGlazedTerracotta(data))
            }
            "minecraft:gray_glazed_terracotta" => {
                let data = GrayGlazedTerracottaData::default();
                Some(Block::GrayGlazedTerracotta(data))
            }
            "minecraft:light_gray_glazed_terracotta" => {
                let data = LightGrayGlazedTerracottaData::default();
                Some(Block::LightGrayGlazedTerracotta(data))
            }
            "minecraft:cyan_glazed_terracotta" => {
                let data = CyanGlazedTerracottaData::default();
                Some(Block::CyanGlazedTerracotta(data))
            }
            "minecraft:purple_glazed_terracotta" => {
                let data = PurpleGlazedTerracottaData::default();
                Some(Block::PurpleGlazedTerracotta(data))
            }
            "minecraft:blue_glazed_terracotta" => {
                let data = BlueGlazedTerracottaData::default();
                Some(Block::BlueGlazedTerracotta(data))
            }
            "minecraft:brown_glazed_terracotta" => {
                let data = BrownGlazedTerracottaData::default();
                Some(Block::BrownGlazedTerracotta(data))
            }
            "minecraft:green_glazed_terracotta" => {
                let data = GreenGlazedTerracottaData::default();
                Some(Block::GreenGlazedTerracotta(data))
            }
            "minecraft:red_glazed_terracotta" => {
                let data = RedGlazedTerracottaData::default();
                Some(Block::RedGlazedTerracotta(data))
            }
            "minecraft:black_glazed_terracotta" => {
                let data = BlackGlazedTerracottaData::default();
                Some(Block::BlackGlazedTerracotta(data))
            }
            "minecraft:white_concrete" => Some(Block::WhiteConcrete),
            "minecraft:orange_concrete" => Some(Block::OrangeConcrete),
            "minecraft:magenta_concrete" => Some(Block::MagentaConcrete),
            "minecraft:light_blue_concrete" => Some(Block::LightBlueConcrete),
            "minecraft:yellow_concrete" => Some(Block::YellowConcrete),
            "minecraft:lime_concrete" => Some(Block::LimeConcrete),
            "minecraft:pink_concrete" => Some(Block::PinkConcrete),
            "minecraft:gray_concrete" => Some(Block::GrayConcrete),
            "minecraft:light_gray_concrete" => Some(Block::LightGrayConcrete),
            "minecraft:cyan_concrete" => Some(Block::CyanConcrete),
            "minecraft:purple_concrete" => Some(Block::PurpleConcrete),
            "minecraft:blue_concrete" => Some(Block::BlueConcrete),
            "minecraft:brown_concrete" => Some(Block::BrownConcrete),
            "minecraft:green_concrete" => Some(Block::GreenConcrete),
            "minecraft:red_concrete" => Some(Block::RedConcrete),
            "minecraft:black_concrete" => Some(Block::BlackConcrete),
            "minecraft:white_concrete_powder" => Some(Block::WhiteConcretePowder),
            "minecraft:orange_concrete_powder" => Some(Block::OrangeConcretePowder),
            "minecraft:magenta_concrete_powder" => Some(Block::MagentaConcretePowder),
            "minecraft:light_blue_concrete_powder" => Some(Block::LightBlueConcretePowder),
            "minecraft:yellow_concrete_powder" => Some(Block::YellowConcretePowder),
            "minecraft:lime_concrete_powder" => Some(Block::LimeConcretePowder),
            "minecraft:pink_concrete_powder" => Some(Block::PinkConcretePowder),
            "minecraft:gray_concrete_powder" => Some(Block::GrayConcretePowder),
            "minecraft:light_gray_concrete_powder" => Some(Block::LightGrayConcretePowder),
            "minecraft:cyan_concrete_powder" => Some(Block::CyanConcretePowder),
            "minecraft:purple_concrete_powder" => Some(Block::PurpleConcretePowder),
            "minecraft:blue_concrete_powder" => Some(Block::BlueConcretePowder),
            "minecraft:brown_concrete_powder" => Some(Block::BrownConcretePowder),
            "minecraft:green_concrete_powder" => Some(Block::GreenConcretePowder),
            "minecraft:red_concrete_powder" => Some(Block::RedConcretePowder),
            "minecraft:black_concrete_powder" => Some(Block::BlackConcretePowder),
            "minecraft:kelp" => {
                let data = KelpData::default();
                Some(Block::Kelp(data))
            }
            "minecraft:kelp_plant" => Some(Block::KelpPlant),
            "minecraft:dried_kelp_block" => Some(Block::DriedKelpBlock),
            "minecraft:turtle_egg" => {
                let data = TurtleEggData::default();
                Some(Block::TurtleEgg(data))
            }
            "minecraft:dead_tube_coral_block" => Some(Block::DeadTubeCoralBlock),
            "minecraft:dead_brain_coral_block" => Some(Block::DeadBrainCoralBlock),
            "minecraft:dead_bubble_coral_block" => Some(Block::DeadBubbleCoralBlock),
            "minecraft:dead_fire_coral_block" => Some(Block::DeadFireCoralBlock),
            "minecraft:dead_horn_coral_block" => Some(Block::DeadHornCoralBlock),
            "minecraft:tube_coral_block" => Some(Block::TubeCoralBlock),
            "minecraft:brain_coral_block" => Some(Block::BrainCoralBlock),
            "minecraft:bubble_coral_block" => Some(Block::BubbleCoralBlock),
            "minecraft:fire_coral_block" => Some(Block::FireCoralBlock),
            "minecraft:horn_coral_block" => Some(Block::HornCoralBlock),
            "minecraft:dead_tube_coral" => {
                let data = DeadTubeCoralData::default();
                Some(Block::DeadTubeCoral(data))
            }
            "minecraft:dead_brain_coral" => {
                let data = DeadBrainCoralData::default();
                Some(Block::DeadBrainCoral(data))
            }
            "minecraft:dead_bubble_coral" => {
                let data = DeadBubbleCoralData::default();
                Some(Block::DeadBubbleCoral(data))
            }
            "minecraft:dead_fire_coral" => {
                let data = DeadFireCoralData::default();
                Some(Block::DeadFireCoral(data))
            }
            "minecraft:dead_horn_coral" => {
                let data = DeadHornCoralData::default();
                Some(Block::DeadHornCoral(data))
            }
            "minecraft:tube_coral" => {
                let data = TubeCoralData::default();
                Some(Block::TubeCoral(data))
            }
            "minecraft:brain_coral" => {
                let data = BrainCoralData::default();
                Some(Block::BrainCoral(data))
            }
            "minecraft:bubble_coral" => {
                let data = BubbleCoralData::default();
                Some(Block::BubbleCoral(data))
            }
            "minecraft:fire_coral" => {
                let data = FireCoralData::default();
                Some(Block::FireCoral(data))
            }
            "minecraft:horn_coral" => {
                let data = HornCoralData::default();
                Some(Block::HornCoral(data))
            }
            "minecraft:dead_tube_coral_wall_fan" => {
                let data = DeadTubeCoralWallFanData::default();
                Some(Block::DeadTubeCoralWallFan(data))
            }
            "minecraft:dead_brain_coral_wall_fan" => {
                let data = DeadBrainCoralWallFanData::default();
                Some(Block::DeadBrainCoralWallFan(data))
            }
            "minecraft:dead_bubble_coral_wall_fan" => {
                let data = DeadBubbleCoralWallFanData::default();
                Some(Block::DeadBubbleCoralWallFan(data))
            }
            "minecraft:dead_fire_coral_wall_fan" => {
                let data = DeadFireCoralWallFanData::default();
                Some(Block::DeadFireCoralWallFan(data))
            }
            "minecraft:dead_horn_coral_wall_fan" => {
                let data = DeadHornCoralWallFanData::default();
                Some(Block::DeadHornCoralWallFan(data))
            }
            "minecraft:tube_coral_wall_fan" => {
                let data = TubeCoralWallFanData::default();
                Some(Block::TubeCoralWallFan(data))
            }
            "minecraft:brain_coral_wall_fan" => {
                let data = BrainCoralWallFanData::default();
                Some(Block::BrainCoralWallFan(data))
            }
            "minecraft:bubble_coral_wall_fan" => {
                let data = BubbleCoralWallFanData::default();
                Some(Block::BubbleCoralWallFan(data))
            }
            "minecraft:fire_coral_wall_fan" => {
                let data = FireCoralWallFanData::default();
                Some(Block::FireCoralWallFan(data))
            }
            "minecraft:horn_coral_wall_fan" => {
                let data = HornCoralWallFanData::default();
                Some(Block::HornCoralWallFan(data))
            }
            "minecraft:dead_tube_coral_fan" => {
                let data = DeadTubeCoralFanData::default();
                Some(Block::DeadTubeCoralFan(data))
            }
            "minecraft:dead_brain_coral_fan" => {
                let data = DeadBrainCoralFanData::default();
                Some(Block::DeadBrainCoralFan(data))
            }
            "minecraft:dead_bubble_coral_fan" => {
                let data = DeadBubbleCoralFanData::default();
                Some(Block::DeadBubbleCoralFan(data))
            }
            "minecraft:dead_fire_coral_fan" => {
                let data = DeadFireCoralFanData::default();
                Some(Block::DeadFireCoralFan(data))
            }
            "minecraft:dead_horn_coral_fan" => {
                let data = DeadHornCoralFanData::default();
                Some(Block::DeadHornCoralFan(data))
            }
            "minecraft:tube_coral_fan" => {
                let data = TubeCoralFanData::default();
                Some(Block::TubeCoralFan(data))
            }
            "minecraft:brain_coral_fan" => {
                let data = BrainCoralFanData::default();
                Some(Block::BrainCoralFan(data))
            }
            "minecraft:bubble_coral_fan" => {
                let data = BubbleCoralFanData::default();
                Some(Block::BubbleCoralFan(data))
            }
            "minecraft:fire_coral_fan" => {
                let data = FireCoralFanData::default();
                Some(Block::FireCoralFan(data))
            }
            "minecraft:horn_coral_fan" => {
                let data = HornCoralFanData::default();
                Some(Block::HornCoralFan(data))
            }
            "minecraft:sea_pickle" => {
                let data = SeaPickleData::default();
                Some(Block::SeaPickle(data))
            }
            "minecraft:blue_ice" => Some(Block::BlueIce),
            "minecraft:conduit" => {
                let data = ConduitData::default();
                Some(Block::Conduit(data))
            }
            "minecraft:void_air" => Some(Block::VoidAir),
            "minecraft:cave_air" => Some(Block::CaveAir),
            "minecraft:bubble_column" => {
                let data = BubbleColumnData::default();
                Some(Block::BubbleColumn(data))
            }
            "minecraft:structure_block" => {
                let data = StructureBlockData::default();
                Some(Block::StructureBlock(data))
            }
            _ => None,
        }
    }
    pub fn from_internal_state_id(id: usize) -> Option<Self> {
        match id {
            0usize => Some(Block::Air),
            1usize => Some(Block::Stone),
            2usize => Some(Block::Granite),
            3usize => Some(Block::PolishedGranite),
            4usize => Some(Block::Diorite),
            5usize => Some(Block::PolishedDiorite),
            6usize => Some(Block::Andesite),
            7usize => Some(Block::PolishedAndesite),
            8usize..=9usize => {
                let offset = id - 8usize;
                let data = GrassBlockData::from_value(offset)?;
                Some(Block::GrassBlock(data))
            }
            10usize => Some(Block::Dirt),
            11usize => Some(Block::CoarseDirt),
            12usize..=13usize => {
                let offset = id - 12usize;
                let data = PodzolData::from_value(offset)?;
                Some(Block::Podzol(data))
            }
            14usize => Some(Block::Cobblestone),
            15usize => Some(Block::OakPlanks),
            16usize => Some(Block::SprucePlanks),
            17usize => Some(Block::BirchPlanks),
            18usize => Some(Block::JunglePlanks),
            19usize => Some(Block::AcaciaPlanks),
            20usize => Some(Block::DarkOakPlanks),
            21usize..=22usize => {
                let offset = id - 21usize;
                let data = OakSaplingData::from_value(offset)?;
                Some(Block::OakSapling(data))
            }
            23usize..=24usize => {
                let offset = id - 23usize;
                let data = SpruceSaplingData::from_value(offset)?;
                Some(Block::SpruceSapling(data))
            }
            25usize..=26usize => {
                let offset = id - 25usize;
                let data = BirchSaplingData::from_value(offset)?;
                Some(Block::BirchSapling(data))
            }
            27usize..=28usize => {
                let offset = id - 27usize;
                let data = JungleSaplingData::from_value(offset)?;
                Some(Block::JungleSapling(data))
            }
            29usize..=30usize => {
                let offset = id - 29usize;
                let data = AcaciaSaplingData::from_value(offset)?;
                Some(Block::AcaciaSapling(data))
            }
            31usize..=32usize => {
                let offset = id - 31usize;
                let data = DarkOakSaplingData::from_value(offset)?;
                Some(Block::DarkOakSapling(data))
            }
            33usize => Some(Block::Bedrock),
            34usize..=49usize => {
                let offset = id - 34usize;
                let data = WaterData::from_value(offset)?;
                Some(Block::Water(data))
            }
            50usize..=65usize => {
                let offset = id - 50usize;
                let data = LavaData::from_value(offset)?;
                Some(Block::Lava(data))
            }
            66usize => Some(Block::Sand),
            67usize => Some(Block::RedSand),
            68usize => Some(Block::Gravel),
            69usize => Some(Block::GoldOre),
            70usize => Some(Block::IronOre),
            71usize => Some(Block::CoalOre),
            72usize..=74usize => {
                let offset = id - 72usize;
                let data = OakLogData::from_value(offset)?;
                Some(Block::OakLog(data))
            }
            75usize..=77usize => {
                let offset = id - 75usize;
                let data = SpruceLogData::from_value(offset)?;
                Some(Block::SpruceLog(data))
            }
            78usize..=80usize => {
                let offset = id - 78usize;
                let data = BirchLogData::from_value(offset)?;
                Some(Block::BirchLog(data))
            }
            81usize..=83usize => {
                let offset = id - 81usize;
                let data = JungleLogData::from_value(offset)?;
                Some(Block::JungleLog(data))
            }
            84usize..=86usize => {
                let offset = id - 84usize;
                let data = AcaciaLogData::from_value(offset)?;
                Some(Block::AcaciaLog(data))
            }
            87usize..=89usize => {
                let offset = id - 87usize;
                let data = DarkOakLogData::from_value(offset)?;
                Some(Block::DarkOakLog(data))
            }
            90usize..=92usize => {
                let offset = id - 90usize;
                let data = StrippedSpruceLogData::from_value(offset)?;
                Some(Block::StrippedSpruceLog(data))
            }
            93usize..=95usize => {
                let offset = id - 93usize;
                let data = StrippedBirchLogData::from_value(offset)?;
                Some(Block::StrippedBirchLog(data))
            }
            96usize..=98usize => {
                let offset = id - 96usize;
                let data = StrippedJungleLogData::from_value(offset)?;
                Some(Block::StrippedJungleLog(data))
            }
            99usize..=101usize => {
                let offset = id - 99usize;
                let data = StrippedAcaciaLogData::from_value(offset)?;
                Some(Block::StrippedAcaciaLog(data))
            }
            102usize..=104usize => {
                let offset = id - 102usize;
                let data = StrippedDarkOakLogData::from_value(offset)?;
                Some(Block::StrippedDarkOakLog(data))
            }
            105usize..=107usize => {
                let offset = id - 105usize;
                let data = StrippedOakLogData::from_value(offset)?;
                Some(Block::StrippedOakLog(data))
            }
            108usize..=110usize => {
                let offset = id - 108usize;
                let data = OakWoodData::from_value(offset)?;
                Some(Block::OakWood(data))
            }
            111usize..=113usize => {
                let offset = id - 111usize;
                let data = SpruceWoodData::from_value(offset)?;
                Some(Block::SpruceWood(data))
            }
            114usize..=116usize => {
                let offset = id - 114usize;
                let data = BirchWoodData::from_value(offset)?;
                Some(Block::BirchWood(data))
            }
            117usize..=119usize => {
                let offset = id - 117usize;
                let data = JungleWoodData::from_value(offset)?;
                Some(Block::JungleWood(data))
            }
            120usize..=122usize => {
                let offset = id - 120usize;
                let data = AcaciaWoodData::from_value(offset)?;
                Some(Block::AcaciaWood(data))
            }
            123usize..=125usize => {
                let offset = id - 123usize;
                let data = DarkOakWoodData::from_value(offset)?;
                Some(Block::DarkOakWood(data))
            }
            126usize..=128usize => {
                let offset = id - 126usize;
                let data = StrippedOakWoodData::from_value(offset)?;
                Some(Block::StrippedOakWood(data))
            }
            129usize..=131usize => {
                let offset = id - 129usize;
                let data = StrippedSpruceWoodData::from_value(offset)?;
                Some(Block::StrippedSpruceWood(data))
            }
            132usize..=134usize => {
                let offset = id - 132usize;
                let data = StrippedBirchWoodData::from_value(offset)?;
                Some(Block::StrippedBirchWood(data))
            }
            135usize..=137usize => {
                let offset = id - 135usize;
                let data = StrippedJungleWoodData::from_value(offset)?;
                Some(Block::StrippedJungleWood(data))
            }
            138usize..=140usize => {
                let offset = id - 138usize;
                let data = StrippedAcaciaWoodData::from_value(offset)?;
                Some(Block::StrippedAcaciaWood(data))
            }
            141usize..=143usize => {
                let offset = id - 141usize;
                let data = StrippedDarkOakWoodData::from_value(offset)?;
                Some(Block::StrippedDarkOakWood(data))
            }
            144usize..=157usize => {
                let offset = id - 144usize;
                let data = OakLeavesData::from_value(offset)?;
                Some(Block::OakLeaves(data))
            }
            158usize..=171usize => {
                let offset = id - 158usize;
                let data = SpruceLeavesData::from_value(offset)?;
                Some(Block::SpruceLeaves(data))
            }
            172usize..=185usize => {
                let offset = id - 172usize;
                let data = BirchLeavesData::from_value(offset)?;
                Some(Block::BirchLeaves(data))
            }
            186usize..=199usize => {
                let offset = id - 186usize;
                let data = JungleLeavesData::from_value(offset)?;
                Some(Block::JungleLeaves(data))
            }
            200usize..=213usize => {
                let offset = id - 200usize;
                let data = AcaciaLeavesData::from_value(offset)?;
                Some(Block::AcaciaLeaves(data))
            }
            214usize..=227usize => {
                let offset = id - 214usize;
                let data = DarkOakLeavesData::from_value(offset)?;
                Some(Block::DarkOakLeaves(data))
            }
            228usize => Some(Block::Sponge),
            229usize => Some(Block::WetSponge),
            230usize => Some(Block::Glass),
            231usize => Some(Block::LapisOre),
            232usize => Some(Block::LapisBlock),
            233usize..=244usize => {
                let offset = id - 233usize;
                let data = DispenserData::from_value(offset)?;
                Some(Block::Dispenser(data))
            }
            245usize => Some(Block::Sandstone),
            246usize => Some(Block::ChiseledSandstone),
            247usize => Some(Block::CutSandstone),
            248usize..=747usize => {
                let offset = id - 248usize;
                let data = NoteBlockData::from_value(offset)?;
                Some(Block::NoteBlock(data))
            }
            748usize..=763usize => {
                let offset = id - 748usize;
                let data = WhiteBedData::from_value(offset)?;
                Some(Block::WhiteBed(data))
            }
            764usize..=779usize => {
                let offset = id - 764usize;
                let data = OrangeBedData::from_value(offset)?;
                Some(Block::OrangeBed(data))
            }
            780usize..=795usize => {
                let offset = id - 780usize;
                let data = MagentaBedData::from_value(offset)?;
                Some(Block::MagentaBed(data))
            }
            796usize..=811usize => {
                let offset = id - 796usize;
                let data = LightBlueBedData::from_value(offset)?;
                Some(Block::LightBlueBed(data))
            }
            812usize..=827usize => {
                let offset = id - 812usize;
                let data = YellowBedData::from_value(offset)?;
                Some(Block::YellowBed(data))
            }
            828usize..=843usize => {
                let offset = id - 828usize;
                let data = LimeBedData::from_value(offset)?;
                Some(Block::LimeBed(data))
            }
            844usize..=859usize => {
                let offset = id - 844usize;
                let data = PinkBedData::from_value(offset)?;
                Some(Block::PinkBed(data))
            }
            860usize..=875usize => {
                let offset = id - 860usize;
                let data = GrayBedData::from_value(offset)?;
                Some(Block::GrayBed(data))
            }
            876usize..=891usize => {
                let offset = id - 876usize;
                let data = LightGrayBedData::from_value(offset)?;
                Some(Block::LightGrayBed(data))
            }
            892usize..=907usize => {
                let offset = id - 892usize;
                let data = CyanBedData::from_value(offset)?;
                Some(Block::CyanBed(data))
            }
            908usize..=923usize => {
                let offset = id - 908usize;
                let data = PurpleBedData::from_value(offset)?;
                Some(Block::PurpleBed(data))
            }
            924usize..=939usize => {
                let offset = id - 924usize;
                let data = BlueBedData::from_value(offset)?;
                Some(Block::BlueBed(data))
            }
            940usize..=955usize => {
                let offset = id - 940usize;
                let data = BrownBedData::from_value(offset)?;
                Some(Block::BrownBed(data))
            }
            956usize..=971usize => {
                let offset = id - 956usize;
                let data = GreenBedData::from_value(offset)?;
                Some(Block::GreenBed(data))
            }
            972usize..=987usize => {
                let offset = id - 972usize;
                let data = RedBedData::from_value(offset)?;
                Some(Block::RedBed(data))
            }
            988usize..=1003usize => {
                let offset = id - 988usize;
                let data = BlackBedData::from_value(offset)?;
                Some(Block::BlackBed(data))
            }
            1004usize..=1015usize => {
                let offset = id - 1004usize;
                let data = PoweredRailData::from_value(offset)?;
                Some(Block::PoweredRail(data))
            }
            1016usize..=1027usize => {
                let offset = id - 1016usize;
                let data = DetectorRailData::from_value(offset)?;
                Some(Block::DetectorRail(data))
            }
            1028usize..=1039usize => {
                let offset = id - 1028usize;
                let data = StickyPistonData::from_value(offset)?;
                Some(Block::StickyPiston(data))
            }
            1040usize => Some(Block::Cobweb),
            1041usize => Some(Block::Grass),
            1042usize => Some(Block::Fern),
            1043usize => Some(Block::DeadBush),
            1044usize => Some(Block::Seagrass),
            1045usize..=1046usize => {
                let offset = id - 1045usize;
                let data = TallSeagrassData::from_value(offset)?;
                Some(Block::TallSeagrass(data))
            }
            1047usize..=1058usize => {
                let offset = id - 1047usize;
                let data = PistonData::from_value(offset)?;
                Some(Block::Piston(data))
            }
            1059usize..=1082usize => {
                let offset = id - 1059usize;
                let data = PistonHeadData::from_value(offset)?;
                Some(Block::PistonHead(data))
            }
            1083usize => Some(Block::WhiteWool),
            1084usize => Some(Block::OrangeWool),
            1085usize => Some(Block::MagentaWool),
            1086usize => Some(Block::LightBlueWool),
            1087usize => Some(Block::YellowWool),
            1088usize => Some(Block::LimeWool),
            1089usize => Some(Block::PinkWool),
            1090usize => Some(Block::GrayWool),
            1091usize => Some(Block::LightGrayWool),
            1092usize => Some(Block::CyanWool),
            1093usize => Some(Block::PurpleWool),
            1094usize => Some(Block::BlueWool),
            1095usize => Some(Block::BrownWool),
            1096usize => Some(Block::GreenWool),
            1097usize => Some(Block::RedWool),
            1098usize => Some(Block::BlackWool),
            1099usize..=1110usize => {
                let offset = id - 1099usize;
                let data = MovingPistonData::from_value(offset)?;
                Some(Block::MovingPiston(data))
            }
            1111usize => Some(Block::Dandelion),
            1112usize => Some(Block::Poppy),
            1113usize => Some(Block::BlueOrchid),
            1114usize => Some(Block::Allium),
            1115usize => Some(Block::AzureBluet),
            1116usize => Some(Block::RedTulip),
            1117usize => Some(Block::OrangeTulip),
            1118usize => Some(Block::WhiteTulip),
            1119usize => Some(Block::PinkTulip),
            1120usize => Some(Block::OxeyeDaisy),
            1121usize => Some(Block::BrownMushroom),
            1122usize => Some(Block::RedMushroom),
            1123usize => Some(Block::GoldBlock),
            1124usize => Some(Block::IronBlock),
            1125usize => Some(Block::Bricks),
            1126usize..=1127usize => {
                let offset = id - 1126usize;
                let data = TntData::from_value(offset)?;
                Some(Block::Tnt(data))
            }
            1128usize => Some(Block::Bookshelf),
            1129usize => Some(Block::MossyCobblestone),
            1130usize => Some(Block::Obsidian),
            1131usize => Some(Block::Torch),
            1132usize..=1135usize => {
                let offset = id - 1132usize;
                let data = WallTorchData::from_value(offset)?;
                Some(Block::WallTorch(data))
            }
            1136usize..=1647usize => {
                let offset = id - 1136usize;
                let data = FireData::from_value(offset)?;
                Some(Block::Fire(data))
            }
            1648usize => Some(Block::Spawner),
            1649usize..=1728usize => {
                let offset = id - 1649usize;
                let data = OakStairsData::from_value(offset)?;
                Some(Block::OakStairs(data))
            }
            1729usize..=1752usize => {
                let offset = id - 1729usize;
                let data = ChestData::from_value(offset)?;
                Some(Block::Chest(data))
            }
            1753usize..=3048usize => {
                let offset = id - 1753usize;
                let data = RedstoneWireData::from_value(offset)?;
                Some(Block::RedstoneWire(data))
            }
            3049usize => Some(Block::DiamondOre),
            3050usize => Some(Block::DiamondBlock),
            3051usize => Some(Block::CraftingTable),
            3052usize..=3059usize => {
                let offset = id - 3052usize;
                let data = WheatData::from_value(offset)?;
                Some(Block::Wheat(data))
            }
            3060usize..=3067usize => {
                let offset = id - 3060usize;
                let data = FarmlandData::from_value(offset)?;
                Some(Block::Farmland(data))
            }
            3068usize..=3075usize => {
                let offset = id - 3068usize;
                let data = FurnaceData::from_value(offset)?;
                Some(Block::Furnace(data))
            }
            3076usize..=3107usize => {
                let offset = id - 3076usize;
                let data = SignData::from_value(offset)?;
                Some(Block::Sign(data))
            }
            3108usize..=3171usize => {
                let offset = id - 3108usize;
                let data = OakDoorData::from_value(offset)?;
                Some(Block::OakDoor(data))
            }
            3172usize..=3179usize => {
                let offset = id - 3172usize;
                let data = LadderData::from_value(offset)?;
                Some(Block::Ladder(data))
            }
            3180usize..=3189usize => {
                let offset = id - 3180usize;
                let data = RailData::from_value(offset)?;
                Some(Block::Rail(data))
            }
            3190usize..=3269usize => {
                let offset = id - 3190usize;
                let data = CobblestoneStairsData::from_value(offset)?;
                Some(Block::CobblestoneStairs(data))
            }
            3270usize..=3277usize => {
                let offset = id - 3270usize;
                let data = WallSignData::from_value(offset)?;
                Some(Block::WallSign(data))
            }
            3278usize..=3301usize => {
                let offset = id - 3278usize;
                let data = LeverData::from_value(offset)?;
                Some(Block::Lever(data))
            }
            3302usize..=3303usize => {
                let offset = id - 3302usize;
                let data = StonePressurePlateData::from_value(offset)?;
                Some(Block::StonePressurePlate(data))
            }
            3304usize..=3367usize => {
                let offset = id - 3304usize;
                let data = IronDoorData::from_value(offset)?;
                Some(Block::IronDoor(data))
            }
            3368usize..=3369usize => {
                let offset = id - 3368usize;
                let data = OakPressurePlateData::from_value(offset)?;
                Some(Block::OakPressurePlate(data))
            }
            3370usize..=3371usize => {
                let offset = id - 3370usize;
                let data = SprucePressurePlateData::from_value(offset)?;
                Some(Block::SprucePressurePlate(data))
            }
            3372usize..=3373usize => {
                let offset = id - 3372usize;
                let data = BirchPressurePlateData::from_value(offset)?;
                Some(Block::BirchPressurePlate(data))
            }
            3374usize..=3375usize => {
                let offset = id - 3374usize;
                let data = JunglePressurePlateData::from_value(offset)?;
                Some(Block::JunglePressurePlate(data))
            }
            3376usize..=3377usize => {
                let offset = id - 3376usize;
                let data = AcaciaPressurePlateData::from_value(offset)?;
                Some(Block::AcaciaPressurePlate(data))
            }
            3378usize..=3379usize => {
                let offset = id - 3378usize;
                let data = DarkOakPressurePlateData::from_value(offset)?;
                Some(Block::DarkOakPressurePlate(data))
            }
            3380usize..=3381usize => {
                let offset = id - 3380usize;
                let data = RedstoneOreData::from_value(offset)?;
                Some(Block::RedstoneOre(data))
            }
            3382usize..=3383usize => {
                let offset = id - 3382usize;
                let data = RedstoneTorchData::from_value(offset)?;
                Some(Block::RedstoneTorch(data))
            }
            3384usize..=3391usize => {
                let offset = id - 3384usize;
                let data = RedstoneWallTorchData::from_value(offset)?;
                Some(Block::RedstoneWallTorch(data))
            }
            3392usize..=3415usize => {
                let offset = id - 3392usize;
                let data = StoneButtonData::from_value(offset)?;
                Some(Block::StoneButton(data))
            }
            3416usize..=3423usize => {
                let offset = id - 3416usize;
                let data = SnowData::from_value(offset)?;
                Some(Block::Snow(data))
            }
            3424usize => Some(Block::Ice),
            3425usize => Some(Block::SnowBlock),
            3426usize..=3441usize => {
                let offset = id - 3426usize;
                let data = CactusData::from_value(offset)?;
                Some(Block::Cactus(data))
            }
            3442usize => Some(Block::Clay),
            3443usize..=3458usize => {
                let offset = id - 3443usize;
                let data = SugarCaneData::from_value(offset)?;
                Some(Block::SugarCane(data))
            }
            3459usize..=3460usize => {
                let offset = id - 3459usize;
                let data = JukeboxData::from_value(offset)?;
                Some(Block::Jukebox(data))
            }
            3461usize..=3492usize => {
                let offset = id - 3461usize;
                let data = OakFenceData::from_value(offset)?;
                Some(Block::OakFence(data))
            }
            3493usize => Some(Block::Pumpkin),
            3494usize => Some(Block::Netherrack),
            3495usize => Some(Block::SoulSand),
            3496usize => Some(Block::Glowstone),
            3497usize..=3498usize => {
                let offset = id - 3497usize;
                let data = NetherPortalData::from_value(offset)?;
                Some(Block::NetherPortal(data))
            }
            3499usize..=3502usize => {
                let offset = id - 3499usize;
                let data = CarvedPumpkinData::from_value(offset)?;
                Some(Block::CarvedPumpkin(data))
            }
            3503usize..=3506usize => {
                let offset = id - 3503usize;
                let data = JackOLanternData::from_value(offset)?;
                Some(Block::JackOLantern(data))
            }
            3507usize..=3513usize => {
                let offset = id - 3507usize;
                let data = CakeData::from_value(offset)?;
                Some(Block::Cake(data))
            }
            3514usize..=3577usize => {
                let offset = id - 3514usize;
                let data = RepeaterData::from_value(offset)?;
                Some(Block::Repeater(data))
            }
            3578usize => Some(Block::WhiteStainedGlass),
            3579usize => Some(Block::OrangeStainedGlass),
            3580usize => Some(Block::MagentaStainedGlass),
            3581usize => Some(Block::LightBlueStainedGlass),
            3582usize => Some(Block::YellowStainedGlass),
            3583usize => Some(Block::LimeStainedGlass),
            3584usize => Some(Block::PinkStainedGlass),
            3585usize => Some(Block::GrayStainedGlass),
            3586usize => Some(Block::LightGrayStainedGlass),
            3587usize => Some(Block::CyanStainedGlass),
            3588usize => Some(Block::PurpleStainedGlass),
            3589usize => Some(Block::BlueStainedGlass),
            3590usize => Some(Block::BrownStainedGlass),
            3591usize => Some(Block::GreenStainedGlass),
            3592usize => Some(Block::RedStainedGlass),
            3593usize => Some(Block::BlackStainedGlass),
            3594usize..=3657usize => {
                let offset = id - 3594usize;
                let data = OakTrapdoorData::from_value(offset)?;
                Some(Block::OakTrapdoor(data))
            }
            3658usize..=3721usize => {
                let offset = id - 3658usize;
                let data = SpruceTrapdoorData::from_value(offset)?;
                Some(Block::SpruceTrapdoor(data))
            }
            3722usize..=3785usize => {
                let offset = id - 3722usize;
                let data = BirchTrapdoorData::from_value(offset)?;
                Some(Block::BirchTrapdoor(data))
            }
            3786usize..=3849usize => {
                let offset = id - 3786usize;
                let data = JungleTrapdoorData::from_value(offset)?;
                Some(Block::JungleTrapdoor(data))
            }
            3850usize..=3913usize => {
                let offset = id - 3850usize;
                let data = AcaciaTrapdoorData::from_value(offset)?;
                Some(Block::AcaciaTrapdoor(data))
            }
            3914usize..=3977usize => {
                let offset = id - 3914usize;
                let data = DarkOakTrapdoorData::from_value(offset)?;
                Some(Block::DarkOakTrapdoor(data))
            }
            3978usize => Some(Block::InfestedStone),
            3979usize => Some(Block::InfestedCobblestone),
            3980usize => Some(Block::InfestedStoneBricks),
            3981usize => Some(Block::InfestedMossyStoneBricks),
            3982usize => Some(Block::InfestedCrackedStoneBricks),
            3983usize => Some(Block::InfestedChiseledStoneBricks),
            3984usize => Some(Block::StoneBricks),
            3985usize => Some(Block::MossyStoneBricks),
            3986usize => Some(Block::CrackedStoneBricks),
            3987usize => Some(Block::ChiseledStoneBricks),
            3988usize..=4051usize => {
                let offset = id - 3988usize;
                let data = BrownMushroomBlockData::from_value(offset)?;
                Some(Block::BrownMushroomBlock(data))
            }
            4052usize..=4115usize => {
                let offset = id - 4052usize;
                let data = RedMushroomBlockData::from_value(offset)?;
                Some(Block::RedMushroomBlock(data))
            }
            4116usize..=4179usize => {
                let offset = id - 4116usize;
                let data = MushroomStemData::from_value(offset)?;
                Some(Block::MushroomStem(data))
            }
            4180usize..=4211usize => {
                let offset = id - 4180usize;
                let data = IronBarsData::from_value(offset)?;
                Some(Block::IronBars(data))
            }
            4212usize..=4243usize => {
                let offset = id - 4212usize;
                let data = GlassPaneData::from_value(offset)?;
                Some(Block::GlassPane(data))
            }
            4244usize => Some(Block::Melon),
            4245usize..=4248usize => {
                let offset = id - 4245usize;
                let data = AttachedPumpkinStemData::from_value(offset)?;
                Some(Block::AttachedPumpkinStem(data))
            }
            4249usize..=4252usize => {
                let offset = id - 4249usize;
                let data = AttachedMelonStemData::from_value(offset)?;
                Some(Block::AttachedMelonStem(data))
            }
            4253usize..=4260usize => {
                let offset = id - 4253usize;
                let data = PumpkinStemData::from_value(offset)?;
                Some(Block::PumpkinStem(data))
            }
            4261usize..=4268usize => {
                let offset = id - 4261usize;
                let data = MelonStemData::from_value(offset)?;
                Some(Block::MelonStem(data))
            }
            4269usize..=4300usize => {
                let offset = id - 4269usize;
                let data = VineData::from_value(offset)?;
                Some(Block::Vine(data))
            }
            4301usize..=4332usize => {
                let offset = id - 4301usize;
                let data = OakFenceGateData::from_value(offset)?;
                Some(Block::OakFenceGate(data))
            }
            4333usize..=4412usize => {
                let offset = id - 4333usize;
                let data = BrickStairsData::from_value(offset)?;
                Some(Block::BrickStairs(data))
            }
            4413usize..=4492usize => {
                let offset = id - 4413usize;
                let data = StoneBrickStairsData::from_value(offset)?;
                Some(Block::StoneBrickStairs(data))
            }
            4493usize..=4494usize => {
                let offset = id - 4493usize;
                let data = MyceliumData::from_value(offset)?;
                Some(Block::Mycelium(data))
            }
            4495usize => Some(Block::LilyPad),
            4496usize => Some(Block::NetherBricks),
            4497usize..=4528usize => {
                let offset = id - 4497usize;
                let data = NetherBrickFenceData::from_value(offset)?;
                Some(Block::NetherBrickFence(data))
            }
            4529usize..=4608usize => {
                let offset = id - 4529usize;
                let data = NetherBrickStairsData::from_value(offset)?;
                Some(Block::NetherBrickStairs(data))
            }
            4609usize..=4612usize => {
                let offset = id - 4609usize;
                let data = NetherWartData::from_value(offset)?;
                Some(Block::NetherWart(data))
            }
            4613usize => Some(Block::EnchantingTable),
            4614usize..=4621usize => {
                let offset = id - 4614usize;
                let data = BrewingStandData::from_value(offset)?;
                Some(Block::BrewingStand(data))
            }
            4622usize..=4625usize => {
                let offset = id - 4622usize;
                let data = CauldronData::from_value(offset)?;
                Some(Block::Cauldron(data))
            }
            4626usize => Some(Block::EndPortal),
            4627usize..=4634usize => {
                let offset = id - 4627usize;
                let data = EndPortalFrameData::from_value(offset)?;
                Some(Block::EndPortalFrame(data))
            }
            4635usize => Some(Block::EndStone),
            4636usize => Some(Block::DragonEgg),
            4637usize..=4638usize => {
                let offset = id - 4637usize;
                let data = RedstoneLampData::from_value(offset)?;
                Some(Block::RedstoneLamp(data))
            }
            4639usize..=4650usize => {
                let offset = id - 4639usize;
                let data = CocoaData::from_value(offset)?;
                Some(Block::Cocoa(data))
            }
            4651usize..=4730usize => {
                let offset = id - 4651usize;
                let data = SandstoneStairsData::from_value(offset)?;
                Some(Block::SandstoneStairs(data))
            }
            4731usize => Some(Block::EmeraldOre),
            4732usize..=4739usize => {
                let offset = id - 4732usize;
                let data = EnderChestData::from_value(offset)?;
                Some(Block::EnderChest(data))
            }
            4740usize..=4755usize => {
                let offset = id - 4740usize;
                let data = TripwireHookData::from_value(offset)?;
                Some(Block::TripwireHook(data))
            }
            4756usize..=4883usize => {
                let offset = id - 4756usize;
                let data = TripwireData::from_value(offset)?;
                Some(Block::Tripwire(data))
            }
            4884usize => Some(Block::EmeraldBlock),
            4885usize..=4964usize => {
                let offset = id - 4885usize;
                let data = SpruceStairsData::from_value(offset)?;
                Some(Block::SpruceStairs(data))
            }
            4965usize..=5044usize => {
                let offset = id - 4965usize;
                let data = BirchStairsData::from_value(offset)?;
                Some(Block::BirchStairs(data))
            }
            5045usize..=5124usize => {
                let offset = id - 5045usize;
                let data = JungleStairsData::from_value(offset)?;
                Some(Block::JungleStairs(data))
            }
            5125usize..=5136usize => {
                let offset = id - 5125usize;
                let data = CommandBlockData::from_value(offset)?;
                Some(Block::CommandBlock(data))
            }
            5137usize => Some(Block::Beacon),
            5138usize..=5201usize => {
                let offset = id - 5138usize;
                let data = CobblestoneWallData::from_value(offset)?;
                Some(Block::CobblestoneWall(data))
            }
            5202usize..=5265usize => {
                let offset = id - 5202usize;
                let data = MossyCobblestoneWallData::from_value(offset)?;
                Some(Block::MossyCobblestoneWall(data))
            }
            5266usize => Some(Block::FlowerPot),
            5267usize => Some(Block::PottedOakSapling),
            5268usize => Some(Block::PottedSpruceSapling),
            5269usize => Some(Block::PottedBirchSapling),
            5270usize => Some(Block::PottedJungleSapling),
            5271usize => Some(Block::PottedAcaciaSapling),
            5272usize => Some(Block::PottedDarkOakSapling),
            5273usize => Some(Block::PottedFern),
            5274usize => Some(Block::PottedDandelion),
            5275usize => Some(Block::PottedPoppy),
            5276usize => Some(Block::PottedBlueOrchid),
            5277usize => Some(Block::PottedAllium),
            5278usize => Some(Block::PottedAzureBluet),
            5279usize => Some(Block::PottedRedTulip),
            5280usize => Some(Block::PottedOrangeTulip),
            5281usize => Some(Block::PottedWhiteTulip),
            5282usize => Some(Block::PottedPinkTulip),
            5283usize => Some(Block::PottedOxeyeDaisy),
            5284usize => Some(Block::PottedRedMushroom),
            5285usize => Some(Block::PottedBrownMushroom),
            5286usize => Some(Block::PottedDeadBush),
            5287usize => Some(Block::PottedCactus),
            5288usize..=5295usize => {
                let offset = id - 5288usize;
                let data = CarrotsData::from_value(offset)?;
                Some(Block::Carrots(data))
            }
            5296usize..=5303usize => {
                let offset = id - 5296usize;
                let data = PotatoesData::from_value(offset)?;
                Some(Block::Potatoes(data))
            }
            5304usize..=5327usize => {
                let offset = id - 5304usize;
                let data = OakButtonData::from_value(offset)?;
                Some(Block::OakButton(data))
            }
            5328usize..=5351usize => {
                let offset = id - 5328usize;
                let data = SpruceButtonData::from_value(offset)?;
                Some(Block::SpruceButton(data))
            }
            5352usize..=5375usize => {
                let offset = id - 5352usize;
                let data = BirchButtonData::from_value(offset)?;
                Some(Block::BirchButton(data))
            }
            5376usize..=5399usize => {
                let offset = id - 5376usize;
                let data = JungleButtonData::from_value(offset)?;
                Some(Block::JungleButton(data))
            }
            5400usize..=5423usize => {
                let offset = id - 5400usize;
                let data = AcaciaButtonData::from_value(offset)?;
                Some(Block::AcaciaButton(data))
            }
            5424usize..=5447usize => {
                let offset = id - 5424usize;
                let data = DarkOakButtonData::from_value(offset)?;
                Some(Block::DarkOakButton(data))
            }
            5448usize..=5451usize => {
                let offset = id - 5448usize;
                let data = SkeletonWallSkullData::from_value(offset)?;
                Some(Block::SkeletonWallSkull(data))
            }
            5452usize..=5467usize => {
                let offset = id - 5452usize;
                let data = SkeletonSkullData::from_value(offset)?;
                Some(Block::SkeletonSkull(data))
            }
            5468usize..=5471usize => {
                let offset = id - 5468usize;
                let data = WitherSkeletonWallSkullData::from_value(offset)?;
                Some(Block::WitherSkeletonWallSkull(data))
            }
            5472usize..=5487usize => {
                let offset = id - 5472usize;
                let data = WitherSkeletonSkullData::from_value(offset)?;
                Some(Block::WitherSkeletonSkull(data))
            }
            5488usize..=5491usize => {
                let offset = id - 5488usize;
                let data = ZombieWallHeadData::from_value(offset)?;
                Some(Block::ZombieWallHead(data))
            }
            5492usize..=5507usize => {
                let offset = id - 5492usize;
                let data = ZombieHeadData::from_value(offset)?;
                Some(Block::ZombieHead(data))
            }
            5508usize..=5511usize => {
                let offset = id - 5508usize;
                let data = PlayerWallHeadData::from_value(offset)?;
                Some(Block::PlayerWallHead(data))
            }
            5512usize..=5527usize => {
                let offset = id - 5512usize;
                let data = PlayerHeadData::from_value(offset)?;
                Some(Block::PlayerHead(data))
            }
            5528usize..=5531usize => {
                let offset = id - 5528usize;
                let data = CreeperWallHeadData::from_value(offset)?;
                Some(Block::CreeperWallHead(data))
            }
            5532usize..=5547usize => {
                let offset = id - 5532usize;
                let data = CreeperHeadData::from_value(offset)?;
                Some(Block::CreeperHead(data))
            }
            5548usize..=5551usize => {
                let offset = id - 5548usize;
                let data = DragonWallHeadData::from_value(offset)?;
                Some(Block::DragonWallHead(data))
            }
            5552usize..=5567usize => {
                let offset = id - 5552usize;
                let data = DragonHeadData::from_value(offset)?;
                Some(Block::DragonHead(data))
            }
            5568usize..=5571usize => {
                let offset = id - 5568usize;
                let data = AnvilData::from_value(offset)?;
                Some(Block::Anvil(data))
            }
            5572usize..=5575usize => {
                let offset = id - 5572usize;
                let data = ChippedAnvilData::from_value(offset)?;
                Some(Block::ChippedAnvil(data))
            }
            5576usize..=5579usize => {
                let offset = id - 5576usize;
                let data = DamagedAnvilData::from_value(offset)?;
                Some(Block::DamagedAnvil(data))
            }
            5580usize..=5603usize => {
                let offset = id - 5580usize;
                let data = TrappedChestData::from_value(offset)?;
                Some(Block::TrappedChest(data))
            }
            5604usize..=5619usize => {
                let offset = id - 5604usize;
                let data = LightWeightedPressurePlateData::from_value(offset)?;
                Some(Block::LightWeightedPressurePlate(data))
            }
            5620usize..=5635usize => {
                let offset = id - 5620usize;
                let data = HeavyWeightedPressurePlateData::from_value(offset)?;
                Some(Block::HeavyWeightedPressurePlate(data))
            }
            5636usize..=5651usize => {
                let offset = id - 5636usize;
                let data = ComparatorData::from_value(offset)?;
                Some(Block::Comparator(data))
            }
            5652usize..=5683usize => {
                let offset = id - 5652usize;
                let data = DaylightDetectorData::from_value(offset)?;
                Some(Block::DaylightDetector(data))
            }
            5684usize => Some(Block::RedstoneBlock),
            5685usize => Some(Block::NetherQuartzOre),
            5686usize..=5695usize => {
                let offset = id - 5686usize;
                let data = HopperData::from_value(offset)?;
                Some(Block::Hopper(data))
            }
            5696usize => Some(Block::QuartzBlock),
            5697usize => Some(Block::ChiseledQuartzBlock),
            5698usize..=5700usize => {
                let offset = id - 5698usize;
                let data = QuartzPillarData::from_value(offset)?;
                Some(Block::QuartzPillar(data))
            }
            5701usize..=5780usize => {
                let offset = id - 5701usize;
                let data = QuartzStairsData::from_value(offset)?;
                Some(Block::QuartzStairs(data))
            }
            5781usize..=5792usize => {
                let offset = id - 5781usize;
                let data = ActivatorRailData::from_value(offset)?;
                Some(Block::ActivatorRail(data))
            }
            5793usize..=5804usize => {
                let offset = id - 5793usize;
                let data = DropperData::from_value(offset)?;
                Some(Block::Dropper(data))
            }
            5805usize => Some(Block::WhiteTerracotta),
            5806usize => Some(Block::OrangeTerracotta),
            5807usize => Some(Block::MagentaTerracotta),
            5808usize => Some(Block::LightBlueTerracotta),
            5809usize => Some(Block::YellowTerracotta),
            5810usize => Some(Block::LimeTerracotta),
            5811usize => Some(Block::PinkTerracotta),
            5812usize => Some(Block::GrayTerracotta),
            5813usize => Some(Block::LightGrayTerracotta),
            5814usize => Some(Block::CyanTerracotta),
            5815usize => Some(Block::PurpleTerracotta),
            5816usize => Some(Block::BlueTerracotta),
            5817usize => Some(Block::BrownTerracotta),
            5818usize => Some(Block::GreenTerracotta),
            5819usize => Some(Block::RedTerracotta),
            5820usize => Some(Block::BlackTerracotta),
            5821usize..=5852usize => {
                let offset = id - 5821usize;
                let data = WhiteStainedGlassPaneData::from_value(offset)?;
                Some(Block::WhiteStainedGlassPane(data))
            }
            5853usize..=5884usize => {
                let offset = id - 5853usize;
                let data = OrangeStainedGlassPaneData::from_value(offset)?;
                Some(Block::OrangeStainedGlassPane(data))
            }
            5885usize..=5916usize => {
                let offset = id - 5885usize;
                let data = MagentaStainedGlassPaneData::from_value(offset)?;
                Some(Block::MagentaStainedGlassPane(data))
            }
            5917usize..=5948usize => {
                let offset = id - 5917usize;
                let data = LightBlueStainedGlassPaneData::from_value(offset)?;
                Some(Block::LightBlueStainedGlassPane(data))
            }
            5949usize..=5980usize => {
                let offset = id - 5949usize;
                let data = YellowStainedGlassPaneData::from_value(offset)?;
                Some(Block::YellowStainedGlassPane(data))
            }
            5981usize..=6012usize => {
                let offset = id - 5981usize;
                let data = LimeStainedGlassPaneData::from_value(offset)?;
                Some(Block::LimeStainedGlassPane(data))
            }
            6013usize..=6044usize => {
                let offset = id - 6013usize;
                let data = PinkStainedGlassPaneData::from_value(offset)?;
                Some(Block::PinkStainedGlassPane(data))
            }
            6045usize..=6076usize => {
                let offset = id - 6045usize;
                let data = GrayStainedGlassPaneData::from_value(offset)?;
                Some(Block::GrayStainedGlassPane(data))
            }
            6077usize..=6108usize => {
                let offset = id - 6077usize;
                let data = LightGrayStainedGlassPaneData::from_value(offset)?;
                Some(Block::LightGrayStainedGlassPane(data))
            }
            6109usize..=6140usize => {
                let offset = id - 6109usize;
                let data = CyanStainedGlassPaneData::from_value(offset)?;
                Some(Block::CyanStainedGlassPane(data))
            }
            6141usize..=6172usize => {
                let offset = id - 6141usize;
                let data = PurpleStainedGlassPaneData::from_value(offset)?;
                Some(Block::PurpleStainedGlassPane(data))
            }
            6173usize..=6204usize => {
                let offset = id - 6173usize;
                let data = BlueStainedGlassPaneData::from_value(offset)?;
                Some(Block::BlueStainedGlassPane(data))
            }
            6205usize..=6236usize => {
                let offset = id - 6205usize;
                let data = BrownStainedGlassPaneData::from_value(offset)?;
                Some(Block::BrownStainedGlassPane(data))
            }
            6237usize..=6268usize => {
                let offset = id - 6237usize;
                let data = GreenStainedGlassPaneData::from_value(offset)?;
                Some(Block::GreenStainedGlassPane(data))
            }
            6269usize..=6300usize => {
                let offset = id - 6269usize;
                let data = RedStainedGlassPaneData::from_value(offset)?;
                Some(Block::RedStainedGlassPane(data))
            }
            6301usize..=6332usize => {
                let offset = id - 6301usize;
                let data = BlackStainedGlassPaneData::from_value(offset)?;
                Some(Block::BlackStainedGlassPane(data))
            }
            6333usize..=6412usize => {
                let offset = id - 6333usize;
                let data = AcaciaStairsData::from_value(offset)?;
                Some(Block::AcaciaStairs(data))
            }
            6413usize..=6492usize => {
                let offset = id - 6413usize;
                let data = DarkOakStairsData::from_value(offset)?;
                Some(Block::DarkOakStairs(data))
            }
            6493usize => Some(Block::SlimeBlock),
            6494usize => Some(Block::Barrier),
            6495usize..=6558usize => {
                let offset = id - 6495usize;
                let data = IronTrapdoorData::from_value(offset)?;
                Some(Block::IronTrapdoor(data))
            }
            6559usize => Some(Block::Prismarine),
            6560usize => Some(Block::PrismarineBricks),
            6561usize => Some(Block::DarkPrismarine),
            6562usize..=6641usize => {
                let offset = id - 6562usize;
                let data = PrismarineStairsData::from_value(offset)?;
                Some(Block::PrismarineStairs(data))
            }
            6642usize..=6721usize => {
                let offset = id - 6642usize;
                let data = PrismarineBrickStairsData::from_value(offset)?;
                Some(Block::PrismarineBrickStairs(data))
            }
            6722usize..=6801usize => {
                let offset = id - 6722usize;
                let data = DarkPrismarineStairsData::from_value(offset)?;
                Some(Block::DarkPrismarineStairs(data))
            }
            6802usize..=6807usize => {
                let offset = id - 6802usize;
                let data = PrismarineSlabData::from_value(offset)?;
                Some(Block::PrismarineSlab(data))
            }
            6808usize..=6813usize => {
                let offset = id - 6808usize;
                let data = PrismarineBrickSlabData::from_value(offset)?;
                Some(Block::PrismarineBrickSlab(data))
            }
            6814usize..=6819usize => {
                let offset = id - 6814usize;
                let data = DarkPrismarineSlabData::from_value(offset)?;
                Some(Block::DarkPrismarineSlab(data))
            }
            6820usize => Some(Block::SeaLantern),
            6821usize..=6823usize => {
                let offset = id - 6821usize;
                let data = HayBlockData::from_value(offset)?;
                Some(Block::HayBlock(data))
            }
            6824usize => Some(Block::WhiteCarpet),
            6825usize => Some(Block::OrangeCarpet),
            6826usize => Some(Block::MagentaCarpet),
            6827usize => Some(Block::LightBlueCarpet),
            6828usize => Some(Block::YellowCarpet),
            6829usize => Some(Block::LimeCarpet),
            6830usize => Some(Block::PinkCarpet),
            6831usize => Some(Block::GrayCarpet),
            6832usize => Some(Block::LightGrayCarpet),
            6833usize => Some(Block::CyanCarpet),
            6834usize => Some(Block::PurpleCarpet),
            6835usize => Some(Block::BlueCarpet),
            6836usize => Some(Block::BrownCarpet),
            6837usize => Some(Block::GreenCarpet),
            6838usize => Some(Block::RedCarpet),
            6839usize => Some(Block::BlackCarpet),
            6840usize => Some(Block::Terracotta),
            6841usize => Some(Block::CoalBlock),
            6842usize => Some(Block::PackedIce),
            6843usize..=6844usize => {
                let offset = id - 6843usize;
                let data = SunflowerData::from_value(offset)?;
                Some(Block::Sunflower(data))
            }
            6845usize..=6846usize => {
                let offset = id - 6845usize;
                let data = LilacData::from_value(offset)?;
                Some(Block::Lilac(data))
            }
            6847usize..=6848usize => {
                let offset = id - 6847usize;
                let data = RoseBushData::from_value(offset)?;
                Some(Block::RoseBush(data))
            }
            6849usize..=6850usize => {
                let offset = id - 6849usize;
                let data = PeonyData::from_value(offset)?;
                Some(Block::Peony(data))
            }
            6851usize..=6852usize => {
                let offset = id - 6851usize;
                let data = TallGrassData::from_value(offset)?;
                Some(Block::TallGrass(data))
            }
            6853usize..=6854usize => {
                let offset = id - 6853usize;
                let data = LargeFernData::from_value(offset)?;
                Some(Block::LargeFern(data))
            }
            6855usize..=6870usize => {
                let offset = id - 6855usize;
                let data = WhiteBannerData::from_value(offset)?;
                Some(Block::WhiteBanner(data))
            }
            6871usize..=6886usize => {
                let offset = id - 6871usize;
                let data = OrangeBannerData::from_value(offset)?;
                Some(Block::OrangeBanner(data))
            }
            6887usize..=6902usize => {
                let offset = id - 6887usize;
                let data = MagentaBannerData::from_value(offset)?;
                Some(Block::MagentaBanner(data))
            }
            6903usize..=6918usize => {
                let offset = id - 6903usize;
                let data = LightBlueBannerData::from_value(offset)?;
                Some(Block::LightBlueBanner(data))
            }
            6919usize..=6934usize => {
                let offset = id - 6919usize;
                let data = YellowBannerData::from_value(offset)?;
                Some(Block::YellowBanner(data))
            }
            6935usize..=6950usize => {
                let offset = id - 6935usize;
                let data = LimeBannerData::from_value(offset)?;
                Some(Block::LimeBanner(data))
            }
            6951usize..=6966usize => {
                let offset = id - 6951usize;
                let data = PinkBannerData::from_value(offset)?;
                Some(Block::PinkBanner(data))
            }
            6967usize..=6982usize => {
                let offset = id - 6967usize;
                let data = GrayBannerData::from_value(offset)?;
                Some(Block::GrayBanner(data))
            }
            6983usize..=6998usize => {
                let offset = id - 6983usize;
                let data = LightGrayBannerData::from_value(offset)?;
                Some(Block::LightGrayBanner(data))
            }
            6999usize..=7014usize => {
                let offset = id - 6999usize;
                let data = CyanBannerData::from_value(offset)?;
                Some(Block::CyanBanner(data))
            }
            7015usize..=7030usize => {
                let offset = id - 7015usize;
                let data = PurpleBannerData::from_value(offset)?;
                Some(Block::PurpleBanner(data))
            }
            7031usize..=7046usize => {
                let offset = id - 7031usize;
                let data = BlueBannerData::from_value(offset)?;
                Some(Block::BlueBanner(data))
            }
            7047usize..=7062usize => {
                let offset = id - 7047usize;
                let data = BrownBannerData::from_value(offset)?;
                Some(Block::BrownBanner(data))
            }
            7063usize..=7078usize => {
                let offset = id - 7063usize;
                let data = GreenBannerData::from_value(offset)?;
                Some(Block::GreenBanner(data))
            }
            7079usize..=7094usize => {
                let offset = id - 7079usize;
                let data = RedBannerData::from_value(offset)?;
                Some(Block::RedBanner(data))
            }
            7095usize..=7110usize => {
                let offset = id - 7095usize;
                let data = BlackBannerData::from_value(offset)?;
                Some(Block::BlackBanner(data))
            }
            7111usize..=7114usize => {
                let offset = id - 7111usize;
                let data = WhiteWallBannerData::from_value(offset)?;
                Some(Block::WhiteWallBanner(data))
            }
            7115usize..=7118usize => {
                let offset = id - 7115usize;
                let data = OrangeWallBannerData::from_value(offset)?;
                Some(Block::OrangeWallBanner(data))
            }
            7119usize..=7122usize => {
                let offset = id - 7119usize;
                let data = MagentaWallBannerData::from_value(offset)?;
                Some(Block::MagentaWallBanner(data))
            }
            7123usize..=7126usize => {
                let offset = id - 7123usize;
                let data = LightBlueWallBannerData::from_value(offset)?;
                Some(Block::LightBlueWallBanner(data))
            }
            7127usize..=7130usize => {
                let offset = id - 7127usize;
                let data = YellowWallBannerData::from_value(offset)?;
                Some(Block::YellowWallBanner(data))
            }
            7131usize..=7134usize => {
                let offset = id - 7131usize;
                let data = LimeWallBannerData::from_value(offset)?;
                Some(Block::LimeWallBanner(data))
            }
            7135usize..=7138usize => {
                let offset = id - 7135usize;
                let data = PinkWallBannerData::from_value(offset)?;
                Some(Block::PinkWallBanner(data))
            }
            7139usize..=7142usize => {
                let offset = id - 7139usize;
                let data = GrayWallBannerData::from_value(offset)?;
                Some(Block::GrayWallBanner(data))
            }
            7143usize..=7146usize => {
                let offset = id - 7143usize;
                let data = LightGrayWallBannerData::from_value(offset)?;
                Some(Block::LightGrayWallBanner(data))
            }
            7147usize..=7150usize => {
                let offset = id - 7147usize;
                let data = CyanWallBannerData::from_value(offset)?;
                Some(Block::CyanWallBanner(data))
            }
            7151usize..=7154usize => {
                let offset = id - 7151usize;
                let data = PurpleWallBannerData::from_value(offset)?;
                Some(Block::PurpleWallBanner(data))
            }
            7155usize..=7158usize => {
                let offset = id - 7155usize;
                let data = BlueWallBannerData::from_value(offset)?;
                Some(Block::BlueWallBanner(data))
            }
            7159usize..=7162usize => {
                let offset = id - 7159usize;
                let data = BrownWallBannerData::from_value(offset)?;
                Some(Block::BrownWallBanner(data))
            }
            7163usize..=7166usize => {
                let offset = id - 7163usize;
                let data = GreenWallBannerData::from_value(offset)?;
                Some(Block::GreenWallBanner(data))
            }
            7167usize..=7170usize => {
                let offset = id - 7167usize;
                let data = RedWallBannerData::from_value(offset)?;
                Some(Block::RedWallBanner(data))
            }
            7171usize..=7174usize => {
                let offset = id - 7171usize;
                let data = BlackWallBannerData::from_value(offset)?;
                Some(Block::BlackWallBanner(data))
            }
            7175usize => Some(Block::RedSandstone),
            7176usize => Some(Block::ChiseledRedSandstone),
            7177usize => Some(Block::CutRedSandstone),
            7178usize..=7257usize => {
                let offset = id - 7178usize;
                let data = RedSandstoneStairsData::from_value(offset)?;
                Some(Block::RedSandstoneStairs(data))
            }
            7258usize..=7263usize => {
                let offset = id - 7258usize;
                let data = OakSlabData::from_value(offset)?;
                Some(Block::OakSlab(data))
            }
            7264usize..=7269usize => {
                let offset = id - 7264usize;
                let data = SpruceSlabData::from_value(offset)?;
                Some(Block::SpruceSlab(data))
            }
            7270usize..=7275usize => {
                let offset = id - 7270usize;
                let data = BirchSlabData::from_value(offset)?;
                Some(Block::BirchSlab(data))
            }
            7276usize..=7281usize => {
                let offset = id - 7276usize;
                let data = JungleSlabData::from_value(offset)?;
                Some(Block::JungleSlab(data))
            }
            7282usize..=7287usize => {
                let offset = id - 7282usize;
                let data = AcaciaSlabData::from_value(offset)?;
                Some(Block::AcaciaSlab(data))
            }
            7288usize..=7293usize => {
                let offset = id - 7288usize;
                let data = DarkOakSlabData::from_value(offset)?;
                Some(Block::DarkOakSlab(data))
            }
            7294usize..=7299usize => {
                let offset = id - 7294usize;
                let data = StoneSlabData::from_value(offset)?;
                Some(Block::StoneSlab(data))
            }
            7300usize..=7305usize => {
                let offset = id - 7300usize;
                let data = SandstoneSlabData::from_value(offset)?;
                Some(Block::SandstoneSlab(data))
            }
            7306usize..=7311usize => {
                let offset = id - 7306usize;
                let data = PetrifiedOakSlabData::from_value(offset)?;
                Some(Block::PetrifiedOakSlab(data))
            }
            7312usize..=7317usize => {
                let offset = id - 7312usize;
                let data = CobblestoneSlabData::from_value(offset)?;
                Some(Block::CobblestoneSlab(data))
            }
            7318usize..=7323usize => {
                let offset = id - 7318usize;
                let data = BrickSlabData::from_value(offset)?;
                Some(Block::BrickSlab(data))
            }
            7324usize..=7329usize => {
                let offset = id - 7324usize;
                let data = StoneBrickSlabData::from_value(offset)?;
                Some(Block::StoneBrickSlab(data))
            }
            7330usize..=7335usize => {
                let offset = id - 7330usize;
                let data = NetherBrickSlabData::from_value(offset)?;
                Some(Block::NetherBrickSlab(data))
            }
            7336usize..=7341usize => {
                let offset = id - 7336usize;
                let data = QuartzSlabData::from_value(offset)?;
                Some(Block::QuartzSlab(data))
            }
            7342usize..=7347usize => {
                let offset = id - 7342usize;
                let data = RedSandstoneSlabData::from_value(offset)?;
                Some(Block::RedSandstoneSlab(data))
            }
            7348usize..=7353usize => {
                let offset = id - 7348usize;
                let data = PurpurSlabData::from_value(offset)?;
                Some(Block::PurpurSlab(data))
            }
            7354usize => Some(Block::SmoothStone),
            7355usize => Some(Block::SmoothSandstone),
            7356usize => Some(Block::SmoothQuartz),
            7357usize => Some(Block::SmoothRedSandstone),
            7358usize..=7389usize => {
                let offset = id - 7358usize;
                let data = SpruceFenceGateData::from_value(offset)?;
                Some(Block::SpruceFenceGate(data))
            }
            7390usize..=7421usize => {
                let offset = id - 7390usize;
                let data = BirchFenceGateData::from_value(offset)?;
                Some(Block::BirchFenceGate(data))
            }
            7422usize..=7453usize => {
                let offset = id - 7422usize;
                let data = JungleFenceGateData::from_value(offset)?;
                Some(Block::JungleFenceGate(data))
            }
            7454usize..=7485usize => {
                let offset = id - 7454usize;
                let data = AcaciaFenceGateData::from_value(offset)?;
                Some(Block::AcaciaFenceGate(data))
            }
            7486usize..=7517usize => {
                let offset = id - 7486usize;
                let data = DarkOakFenceGateData::from_value(offset)?;
                Some(Block::DarkOakFenceGate(data))
            }
            7518usize..=7549usize => {
                let offset = id - 7518usize;
                let data = SpruceFenceData::from_value(offset)?;
                Some(Block::SpruceFence(data))
            }
            7550usize..=7581usize => {
                let offset = id - 7550usize;
                let data = BirchFenceData::from_value(offset)?;
                Some(Block::BirchFence(data))
            }
            7582usize..=7613usize => {
                let offset = id - 7582usize;
                let data = JungleFenceData::from_value(offset)?;
                Some(Block::JungleFence(data))
            }
            7614usize..=7645usize => {
                let offset = id - 7614usize;
                let data = AcaciaFenceData::from_value(offset)?;
                Some(Block::AcaciaFence(data))
            }
            7646usize..=7677usize => {
                let offset = id - 7646usize;
                let data = DarkOakFenceData::from_value(offset)?;
                Some(Block::DarkOakFence(data))
            }
            7678usize..=7741usize => {
                let offset = id - 7678usize;
                let data = SpruceDoorData::from_value(offset)?;
                Some(Block::SpruceDoor(data))
            }
            7742usize..=7805usize => {
                let offset = id - 7742usize;
                let data = BirchDoorData::from_value(offset)?;
                Some(Block::BirchDoor(data))
            }
            7806usize..=7869usize => {
                let offset = id - 7806usize;
                let data = JungleDoorData::from_value(offset)?;
                Some(Block::JungleDoor(data))
            }
            7870usize..=7933usize => {
                let offset = id - 7870usize;
                let data = AcaciaDoorData::from_value(offset)?;
                Some(Block::AcaciaDoor(data))
            }
            7934usize..=7997usize => {
                let offset = id - 7934usize;
                let data = DarkOakDoorData::from_value(offset)?;
                Some(Block::DarkOakDoor(data))
            }
            7998usize..=8003usize => {
                let offset = id - 7998usize;
                let data = EndRodData::from_value(offset)?;
                Some(Block::EndRod(data))
            }
            8004usize..=8067usize => {
                let offset = id - 8004usize;
                let data = ChorusPlantData::from_value(offset)?;
                Some(Block::ChorusPlant(data))
            }
            8068usize..=8073usize => {
                let offset = id - 8068usize;
                let data = ChorusFlowerData::from_value(offset)?;
                Some(Block::ChorusFlower(data))
            }
            8074usize => Some(Block::PurpurBlock),
            8075usize..=8077usize => {
                let offset = id - 8075usize;
                let data = PurpurPillarData::from_value(offset)?;
                Some(Block::PurpurPillar(data))
            }
            8078usize..=8157usize => {
                let offset = id - 8078usize;
                let data = PurpurStairsData::from_value(offset)?;
                Some(Block::PurpurStairs(data))
            }
            8158usize => Some(Block::EndStoneBricks),
            8159usize..=8162usize => {
                let offset = id - 8159usize;
                let data = BeetrootsData::from_value(offset)?;
                Some(Block::Beetroots(data))
            }
            8163usize => Some(Block::GrassPath),
            8164usize => Some(Block::EndGateway),
            8165usize..=8176usize => {
                let offset = id - 8165usize;
                let data = RepeatingCommandBlockData::from_value(offset)?;
                Some(Block::RepeatingCommandBlock(data))
            }
            8177usize..=8188usize => {
                let offset = id - 8177usize;
                let data = ChainCommandBlockData::from_value(offset)?;
                Some(Block::ChainCommandBlock(data))
            }
            8189usize..=8192usize => {
                let offset = id - 8189usize;
                let data = FrostedIceData::from_value(offset)?;
                Some(Block::FrostedIce(data))
            }
            8193usize => Some(Block::MagmaBlock),
            8194usize => Some(Block::NetherWartBlock),
            8195usize => Some(Block::RedNetherBricks),
            8196usize..=8198usize => {
                let offset = id - 8196usize;
                let data = BoneBlockData::from_value(offset)?;
                Some(Block::BoneBlock(data))
            }
            8199usize => Some(Block::StructureVoid),
            8200usize..=8211usize => {
                let offset = id - 8200usize;
                let data = ObserverData::from_value(offset)?;
                Some(Block::Observer(data))
            }
            8212usize..=8217usize => {
                let offset = id - 8212usize;
                let data = ShulkerBoxData::from_value(offset)?;
                Some(Block::ShulkerBox(data))
            }
            8218usize..=8223usize => {
                let offset = id - 8218usize;
                let data = WhiteShulkerBoxData::from_value(offset)?;
                Some(Block::WhiteShulkerBox(data))
            }
            8224usize..=8229usize => {
                let offset = id - 8224usize;
                let data = OrangeShulkerBoxData::from_value(offset)?;
                Some(Block::OrangeShulkerBox(data))
            }
            8230usize..=8235usize => {
                let offset = id - 8230usize;
                let data = MagentaShulkerBoxData::from_value(offset)?;
                Some(Block::MagentaShulkerBox(data))
            }
            8236usize..=8241usize => {
                let offset = id - 8236usize;
                let data = LightBlueShulkerBoxData::from_value(offset)?;
                Some(Block::LightBlueShulkerBox(data))
            }
            8242usize..=8247usize => {
                let offset = id - 8242usize;
                let data = YellowShulkerBoxData::from_value(offset)?;
                Some(Block::YellowShulkerBox(data))
            }
            8248usize..=8253usize => {
                let offset = id - 8248usize;
                let data = LimeShulkerBoxData::from_value(offset)?;
                Some(Block::LimeShulkerBox(data))
            }
            8254usize..=8259usize => {
                let offset = id - 8254usize;
                let data = PinkShulkerBoxData::from_value(offset)?;
                Some(Block::PinkShulkerBox(data))
            }
            8260usize..=8265usize => {
                let offset = id - 8260usize;
                let data = GrayShulkerBoxData::from_value(offset)?;
                Some(Block::GrayShulkerBox(data))
            }
            8266usize..=8271usize => {
                let offset = id - 8266usize;
                let data = LightGrayShulkerBoxData::from_value(offset)?;
                Some(Block::LightGrayShulkerBox(data))
            }
            8272usize..=8277usize => {
                let offset = id - 8272usize;
                let data = CyanShulkerBoxData::from_value(offset)?;
                Some(Block::CyanShulkerBox(data))
            }
            8278usize..=8283usize => {
                let offset = id - 8278usize;
                let data = PurpleShulkerBoxData::from_value(offset)?;
                Some(Block::PurpleShulkerBox(data))
            }
            8284usize..=8289usize => {
                let offset = id - 8284usize;
                let data = BlueShulkerBoxData::from_value(offset)?;
                Some(Block::BlueShulkerBox(data))
            }
            8290usize..=8295usize => {
                let offset = id - 8290usize;
                let data = BrownShulkerBoxData::from_value(offset)?;
                Some(Block::BrownShulkerBox(data))
            }
            8296usize..=8301usize => {
                let offset = id - 8296usize;
                let data = GreenShulkerBoxData::from_value(offset)?;
                Some(Block::GreenShulkerBox(data))
            }
            8302usize..=8307usize => {
                let offset = id - 8302usize;
                let data = RedShulkerBoxData::from_value(offset)?;
                Some(Block::RedShulkerBox(data))
            }
            8308usize..=8313usize => {
                let offset = id - 8308usize;
                let data = BlackShulkerBoxData::from_value(offset)?;
                Some(Block::BlackShulkerBox(data))
            }
            8314usize..=8317usize => {
                let offset = id - 8314usize;
                let data = WhiteGlazedTerracottaData::from_value(offset)?;
                Some(Block::WhiteGlazedTerracotta(data))
            }
            8318usize..=8321usize => {
                let offset = id - 8318usize;
                let data = OrangeGlazedTerracottaData::from_value(offset)?;
                Some(Block::OrangeGlazedTerracotta(data))
            }
            8322usize..=8325usize => {
                let offset = id - 8322usize;
                let data = MagentaGlazedTerracottaData::from_value(offset)?;
                Some(Block::MagentaGlazedTerracotta(data))
            }
            8326usize..=8329usize => {
                let offset = id - 8326usize;
                let data = LightBlueGlazedTerracottaData::from_value(offset)?;
                Some(Block::LightBlueGlazedTerracotta(data))
            }
            8330usize..=8333usize => {
                let offset = id - 8330usize;
                let data = YellowGlazedTerracottaData::from_value(offset)?;
                Some(Block::YellowGlazedTerracotta(data))
            }
            8334usize..=8337usize => {
                let offset = id - 8334usize;
                let data = LimeGlazedTerracottaData::from_value(offset)?;
                Some(Block::LimeGlazedTerracotta(data))
            }
            8338usize..=8341usize => {
                let offset = id - 8338usize;
                let data = PinkGlazedTerracottaData::from_value(offset)?;
                Some(Block::PinkGlazedTerracotta(data))
            }
            8342usize..=8345usize => {
                let offset = id - 8342usize;
                let data = GrayGlazedTerracottaData::from_value(offset)?;
                Some(Block::GrayGlazedTerracotta(data))
            }
            8346usize..=8349usize => {
                let offset = id - 8346usize;
                let data = LightGrayGlazedTerracottaData::from_value(offset)?;
                Some(Block::LightGrayGlazedTerracotta(data))
            }
            8350usize..=8353usize => {
                let offset = id - 8350usize;
                let data = CyanGlazedTerracottaData::from_value(offset)?;
                Some(Block::CyanGlazedTerracotta(data))
            }
            8354usize..=8357usize => {
                let offset = id - 8354usize;
                let data = PurpleGlazedTerracottaData::from_value(offset)?;
                Some(Block::PurpleGlazedTerracotta(data))
            }
            8358usize..=8361usize => {
                let offset = id - 8358usize;
                let data = BlueGlazedTerracottaData::from_value(offset)?;
                Some(Block::BlueGlazedTerracotta(data))
            }
            8362usize..=8365usize => {
                let offset = id - 8362usize;
                let data = BrownGlazedTerracottaData::from_value(offset)?;
                Some(Block::BrownGlazedTerracotta(data))
            }
            8366usize..=8369usize => {
                let offset = id - 8366usize;
                let data = GreenGlazedTerracottaData::from_value(offset)?;
                Some(Block::GreenGlazedTerracotta(data))
            }
            8370usize..=8373usize => {
                let offset = id - 8370usize;
                let data = RedGlazedTerracottaData::from_value(offset)?;
                Some(Block::RedGlazedTerracotta(data))
            }
            8374usize..=8377usize => {
                let offset = id - 8374usize;
                let data = BlackGlazedTerracottaData::from_value(offset)?;
                Some(Block::BlackGlazedTerracotta(data))
            }
            8378usize => Some(Block::WhiteConcrete),
            8379usize => Some(Block::OrangeConcrete),
            8380usize => Some(Block::MagentaConcrete),
            8381usize => Some(Block::LightBlueConcrete),
            8382usize => Some(Block::YellowConcrete),
            8383usize => Some(Block::LimeConcrete),
            8384usize => Some(Block::PinkConcrete),
            8385usize => Some(Block::GrayConcrete),
            8386usize => Some(Block::LightGrayConcrete),
            8387usize => Some(Block::CyanConcrete),
            8388usize => Some(Block::PurpleConcrete),
            8389usize => Some(Block::BlueConcrete),
            8390usize => Some(Block::BrownConcrete),
            8391usize => Some(Block::GreenConcrete),
            8392usize => Some(Block::RedConcrete),
            8393usize => Some(Block::BlackConcrete),
            8394usize => Some(Block::WhiteConcretePowder),
            8395usize => Some(Block::OrangeConcretePowder),
            8396usize => Some(Block::MagentaConcretePowder),
            8397usize => Some(Block::LightBlueConcretePowder),
            8398usize => Some(Block::YellowConcretePowder),
            8399usize => Some(Block::LimeConcretePowder),
            8400usize => Some(Block::PinkConcretePowder),
            8401usize => Some(Block::GrayConcretePowder),
            8402usize => Some(Block::LightGrayConcretePowder),
            8403usize => Some(Block::CyanConcretePowder),
            8404usize => Some(Block::PurpleConcretePowder),
            8405usize => Some(Block::BlueConcretePowder),
            8406usize => Some(Block::BrownConcretePowder),
            8407usize => Some(Block::GreenConcretePowder),
            8408usize => Some(Block::RedConcretePowder),
            8409usize => Some(Block::BlackConcretePowder),
            8410usize..=8435usize => {
                let offset = id - 8410usize;
                let data = KelpData::from_value(offset)?;
                Some(Block::Kelp(data))
            }
            8436usize => Some(Block::KelpPlant),
            8437usize => Some(Block::DriedKelpBlock),
            8438usize..=8449usize => {
                let offset = id - 8438usize;
                let data = TurtleEggData::from_value(offset)?;
                Some(Block::TurtleEgg(data))
            }
            8450usize => Some(Block::DeadTubeCoralBlock),
            8451usize => Some(Block::DeadBrainCoralBlock),
            8452usize => Some(Block::DeadBubbleCoralBlock),
            8453usize => Some(Block::DeadFireCoralBlock),
            8454usize => Some(Block::DeadHornCoralBlock),
            8455usize => Some(Block::TubeCoralBlock),
            8456usize => Some(Block::BrainCoralBlock),
            8457usize => Some(Block::BubbleCoralBlock),
            8458usize => Some(Block::FireCoralBlock),
            8459usize => Some(Block::HornCoralBlock),
            8460usize..=8461usize => {
                let offset = id - 8460usize;
                let data = DeadTubeCoralData::from_value(offset)?;
                Some(Block::DeadTubeCoral(data))
            }
            8462usize..=8463usize => {
                let offset = id - 8462usize;
                let data = DeadBrainCoralData::from_value(offset)?;
                Some(Block::DeadBrainCoral(data))
            }
            8464usize..=8465usize => {
                let offset = id - 8464usize;
                let data = DeadBubbleCoralData::from_value(offset)?;
                Some(Block::DeadBubbleCoral(data))
            }
            8466usize..=8467usize => {
                let offset = id - 8466usize;
                let data = DeadFireCoralData::from_value(offset)?;
                Some(Block::DeadFireCoral(data))
            }
            8468usize..=8469usize => {
                let offset = id - 8468usize;
                let data = DeadHornCoralData::from_value(offset)?;
                Some(Block::DeadHornCoral(data))
            }
            8470usize..=8471usize => {
                let offset = id - 8470usize;
                let data = TubeCoralData::from_value(offset)?;
                Some(Block::TubeCoral(data))
            }
            8472usize..=8473usize => {
                let offset = id - 8472usize;
                let data = BrainCoralData::from_value(offset)?;
                Some(Block::BrainCoral(data))
            }
            8474usize..=8475usize => {
                let offset = id - 8474usize;
                let data = BubbleCoralData::from_value(offset)?;
                Some(Block::BubbleCoral(data))
            }
            8476usize..=8477usize => {
                let offset = id - 8476usize;
                let data = FireCoralData::from_value(offset)?;
                Some(Block::FireCoral(data))
            }
            8478usize..=8479usize => {
                let offset = id - 8478usize;
                let data = HornCoralData::from_value(offset)?;
                Some(Block::HornCoral(data))
            }
            8480usize..=8487usize => {
                let offset = id - 8480usize;
                let data = DeadTubeCoralWallFanData::from_value(offset)?;
                Some(Block::DeadTubeCoralWallFan(data))
            }
            8488usize..=8495usize => {
                let offset = id - 8488usize;
                let data = DeadBrainCoralWallFanData::from_value(offset)?;
                Some(Block::DeadBrainCoralWallFan(data))
            }
            8496usize..=8503usize => {
                let offset = id - 8496usize;
                let data = DeadBubbleCoralWallFanData::from_value(offset)?;
                Some(Block::DeadBubbleCoralWallFan(data))
            }
            8504usize..=8511usize => {
                let offset = id - 8504usize;
                let data = DeadFireCoralWallFanData::from_value(offset)?;
                Some(Block::DeadFireCoralWallFan(data))
            }
            8512usize..=8519usize => {
                let offset = id - 8512usize;
                let data = DeadHornCoralWallFanData::from_value(offset)?;
                Some(Block::DeadHornCoralWallFan(data))
            }
            8520usize..=8527usize => {
                let offset = id - 8520usize;
                let data = TubeCoralWallFanData::from_value(offset)?;
                Some(Block::TubeCoralWallFan(data))
            }
            8528usize..=8535usize => {
                let offset = id - 8528usize;
                let data = BrainCoralWallFanData::from_value(offset)?;
                Some(Block::BrainCoralWallFan(data))
            }
            8536usize..=8543usize => {
                let offset = id - 8536usize;
                let data = BubbleCoralWallFanData::from_value(offset)?;
                Some(Block::BubbleCoralWallFan(data))
            }
            8544usize..=8551usize => {
                let offset = id - 8544usize;
                let data = FireCoralWallFanData::from_value(offset)?;
                Some(Block::FireCoralWallFan(data))
            }
            8552usize..=8559usize => {
                let offset = id - 8552usize;
                let data = HornCoralWallFanData::from_value(offset)?;
                Some(Block::HornCoralWallFan(data))
            }
            8560usize..=8561usize => {
                let offset = id - 8560usize;
                let data = DeadTubeCoralFanData::from_value(offset)?;
                Some(Block::DeadTubeCoralFan(data))
            }
            8562usize..=8563usize => {
                let offset = id - 8562usize;
                let data = DeadBrainCoralFanData::from_value(offset)?;
                Some(Block::DeadBrainCoralFan(data))
            }
            8564usize..=8565usize => {
                let offset = id - 8564usize;
                let data = DeadBubbleCoralFanData::from_value(offset)?;
                Some(Block::DeadBubbleCoralFan(data))
            }
            8566usize..=8567usize => {
                let offset = id - 8566usize;
                let data = DeadFireCoralFanData::from_value(offset)?;
                Some(Block::DeadFireCoralFan(data))
            }
            8568usize..=8569usize => {
                let offset = id - 8568usize;
                let data = DeadHornCoralFanData::from_value(offset)?;
                Some(Block::DeadHornCoralFan(data))
            }
            8570usize..=8571usize => {
                let offset = id - 8570usize;
                let data = TubeCoralFanData::from_value(offset)?;
                Some(Block::TubeCoralFan(data))
            }
            8572usize..=8573usize => {
                let offset = id - 8572usize;
                let data = BrainCoralFanData::from_value(offset)?;
                Some(Block::BrainCoralFan(data))
            }
            8574usize..=8575usize => {
                let offset = id - 8574usize;
                let data = BubbleCoralFanData::from_value(offset)?;
                Some(Block::BubbleCoralFan(data))
            }
            8576usize..=8577usize => {
                let offset = id - 8576usize;
                let data = FireCoralFanData::from_value(offset)?;
                Some(Block::FireCoralFan(data))
            }
            8578usize..=8579usize => {
                let offset = id - 8578usize;
                let data = HornCoralFanData::from_value(offset)?;
                Some(Block::HornCoralFan(data))
            }
            8580usize..=8587usize => {
                let offset = id - 8580usize;
                let data = SeaPickleData::from_value(offset)?;
                Some(Block::SeaPickle(data))
            }
            8588usize => Some(Block::BlueIce),
            8589usize..=8590usize => {
                let offset = id - 8589usize;
                let data = ConduitData::from_value(offset)?;
                Some(Block::Conduit(data))
            }
            8591usize => Some(Block::VoidAir),
            8592usize => Some(Block::CaveAir),
            8593usize..=8594usize => {
                let offset = id - 8593usize;
                let data = BubbleColumnData::from_value(offset)?;
                Some(Block::BubbleColumn(data))
            }
            8595usize..=8598usize => {
                let offset = id - 8595usize;
                let data = StructureBlockData::from_value(offset)?;
                Some(Block::StructureBlock(data))
            }
            _ => None,
        }
    }
}
pub trait Value {
    fn value(&self) -> usize;
    fn from_value(val: usize) -> Option<Self>
    where
        Self: Sized;
}
impl Value for i32 {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Some(val as i32)
    }
}
impl Value for bool {
    fn value(&self) -> usize {
        match *self {
            true => 1,
            false => 0,
        }
    }
    fn from_value(val: usize) -> Option<Self> {
        match val {
            0 => Some(false),
            1 => Some(true),
            _ => None,
        }
    }
}
pub trait FromSnakeCase {
    fn from_snake_case(val: &str) -> Option<Self>
    where
        Self: Sized;
}
impl FromSnakeCase for i32 {
    fn from_snake_case(val: &str) -> Option<Self> {
        use std::str::FromStr;
        match i32::from_str(val) {
            Ok(x) => Some(x),
            Err(_) => None,
        }
    }
}
impl FromSnakeCase for bool {
    fn from_snake_case(val: &str) -> Option<Self> {
        use std::str::FromStr;
        match bool::from_str(val) {
            Ok(x) => Some(x),
            Err(_) => None,
        }
    }
}
pub trait ToSnakeCase {
    fn to_snake_case(&self) -> String;
}
impl ToSnakeCase for i32 {
    fn to_snake_case(&self) -> String {
        self.to_string()
    }
}
impl ToSnakeCase for bool {
    fn to_snake_case(&self) -> String {
        self.to_string()
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct GrassBlockData {
    pub snowy: bool,
}
impl GrassBlockData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            snowy: bool::from_snake_case(map.get("snowy")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("snowy".to_string(), self.snowy.to_snake_case());
        m
    }
}
impl Default for GrassBlockData {
    fn default() -> Self {
        Self { snowy: false }
    }
}
impl Value for GrassBlockData {
    fn value(&self) -> usize {
        (self.snowy.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let snowy = bool::from_value(val / 1usize).unwrap();
        val -= (snowy.value() - 0usize) * 1usize;
        Some(Self { snowy })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PodzolData {
    pub snowy: bool,
}
impl PodzolData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            snowy: bool::from_snake_case(map.get("snowy")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("snowy".to_string(), self.snowy.to_snake_case());
        m
    }
}
impl Default for PodzolData {
    fn default() -> Self {
        Self { snowy: false }
    }
}
impl Value for PodzolData {
    fn value(&self) -> usize {
        (self.snowy.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let snowy = bool::from_value(val / 1usize).unwrap();
        val -= (snowy.value() - 0usize) * 1usize;
        Some(Self { snowy })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OakSaplingData {
    pub stage: i32,
}
impl OakSaplingData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            stage: i32::from_snake_case(map.get("stage")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("stage".to_string(), self.stage.to_snake_case());
        m
    }
}
impl Default for OakSaplingData {
    fn default() -> Self {
        Self { stage: 0 }
    }
}
impl Value for OakSaplingData {
    fn value(&self) -> usize {
        (self.stage.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let stage = i32::from_value(val / 1usize).unwrap();
        val -= (stage.value() - 0usize) * 1usize;
        Some(Self { stage })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SpruceSaplingData {
    pub stage: i32,
}
impl SpruceSaplingData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            stage: i32::from_snake_case(map.get("stage")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("stage".to_string(), self.stage.to_snake_case());
        m
    }
}
impl Default for SpruceSaplingData {
    fn default() -> Self {
        Self { stage: 0 }
    }
}
impl Value for SpruceSaplingData {
    fn value(&self) -> usize {
        (self.stage.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let stage = i32::from_value(val / 1usize).unwrap();
        val -= (stage.value() - 0usize) * 1usize;
        Some(Self { stage })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BirchSaplingData {
    pub stage: i32,
}
impl BirchSaplingData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            stage: i32::from_snake_case(map.get("stage")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("stage".to_string(), self.stage.to_snake_case());
        m
    }
}
impl Default for BirchSaplingData {
    fn default() -> Self {
        Self { stage: 0 }
    }
}
impl Value for BirchSaplingData {
    fn value(&self) -> usize {
        (self.stage.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let stage = i32::from_value(val / 1usize).unwrap();
        val -= (stage.value() - 0usize) * 1usize;
        Some(Self { stage })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct JungleSaplingData {
    pub stage: i32,
}
impl JungleSaplingData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            stage: i32::from_snake_case(map.get("stage")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("stage".to_string(), self.stage.to_snake_case());
        m
    }
}
impl Default for JungleSaplingData {
    fn default() -> Self {
        Self { stage: 0 }
    }
}
impl Value for JungleSaplingData {
    fn value(&self) -> usize {
        (self.stage.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let stage = i32::from_value(val / 1usize).unwrap();
        val -= (stage.value() - 0usize) * 1usize;
        Some(Self { stage })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AcaciaSaplingData {
    pub stage: i32,
}
impl AcaciaSaplingData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            stage: i32::from_snake_case(map.get("stage")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("stage".to_string(), self.stage.to_snake_case());
        m
    }
}
impl Default for AcaciaSaplingData {
    fn default() -> Self {
        Self { stage: 0 }
    }
}
impl Value for AcaciaSaplingData {
    fn value(&self) -> usize {
        (self.stage.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let stage = i32::from_value(val / 1usize).unwrap();
        val -= (stage.value() - 0usize) * 1usize;
        Some(Self { stage })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DarkOakSaplingData {
    pub stage: i32,
}
impl DarkOakSaplingData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            stage: i32::from_snake_case(map.get("stage")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("stage".to_string(), self.stage.to_snake_case());
        m
    }
}
impl Default for DarkOakSaplingData {
    fn default() -> Self {
        Self { stage: 0 }
    }
}
impl Value for DarkOakSaplingData {
    fn value(&self) -> usize {
        (self.stage.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let stage = i32::from_value(val / 1usize).unwrap();
        val -= (stage.value() - 0usize) * 1usize;
        Some(Self { stage })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct WaterData {
    pub level: i32,
}
impl WaterData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            level: i32::from_snake_case(map.get("level")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("level".to_string(), self.level.to_snake_case());
        m
    }
}
impl Default for WaterData {
    fn default() -> Self {
        Self { level: 0 }
    }
}
impl Value for WaterData {
    fn value(&self) -> usize {
        (self.level.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let level = i32::from_value(val / 1usize).unwrap();
        val -= (level.value() - 0usize) * 1usize;
        Some(Self { level })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LavaData {
    pub level: i32,
}
impl LavaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            level: i32::from_snake_case(map.get("level")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("level".to_string(), self.level.to_snake_case());
        m
    }
}
impl Default for LavaData {
    fn default() -> Self {
        Self { level: 0 }
    }
}
impl Value for LavaData {
    fn value(&self) -> usize {
        (self.level.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let level = i32::from_value(val / 1usize).unwrap();
        val -= (level.value() - 0usize) * 1usize;
        Some(Self { level })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OakLogData {
    pub axis: OakLogAxis,
}
impl OakLogData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: OakLogAxis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Default for OakLogData {
    fn default() -> Self {
        Self {
            axis: OakLogAxis::Y,
        }
    }
}
impl Value for OakLogData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 3usize {
            return None;
        }
        let axis = OakLogAxis::from_value(val / 1usize).unwrap();
        val -= (axis.value() - 0usize) * 1usize;
        Some(Self { axis })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SpruceLogData {
    pub axis: SpruceLogAxis,
}
impl SpruceLogData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: SpruceLogAxis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Default for SpruceLogData {
    fn default() -> Self {
        Self {
            axis: SpruceLogAxis::Y,
        }
    }
}
impl Value for SpruceLogData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 3usize {
            return None;
        }
        let axis = SpruceLogAxis::from_value(val / 1usize).unwrap();
        val -= (axis.value() - 0usize) * 1usize;
        Some(Self { axis })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BirchLogData {
    pub axis: BirchLogAxis,
}
impl BirchLogData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: BirchLogAxis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Default for BirchLogData {
    fn default() -> Self {
        Self {
            axis: BirchLogAxis::Y,
        }
    }
}
impl Value for BirchLogData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 3usize {
            return None;
        }
        let axis = BirchLogAxis::from_value(val / 1usize).unwrap();
        val -= (axis.value() - 0usize) * 1usize;
        Some(Self { axis })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct JungleLogData {
    pub axis: JungleLogAxis,
}
impl JungleLogData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: JungleLogAxis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Default for JungleLogData {
    fn default() -> Self {
        Self {
            axis: JungleLogAxis::Y,
        }
    }
}
impl Value for JungleLogData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 3usize {
            return None;
        }
        let axis = JungleLogAxis::from_value(val / 1usize).unwrap();
        val -= (axis.value() - 0usize) * 1usize;
        Some(Self { axis })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AcaciaLogData {
    pub axis: AcaciaLogAxis,
}
impl AcaciaLogData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: AcaciaLogAxis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Default for AcaciaLogData {
    fn default() -> Self {
        Self {
            axis: AcaciaLogAxis::Y,
        }
    }
}
impl Value for AcaciaLogData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 3usize {
            return None;
        }
        let axis = AcaciaLogAxis::from_value(val / 1usize).unwrap();
        val -= (axis.value() - 0usize) * 1usize;
        Some(Self { axis })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DarkOakLogData {
    pub axis: DarkOakLogAxis,
}
impl DarkOakLogData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: DarkOakLogAxis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Default for DarkOakLogData {
    fn default() -> Self {
        Self {
            axis: DarkOakLogAxis::Y,
        }
    }
}
impl Value for DarkOakLogData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 3usize {
            return None;
        }
        let axis = DarkOakLogAxis::from_value(val / 1usize).unwrap();
        val -= (axis.value() - 0usize) * 1usize;
        Some(Self { axis })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StrippedSpruceLogData {
    pub axis: StrippedSpruceLogAxis,
}
impl StrippedSpruceLogData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: StrippedSpruceLogAxis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Default for StrippedSpruceLogData {
    fn default() -> Self {
        Self {
            axis: StrippedSpruceLogAxis::Y,
        }
    }
}
impl Value for StrippedSpruceLogData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 3usize {
            return None;
        }
        let axis = StrippedSpruceLogAxis::from_value(val / 1usize).unwrap();
        val -= (axis.value() - 0usize) * 1usize;
        Some(Self { axis })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StrippedBirchLogData {
    pub axis: StrippedBirchLogAxis,
}
impl StrippedBirchLogData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: StrippedBirchLogAxis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Default for StrippedBirchLogData {
    fn default() -> Self {
        Self {
            axis: StrippedBirchLogAxis::Y,
        }
    }
}
impl Value for StrippedBirchLogData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 3usize {
            return None;
        }
        let axis = StrippedBirchLogAxis::from_value(val / 1usize).unwrap();
        val -= (axis.value() - 0usize) * 1usize;
        Some(Self { axis })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StrippedJungleLogData {
    pub axis: StrippedJungleLogAxis,
}
impl StrippedJungleLogData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: StrippedJungleLogAxis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Default for StrippedJungleLogData {
    fn default() -> Self {
        Self {
            axis: StrippedJungleLogAxis::Y,
        }
    }
}
impl Value for StrippedJungleLogData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 3usize {
            return None;
        }
        let axis = StrippedJungleLogAxis::from_value(val / 1usize).unwrap();
        val -= (axis.value() - 0usize) * 1usize;
        Some(Self { axis })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StrippedAcaciaLogData {
    pub axis: StrippedAcaciaLogAxis,
}
impl StrippedAcaciaLogData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: StrippedAcaciaLogAxis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Default for StrippedAcaciaLogData {
    fn default() -> Self {
        Self {
            axis: StrippedAcaciaLogAxis::Y,
        }
    }
}
impl Value for StrippedAcaciaLogData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 3usize {
            return None;
        }
        let axis = StrippedAcaciaLogAxis::from_value(val / 1usize).unwrap();
        val -= (axis.value() - 0usize) * 1usize;
        Some(Self { axis })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StrippedDarkOakLogData {
    pub axis: StrippedDarkOakLogAxis,
}
impl StrippedDarkOakLogData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: StrippedDarkOakLogAxis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Default for StrippedDarkOakLogData {
    fn default() -> Self {
        Self {
            axis: StrippedDarkOakLogAxis::Y,
        }
    }
}
impl Value for StrippedDarkOakLogData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 3usize {
            return None;
        }
        let axis = StrippedDarkOakLogAxis::from_value(val / 1usize).unwrap();
        val -= (axis.value() - 0usize) * 1usize;
        Some(Self { axis })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StrippedOakLogData {
    pub axis: StrippedOakLogAxis,
}
impl StrippedOakLogData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: StrippedOakLogAxis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Default for StrippedOakLogData {
    fn default() -> Self {
        Self {
            axis: StrippedOakLogAxis::Y,
        }
    }
}
impl Value for StrippedOakLogData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 3usize {
            return None;
        }
        let axis = StrippedOakLogAxis::from_value(val / 1usize).unwrap();
        val -= (axis.value() - 0usize) * 1usize;
        Some(Self { axis })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OakWoodData {
    pub axis: OakWoodAxis,
}
impl OakWoodData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: OakWoodAxis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Default for OakWoodData {
    fn default() -> Self {
        Self {
            axis: OakWoodAxis::Y,
        }
    }
}
impl Value for OakWoodData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 3usize {
            return None;
        }
        let axis = OakWoodAxis::from_value(val / 1usize).unwrap();
        val -= (axis.value() - 0usize) * 1usize;
        Some(Self { axis })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SpruceWoodData {
    pub axis: SpruceWoodAxis,
}
impl SpruceWoodData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: SpruceWoodAxis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Default for SpruceWoodData {
    fn default() -> Self {
        Self {
            axis: SpruceWoodAxis::Y,
        }
    }
}
impl Value for SpruceWoodData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 3usize {
            return None;
        }
        let axis = SpruceWoodAxis::from_value(val / 1usize).unwrap();
        val -= (axis.value() - 0usize) * 1usize;
        Some(Self { axis })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BirchWoodData {
    pub axis: BirchWoodAxis,
}
impl BirchWoodData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: BirchWoodAxis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Default for BirchWoodData {
    fn default() -> Self {
        Self {
            axis: BirchWoodAxis::Y,
        }
    }
}
impl Value for BirchWoodData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 3usize {
            return None;
        }
        let axis = BirchWoodAxis::from_value(val / 1usize).unwrap();
        val -= (axis.value() - 0usize) * 1usize;
        Some(Self { axis })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct JungleWoodData {
    pub axis: JungleWoodAxis,
}
impl JungleWoodData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: JungleWoodAxis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Default for JungleWoodData {
    fn default() -> Self {
        Self {
            axis: JungleWoodAxis::Y,
        }
    }
}
impl Value for JungleWoodData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 3usize {
            return None;
        }
        let axis = JungleWoodAxis::from_value(val / 1usize).unwrap();
        val -= (axis.value() - 0usize) * 1usize;
        Some(Self { axis })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AcaciaWoodData {
    pub axis: AcaciaWoodAxis,
}
impl AcaciaWoodData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: AcaciaWoodAxis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Default for AcaciaWoodData {
    fn default() -> Self {
        Self {
            axis: AcaciaWoodAxis::Y,
        }
    }
}
impl Value for AcaciaWoodData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 3usize {
            return None;
        }
        let axis = AcaciaWoodAxis::from_value(val / 1usize).unwrap();
        val -= (axis.value() - 0usize) * 1usize;
        Some(Self { axis })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DarkOakWoodData {
    pub axis: DarkOakWoodAxis,
}
impl DarkOakWoodData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: DarkOakWoodAxis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Default for DarkOakWoodData {
    fn default() -> Self {
        Self {
            axis: DarkOakWoodAxis::Y,
        }
    }
}
impl Value for DarkOakWoodData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 3usize {
            return None;
        }
        let axis = DarkOakWoodAxis::from_value(val / 1usize).unwrap();
        val -= (axis.value() - 0usize) * 1usize;
        Some(Self { axis })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StrippedOakWoodData {
    pub axis: StrippedOakWoodAxis,
}
impl StrippedOakWoodData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: StrippedOakWoodAxis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Default for StrippedOakWoodData {
    fn default() -> Self {
        Self {
            axis: StrippedOakWoodAxis::Y,
        }
    }
}
impl Value for StrippedOakWoodData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 3usize {
            return None;
        }
        let axis = StrippedOakWoodAxis::from_value(val / 1usize).unwrap();
        val -= (axis.value() - 0usize) * 1usize;
        Some(Self { axis })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StrippedSpruceWoodData {
    pub axis: StrippedSpruceWoodAxis,
}
impl StrippedSpruceWoodData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: StrippedSpruceWoodAxis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Default for StrippedSpruceWoodData {
    fn default() -> Self {
        Self {
            axis: StrippedSpruceWoodAxis::Y,
        }
    }
}
impl Value for StrippedSpruceWoodData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 3usize {
            return None;
        }
        let axis = StrippedSpruceWoodAxis::from_value(val / 1usize).unwrap();
        val -= (axis.value() - 0usize) * 1usize;
        Some(Self { axis })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StrippedBirchWoodData {
    pub axis: StrippedBirchWoodAxis,
}
impl StrippedBirchWoodData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: StrippedBirchWoodAxis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Default for StrippedBirchWoodData {
    fn default() -> Self {
        Self {
            axis: StrippedBirchWoodAxis::Y,
        }
    }
}
impl Value for StrippedBirchWoodData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 3usize {
            return None;
        }
        let axis = StrippedBirchWoodAxis::from_value(val / 1usize).unwrap();
        val -= (axis.value() - 0usize) * 1usize;
        Some(Self { axis })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StrippedJungleWoodData {
    pub axis: StrippedJungleWoodAxis,
}
impl StrippedJungleWoodData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: StrippedJungleWoodAxis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Default for StrippedJungleWoodData {
    fn default() -> Self {
        Self {
            axis: StrippedJungleWoodAxis::Y,
        }
    }
}
impl Value for StrippedJungleWoodData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 3usize {
            return None;
        }
        let axis = StrippedJungleWoodAxis::from_value(val / 1usize).unwrap();
        val -= (axis.value() - 0usize) * 1usize;
        Some(Self { axis })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StrippedAcaciaWoodData {
    pub axis: StrippedAcaciaWoodAxis,
}
impl StrippedAcaciaWoodData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: StrippedAcaciaWoodAxis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Default for StrippedAcaciaWoodData {
    fn default() -> Self {
        Self {
            axis: StrippedAcaciaWoodAxis::Y,
        }
    }
}
impl Value for StrippedAcaciaWoodData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 3usize {
            return None;
        }
        let axis = StrippedAcaciaWoodAxis::from_value(val / 1usize).unwrap();
        val -= (axis.value() - 0usize) * 1usize;
        Some(Self { axis })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StrippedDarkOakWoodData {
    pub axis: StrippedDarkOakWoodAxis,
}
impl StrippedDarkOakWoodData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: StrippedDarkOakWoodAxis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Default for StrippedDarkOakWoodData {
    fn default() -> Self {
        Self {
            axis: StrippedDarkOakWoodAxis::Y,
        }
    }
}
impl Value for StrippedDarkOakWoodData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 3usize {
            return None;
        }
        let axis = StrippedDarkOakWoodAxis::from_value(val / 1usize).unwrap();
        val -= (axis.value() - 0usize) * 1usize;
        Some(Self { axis })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OakLeavesData {
    pub persistent: bool,
    pub distance: i32,
}
impl OakLeavesData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            persistent: bool::from_snake_case(map.get("persistent")?)?,
            distance: i32::from_snake_case(map.get("distance")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("persistent".to_string(), self.persistent.to_snake_case());
        m.insert("distance".to_string(), self.distance.to_snake_case());
        m
    }
}
impl Default for OakLeavesData {
    fn default() -> Self {
        Self {
            persistent: false,
            distance: 7,
        }
    }
}
impl Value for OakLeavesData {
    fn value(&self) -> usize {
        (self.persistent.value() * 7usize) + ((self.distance.value() - 1) * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 14usize {
            return None;
        }
        let persistent = bool::from_value(val / 7usize).unwrap();
        val -= (persistent.value() - 0usize) * 7usize;
        let distance = i32::from_value(val / 1usize).unwrap() + 1i32;
        val -= (distance.value() - 1usize) * 1usize;
        Some(Self {
            persistent,
            distance,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SpruceLeavesData {
    pub persistent: bool,
    pub distance: i32,
}
impl SpruceLeavesData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            persistent: bool::from_snake_case(map.get("persistent")?)?,
            distance: i32::from_snake_case(map.get("distance")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("persistent".to_string(), self.persistent.to_snake_case());
        m.insert("distance".to_string(), self.distance.to_snake_case());
        m
    }
}
impl Default for SpruceLeavesData {
    fn default() -> Self {
        Self {
            persistent: false,
            distance: 7,
        }
    }
}
impl Value for SpruceLeavesData {
    fn value(&self) -> usize {
        (self.persistent.value() * 7usize) + ((self.distance.value() - 1) * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 14usize {
            return None;
        }
        let persistent = bool::from_value(val / 7usize).unwrap();
        val -= (persistent.value() - 0usize) * 7usize;
        let distance = i32::from_value(val / 1usize).unwrap() + 1i32;
        val -= (distance.value() - 1usize) * 1usize;
        Some(Self {
            persistent,
            distance,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BirchLeavesData {
    pub distance: i32,
    pub persistent: bool,
}
impl BirchLeavesData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            distance: i32::from_snake_case(map.get("distance")?)?,
            persistent: bool::from_snake_case(map.get("persistent")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("distance".to_string(), self.distance.to_snake_case());
        m.insert("persistent".to_string(), self.persistent.to_snake_case());
        m
    }
}
impl Default for BirchLeavesData {
    fn default() -> Self {
        Self {
            distance: 7,
            persistent: false,
        }
    }
}
impl Value for BirchLeavesData {
    fn value(&self) -> usize {
        ((self.distance.value() - 1) * 2usize) + (self.persistent.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 14usize {
            return None;
        }
        let distance = i32::from_value(val / 2usize).unwrap() + 1i32;
        val -= (distance.value() - 1usize) * 2usize;
        let persistent = bool::from_value(val / 1usize).unwrap();
        val -= (persistent.value() - 0usize) * 1usize;
        Some(Self {
            distance,
            persistent,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct JungleLeavesData {
    pub distance: i32,
    pub persistent: bool,
}
impl JungleLeavesData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            distance: i32::from_snake_case(map.get("distance")?)?,
            persistent: bool::from_snake_case(map.get("persistent")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("distance".to_string(), self.distance.to_snake_case());
        m.insert("persistent".to_string(), self.persistent.to_snake_case());
        m
    }
}
impl Default for JungleLeavesData {
    fn default() -> Self {
        Self {
            distance: 7,
            persistent: false,
        }
    }
}
impl Value for JungleLeavesData {
    fn value(&self) -> usize {
        ((self.distance.value() - 1) * 2usize) + (self.persistent.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 14usize {
            return None;
        }
        let distance = i32::from_value(val / 2usize).unwrap() + 1i32;
        val -= (distance.value() - 1usize) * 2usize;
        let persistent = bool::from_value(val / 1usize).unwrap();
        val -= (persistent.value() - 0usize) * 1usize;
        Some(Self {
            distance,
            persistent,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AcaciaLeavesData {
    pub persistent: bool,
    pub distance: i32,
}
impl AcaciaLeavesData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            persistent: bool::from_snake_case(map.get("persistent")?)?,
            distance: i32::from_snake_case(map.get("distance")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("persistent".to_string(), self.persistent.to_snake_case());
        m.insert("distance".to_string(), self.distance.to_snake_case());
        m
    }
}
impl Default for AcaciaLeavesData {
    fn default() -> Self {
        Self {
            persistent: false,
            distance: 7,
        }
    }
}
impl Value for AcaciaLeavesData {
    fn value(&self) -> usize {
        (self.persistent.value() * 7usize) + ((self.distance.value() - 1) * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 14usize {
            return None;
        }
        let persistent = bool::from_value(val / 7usize).unwrap();
        val -= (persistent.value() - 0usize) * 7usize;
        let distance = i32::from_value(val / 1usize).unwrap() + 1i32;
        val -= (distance.value() - 1usize) * 1usize;
        Some(Self {
            persistent,
            distance,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DarkOakLeavesData {
    pub distance: i32,
    pub persistent: bool,
}
impl DarkOakLeavesData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            distance: i32::from_snake_case(map.get("distance")?)?,
            persistent: bool::from_snake_case(map.get("persistent")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("distance".to_string(), self.distance.to_snake_case());
        m.insert("persistent".to_string(), self.persistent.to_snake_case());
        m
    }
}
impl Default for DarkOakLeavesData {
    fn default() -> Self {
        Self {
            distance: 7,
            persistent: false,
        }
    }
}
impl Value for DarkOakLeavesData {
    fn value(&self) -> usize {
        ((self.distance.value() - 1) * 2usize) + (self.persistent.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 14usize {
            return None;
        }
        let distance = i32::from_value(val / 2usize).unwrap() + 1i32;
        val -= (distance.value() - 1usize) * 2usize;
        let persistent = bool::from_value(val / 1usize).unwrap();
        val -= (persistent.value() - 0usize) * 1usize;
        Some(Self {
            distance,
            persistent,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DispenserData {
    pub facing: DispenserFacing,
    pub triggered: bool,
}
impl DispenserData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: DispenserFacing::from_snake_case(map.get("facing")?)?,
            triggered: bool::from_snake_case(map.get("triggered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("triggered".to_string(), self.triggered.to_snake_case());
        m
    }
}
impl Default for DispenserData {
    fn default() -> Self {
        Self {
            facing: DispenserFacing::North,
            triggered: false,
        }
    }
}
impl Value for DispenserData {
    fn value(&self) -> usize {
        (self.facing.value() * 2usize) + (self.triggered.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 12usize {
            return None;
        }
        let facing = DispenserFacing::from_value(val / 2usize).unwrap();
        val -= (facing.value() - 0usize) * 2usize;
        let triggered = bool::from_value(val / 1usize).unwrap();
        val -= (triggered.value() - 0usize) * 1usize;
        Some(Self { facing, triggered })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct NoteBlockData {
    pub instrument: NoteBlockInstrument,
    pub note: i32,
    pub powered: bool,
}
impl NoteBlockData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            instrument: NoteBlockInstrument::from_snake_case(map.get("instrument")?)?,
            note: i32::from_snake_case(map.get("note")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("instrument".to_string(), self.instrument.to_snake_case());
        m.insert("note".to_string(), self.note.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Default for NoteBlockData {
    fn default() -> Self {
        Self {
            instrument: NoteBlockInstrument::Harp,
            note: 0,
            powered: false,
        }
    }
}
impl Value for NoteBlockData {
    fn value(&self) -> usize {
        (self.instrument.value() * 50usize)
            + (self.note.value() * 2usize)
            + (self.powered.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 500usize {
            return None;
        }
        let instrument = NoteBlockInstrument::from_value(val / 50usize).unwrap();
        val -= (instrument.value() - 0usize) * 50usize;
        let note = i32::from_value(val / 2usize).unwrap();
        val -= (note.value() - 0usize) * 2usize;
        let powered = bool::from_value(val / 1usize).unwrap();
        val -= (powered.value() - 0usize) * 1usize;
        Some(Self {
            instrument,
            note,
            powered,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct WhiteBedData {
    pub occupied: bool,
    pub part: WhiteBedPart,
    pub facing: WhiteBedFacing,
}
impl WhiteBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            occupied: bool::from_snake_case(map.get("occupied")?)?,
            part: WhiteBedPart::from_snake_case(map.get("part")?)?,
            facing: WhiteBedFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m.insert("part".to_string(), self.part.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for WhiteBedData {
    fn default() -> Self {
        Self {
            occupied: false,
            part: WhiteBedPart::Foot,
            facing: WhiteBedFacing::North,
        }
    }
}
impl Value for WhiteBedData {
    fn value(&self) -> usize {
        (self.occupied.value() * 8usize)
            + (self.part.value() * 4usize)
            + (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let occupied = bool::from_value(val / 8usize).unwrap();
        val -= (occupied.value() - 0usize) * 8usize;
        let part = WhiteBedPart::from_value(val / 4usize).unwrap();
        val -= (part.value() - 0usize) * 4usize;
        let facing = WhiteBedFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self {
            occupied,
            part,
            facing,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OrangeBedData {
    pub facing: OrangeBedFacing,
    pub occupied: bool,
    pub part: OrangeBedPart,
}
impl OrangeBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: OrangeBedFacing::from_snake_case(map.get("facing")?)?,
            occupied: bool::from_snake_case(map.get("occupied")?)?,
            part: OrangeBedPart::from_snake_case(map.get("part")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m.insert("part".to_string(), self.part.to_snake_case());
        m
    }
}
impl Default for OrangeBedData {
    fn default() -> Self {
        Self {
            facing: OrangeBedFacing::North,
            occupied: false,
            part: OrangeBedPart::Foot,
        }
    }
}
impl Value for OrangeBedData {
    fn value(&self) -> usize {
        (self.facing.value() * 4usize)
            + (self.occupied.value() * 2usize)
            + (self.part.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let facing = OrangeBedFacing::from_value(val / 4usize).unwrap();
        val -= (facing.value() - 0usize) * 4usize;
        let occupied = bool::from_value(val / 2usize).unwrap();
        val -= (occupied.value() - 0usize) * 2usize;
        let part = OrangeBedPart::from_value(val / 1usize).unwrap();
        val -= (part.value() - 0usize) * 1usize;
        Some(Self {
            facing,
            occupied,
            part,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct MagentaBedData {
    pub occupied: bool,
    pub facing: MagentaBedFacing,
    pub part: MagentaBedPart,
}
impl MagentaBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            occupied: bool::from_snake_case(map.get("occupied")?)?,
            facing: MagentaBedFacing::from_snake_case(map.get("facing")?)?,
            part: MagentaBedPart::from_snake_case(map.get("part")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("part".to_string(), self.part.to_snake_case());
        m
    }
}
impl Default for MagentaBedData {
    fn default() -> Self {
        Self {
            occupied: false,
            facing: MagentaBedFacing::North,
            part: MagentaBedPart::Foot,
        }
    }
}
impl Value for MagentaBedData {
    fn value(&self) -> usize {
        (self.occupied.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.part.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let occupied = bool::from_value(val / 8usize).unwrap();
        val -= (occupied.value() - 0usize) * 8usize;
        let facing = MagentaBedFacing::from_value(val / 2usize).unwrap();
        val -= (facing.value() - 0usize) * 2usize;
        let part = MagentaBedPart::from_value(val / 1usize).unwrap();
        val -= (part.value() - 0usize) * 1usize;
        Some(Self {
            occupied,
            facing,
            part,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LightBlueBedData {
    pub occupied: bool,
    pub part: LightBlueBedPart,
    pub facing: LightBlueBedFacing,
}
impl LightBlueBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            occupied: bool::from_snake_case(map.get("occupied")?)?,
            part: LightBlueBedPart::from_snake_case(map.get("part")?)?,
            facing: LightBlueBedFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m.insert("part".to_string(), self.part.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for LightBlueBedData {
    fn default() -> Self {
        Self {
            occupied: false,
            part: LightBlueBedPart::Foot,
            facing: LightBlueBedFacing::North,
        }
    }
}
impl Value for LightBlueBedData {
    fn value(&self) -> usize {
        (self.occupied.value() * 8usize)
            + (self.part.value() * 4usize)
            + (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let occupied = bool::from_value(val / 8usize).unwrap();
        val -= (occupied.value() - 0usize) * 8usize;
        let part = LightBlueBedPart::from_value(val / 4usize).unwrap();
        val -= (part.value() - 0usize) * 4usize;
        let facing = LightBlueBedFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self {
            occupied,
            part,
            facing,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct YellowBedData {
    pub part: YellowBedPart,
    pub occupied: bool,
    pub facing: YellowBedFacing,
}
impl YellowBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            part: YellowBedPart::from_snake_case(map.get("part")?)?,
            occupied: bool::from_snake_case(map.get("occupied")?)?,
            facing: YellowBedFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("part".to_string(), self.part.to_snake_case());
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for YellowBedData {
    fn default() -> Self {
        Self {
            part: YellowBedPart::Foot,
            occupied: false,
            facing: YellowBedFacing::North,
        }
    }
}
impl Value for YellowBedData {
    fn value(&self) -> usize {
        (self.part.value() * 8usize)
            + (self.occupied.value() * 4usize)
            + (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let part = YellowBedPart::from_value(val / 8usize).unwrap();
        val -= (part.value() - 0usize) * 8usize;
        let occupied = bool::from_value(val / 4usize).unwrap();
        val -= (occupied.value() - 0usize) * 4usize;
        let facing = YellowBedFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self {
            part,
            occupied,
            facing,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LimeBedData {
    pub occupied: bool,
    pub part: LimeBedPart,
    pub facing: LimeBedFacing,
}
impl LimeBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            occupied: bool::from_snake_case(map.get("occupied")?)?,
            part: LimeBedPart::from_snake_case(map.get("part")?)?,
            facing: LimeBedFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m.insert("part".to_string(), self.part.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for LimeBedData {
    fn default() -> Self {
        Self {
            occupied: false,
            part: LimeBedPart::Foot,
            facing: LimeBedFacing::North,
        }
    }
}
impl Value for LimeBedData {
    fn value(&self) -> usize {
        (self.occupied.value() * 8usize)
            + (self.part.value() * 4usize)
            + (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let occupied = bool::from_value(val / 8usize).unwrap();
        val -= (occupied.value() - 0usize) * 8usize;
        let part = LimeBedPart::from_value(val / 4usize).unwrap();
        val -= (part.value() - 0usize) * 4usize;
        let facing = LimeBedFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self {
            occupied,
            part,
            facing,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PinkBedData {
    pub part: PinkBedPart,
    pub occupied: bool,
    pub facing: PinkBedFacing,
}
impl PinkBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            part: PinkBedPart::from_snake_case(map.get("part")?)?,
            occupied: bool::from_snake_case(map.get("occupied")?)?,
            facing: PinkBedFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("part".to_string(), self.part.to_snake_case());
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for PinkBedData {
    fn default() -> Self {
        Self {
            part: PinkBedPart::Foot,
            occupied: false,
            facing: PinkBedFacing::North,
        }
    }
}
impl Value for PinkBedData {
    fn value(&self) -> usize {
        (self.part.value() * 8usize)
            + (self.occupied.value() * 4usize)
            + (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let part = PinkBedPart::from_value(val / 8usize).unwrap();
        val -= (part.value() - 0usize) * 8usize;
        let occupied = bool::from_value(val / 4usize).unwrap();
        val -= (occupied.value() - 0usize) * 4usize;
        let facing = PinkBedFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self {
            part,
            occupied,
            facing,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct GrayBedData {
    pub facing: GrayBedFacing,
    pub occupied: bool,
    pub part: GrayBedPart,
}
impl GrayBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: GrayBedFacing::from_snake_case(map.get("facing")?)?,
            occupied: bool::from_snake_case(map.get("occupied")?)?,
            part: GrayBedPart::from_snake_case(map.get("part")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m.insert("part".to_string(), self.part.to_snake_case());
        m
    }
}
impl Default for GrayBedData {
    fn default() -> Self {
        Self {
            facing: GrayBedFacing::North,
            occupied: false,
            part: GrayBedPart::Foot,
        }
    }
}
impl Value for GrayBedData {
    fn value(&self) -> usize {
        (self.facing.value() * 4usize)
            + (self.occupied.value() * 2usize)
            + (self.part.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let facing = GrayBedFacing::from_value(val / 4usize).unwrap();
        val -= (facing.value() - 0usize) * 4usize;
        let occupied = bool::from_value(val / 2usize).unwrap();
        val -= (occupied.value() - 0usize) * 2usize;
        let part = GrayBedPart::from_value(val / 1usize).unwrap();
        val -= (part.value() - 0usize) * 1usize;
        Some(Self {
            facing,
            occupied,
            part,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LightGrayBedData {
    pub facing: LightGrayBedFacing,
    pub occupied: bool,
    pub part: LightGrayBedPart,
}
impl LightGrayBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: LightGrayBedFacing::from_snake_case(map.get("facing")?)?,
            occupied: bool::from_snake_case(map.get("occupied")?)?,
            part: LightGrayBedPart::from_snake_case(map.get("part")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m.insert("part".to_string(), self.part.to_snake_case());
        m
    }
}
impl Default for LightGrayBedData {
    fn default() -> Self {
        Self {
            facing: LightGrayBedFacing::North,
            occupied: false,
            part: LightGrayBedPart::Foot,
        }
    }
}
impl Value for LightGrayBedData {
    fn value(&self) -> usize {
        (self.facing.value() * 4usize)
            + (self.occupied.value() * 2usize)
            + (self.part.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let facing = LightGrayBedFacing::from_value(val / 4usize).unwrap();
        val -= (facing.value() - 0usize) * 4usize;
        let occupied = bool::from_value(val / 2usize).unwrap();
        val -= (occupied.value() - 0usize) * 2usize;
        let part = LightGrayBedPart::from_value(val / 1usize).unwrap();
        val -= (part.value() - 0usize) * 1usize;
        Some(Self {
            facing,
            occupied,
            part,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CyanBedData {
    pub occupied: bool,
    pub part: CyanBedPart,
    pub facing: CyanBedFacing,
}
impl CyanBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            occupied: bool::from_snake_case(map.get("occupied")?)?,
            part: CyanBedPart::from_snake_case(map.get("part")?)?,
            facing: CyanBedFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m.insert("part".to_string(), self.part.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for CyanBedData {
    fn default() -> Self {
        Self {
            occupied: false,
            part: CyanBedPart::Foot,
            facing: CyanBedFacing::North,
        }
    }
}
impl Value for CyanBedData {
    fn value(&self) -> usize {
        (self.occupied.value() * 8usize)
            + (self.part.value() * 4usize)
            + (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let occupied = bool::from_value(val / 8usize).unwrap();
        val -= (occupied.value() - 0usize) * 8usize;
        let part = CyanBedPart::from_value(val / 4usize).unwrap();
        val -= (part.value() - 0usize) * 4usize;
        let facing = CyanBedFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self {
            occupied,
            part,
            facing,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PurpleBedData {
    pub part: PurpleBedPart,
    pub facing: PurpleBedFacing,
    pub occupied: bool,
}
impl PurpleBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            part: PurpleBedPart::from_snake_case(map.get("part")?)?,
            facing: PurpleBedFacing::from_snake_case(map.get("facing")?)?,
            occupied: bool::from_snake_case(map.get("occupied")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("part".to_string(), self.part.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m
    }
}
impl Default for PurpleBedData {
    fn default() -> Self {
        Self {
            part: PurpleBedPart::Foot,
            facing: PurpleBedFacing::North,
            occupied: false,
        }
    }
}
impl Value for PurpleBedData {
    fn value(&self) -> usize {
        (self.part.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.occupied.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let part = PurpleBedPart::from_value(val / 8usize).unwrap();
        val -= (part.value() - 0usize) * 8usize;
        let facing = PurpleBedFacing::from_value(val / 2usize).unwrap();
        val -= (facing.value() - 0usize) * 2usize;
        let occupied = bool::from_value(val / 1usize).unwrap();
        val -= (occupied.value() - 0usize) * 1usize;
        Some(Self {
            part,
            facing,
            occupied,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BlueBedData {
    pub facing: BlueBedFacing,
    pub occupied: bool,
    pub part: BlueBedPart,
}
impl BlueBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: BlueBedFacing::from_snake_case(map.get("facing")?)?,
            occupied: bool::from_snake_case(map.get("occupied")?)?,
            part: BlueBedPart::from_snake_case(map.get("part")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m.insert("part".to_string(), self.part.to_snake_case());
        m
    }
}
impl Default for BlueBedData {
    fn default() -> Self {
        Self {
            facing: BlueBedFacing::North,
            occupied: false,
            part: BlueBedPart::Foot,
        }
    }
}
impl Value for BlueBedData {
    fn value(&self) -> usize {
        (self.facing.value() * 4usize)
            + (self.occupied.value() * 2usize)
            + (self.part.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let facing = BlueBedFacing::from_value(val / 4usize).unwrap();
        val -= (facing.value() - 0usize) * 4usize;
        let occupied = bool::from_value(val / 2usize).unwrap();
        val -= (occupied.value() - 0usize) * 2usize;
        let part = BlueBedPart::from_value(val / 1usize).unwrap();
        val -= (part.value() - 0usize) * 1usize;
        Some(Self {
            facing,
            occupied,
            part,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BrownBedData {
    pub facing: BrownBedFacing,
    pub part: BrownBedPart,
    pub occupied: bool,
}
impl BrownBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: BrownBedFacing::from_snake_case(map.get("facing")?)?,
            part: BrownBedPart::from_snake_case(map.get("part")?)?,
            occupied: bool::from_snake_case(map.get("occupied")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("part".to_string(), self.part.to_snake_case());
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m
    }
}
impl Default for BrownBedData {
    fn default() -> Self {
        Self {
            facing: BrownBedFacing::North,
            part: BrownBedPart::Foot,
            occupied: false,
        }
    }
}
impl Value for BrownBedData {
    fn value(&self) -> usize {
        (self.facing.value() * 4usize)
            + (self.part.value() * 2usize)
            + (self.occupied.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let facing = BrownBedFacing::from_value(val / 4usize).unwrap();
        val -= (facing.value() - 0usize) * 4usize;
        let part = BrownBedPart::from_value(val / 2usize).unwrap();
        val -= (part.value() - 0usize) * 2usize;
        let occupied = bool::from_value(val / 1usize).unwrap();
        val -= (occupied.value() - 0usize) * 1usize;
        Some(Self {
            facing,
            part,
            occupied,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct GreenBedData {
    pub occupied: bool,
    pub facing: GreenBedFacing,
    pub part: GreenBedPart,
}
impl GreenBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            occupied: bool::from_snake_case(map.get("occupied")?)?,
            facing: GreenBedFacing::from_snake_case(map.get("facing")?)?,
            part: GreenBedPart::from_snake_case(map.get("part")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("part".to_string(), self.part.to_snake_case());
        m
    }
}
impl Default for GreenBedData {
    fn default() -> Self {
        Self {
            occupied: false,
            facing: GreenBedFacing::North,
            part: GreenBedPart::Foot,
        }
    }
}
impl Value for GreenBedData {
    fn value(&self) -> usize {
        (self.occupied.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.part.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let occupied = bool::from_value(val / 8usize).unwrap();
        val -= (occupied.value() - 0usize) * 8usize;
        let facing = GreenBedFacing::from_value(val / 2usize).unwrap();
        val -= (facing.value() - 0usize) * 2usize;
        let part = GreenBedPart::from_value(val / 1usize).unwrap();
        val -= (part.value() - 0usize) * 1usize;
        Some(Self {
            occupied,
            facing,
            part,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RedBedData {
    pub occupied: bool,
    pub part: RedBedPart,
    pub facing: RedBedFacing,
}
impl RedBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            occupied: bool::from_snake_case(map.get("occupied")?)?,
            part: RedBedPart::from_snake_case(map.get("part")?)?,
            facing: RedBedFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m.insert("part".to_string(), self.part.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for RedBedData {
    fn default() -> Self {
        Self {
            occupied: false,
            part: RedBedPart::Foot,
            facing: RedBedFacing::North,
        }
    }
}
impl Value for RedBedData {
    fn value(&self) -> usize {
        (self.occupied.value() * 8usize)
            + (self.part.value() * 4usize)
            + (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let occupied = bool::from_value(val / 8usize).unwrap();
        val -= (occupied.value() - 0usize) * 8usize;
        let part = RedBedPart::from_value(val / 4usize).unwrap();
        val -= (part.value() - 0usize) * 4usize;
        let facing = RedBedFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self {
            occupied,
            part,
            facing,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BlackBedData {
    pub occupied: bool,
    pub part: BlackBedPart,
    pub facing: BlackBedFacing,
}
impl BlackBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            occupied: bool::from_snake_case(map.get("occupied")?)?,
            part: BlackBedPart::from_snake_case(map.get("part")?)?,
            facing: BlackBedFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m.insert("part".to_string(), self.part.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for BlackBedData {
    fn default() -> Self {
        Self {
            occupied: false,
            part: BlackBedPart::Foot,
            facing: BlackBedFacing::North,
        }
    }
}
impl Value for BlackBedData {
    fn value(&self) -> usize {
        (self.occupied.value() * 8usize)
            + (self.part.value() * 4usize)
            + (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let occupied = bool::from_value(val / 8usize).unwrap();
        val -= (occupied.value() - 0usize) * 8usize;
        let part = BlackBedPart::from_value(val / 4usize).unwrap();
        val -= (part.value() - 0usize) * 4usize;
        let facing = BlackBedFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self {
            occupied,
            part,
            facing,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PoweredRailData {
    pub shape: PoweredRailShape,
    pub powered: bool,
}
impl PoweredRailData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            shape: PoweredRailShape::from_snake_case(map.get("shape")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Default for PoweredRailData {
    fn default() -> Self {
        Self {
            shape: PoweredRailShape::NorthSouth,
            powered: false,
        }
    }
}
impl Value for PoweredRailData {
    fn value(&self) -> usize {
        (self.shape.value() * 2usize) + (self.powered.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 12usize {
            return None;
        }
        let shape = PoweredRailShape::from_value(val / 2usize).unwrap();
        val -= (shape.value() - 0usize) * 2usize;
        let powered = bool::from_value(val / 1usize).unwrap();
        val -= (powered.value() - 0usize) * 1usize;
        Some(Self { shape, powered })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DetectorRailData {
    pub powered: bool,
    pub shape: DetectorRailShape,
}
impl DetectorRailData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
            shape: DetectorRailShape::from_snake_case(map.get("shape")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m
    }
}
impl Default for DetectorRailData {
    fn default() -> Self {
        Self {
            powered: false,
            shape: DetectorRailShape::NorthSouth,
        }
    }
}
impl Value for DetectorRailData {
    fn value(&self) -> usize {
        (self.powered.value() * 6usize) + (self.shape.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 12usize {
            return None;
        }
        let powered = bool::from_value(val / 6usize).unwrap();
        val -= (powered.value() - 0usize) * 6usize;
        let shape = DetectorRailShape::from_value(val / 1usize).unwrap();
        val -= (shape.value() - 0usize) * 1usize;
        Some(Self { powered, shape })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StickyPistonData {
    pub extended: bool,
    pub facing: StickyPistonFacing,
}
impl StickyPistonData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            extended: bool::from_snake_case(map.get("extended")?)?,
            facing: StickyPistonFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("extended".to_string(), self.extended.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for StickyPistonData {
    fn default() -> Self {
        Self {
            extended: false,
            facing: StickyPistonFacing::North,
        }
    }
}
impl Value for StickyPistonData {
    fn value(&self) -> usize {
        (self.extended.value() * 6usize) + (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 12usize {
            return None;
        }
        let extended = bool::from_value(val / 6usize).unwrap();
        val -= (extended.value() - 0usize) * 6usize;
        let facing = StickyPistonFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { extended, facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct TallSeagrassData {
    pub half: TallSeagrassHalf,
}
impl TallSeagrassData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            half: TallSeagrassHalf::from_snake_case(map.get("half")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("half".to_string(), self.half.to_snake_case());
        m
    }
}
impl Default for TallSeagrassData {
    fn default() -> Self {
        Self {
            half: TallSeagrassHalf::Lower,
        }
    }
}
impl Value for TallSeagrassData {
    fn value(&self) -> usize {
        (self.half.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let half = TallSeagrassHalf::from_value(val / 1usize).unwrap();
        val -= (half.value() - 0usize) * 1usize;
        Some(Self { half })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PistonData {
    pub facing: PistonFacing,
    pub extended: bool,
}
impl PistonData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: PistonFacing::from_snake_case(map.get("facing")?)?,
            extended: bool::from_snake_case(map.get("extended")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("extended".to_string(), self.extended.to_snake_case());
        m
    }
}
impl Default for PistonData {
    fn default() -> Self {
        Self {
            facing: PistonFacing::North,
            extended: false,
        }
    }
}
impl Value for PistonData {
    fn value(&self) -> usize {
        (self.facing.value() * 2usize) + (self.extended.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 12usize {
            return None;
        }
        let facing = PistonFacing::from_value(val / 2usize).unwrap();
        val -= (facing.value() - 0usize) * 2usize;
        let extended = bool::from_value(val / 1usize).unwrap();
        val -= (extended.value() - 0usize) * 1usize;
        Some(Self { facing, extended })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PistonHeadData {
    pub short: bool,
    pub ty: PistonHeadType,
    pub facing: PistonHeadFacing,
}
impl PistonHeadData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            short: bool::from_snake_case(map.get("short")?)?,
            ty: PistonHeadType::from_snake_case(map.get("type")?)?,
            facing: PistonHeadFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("short".to_string(), self.short.to_snake_case());
        m.insert("type".to_string(), self.ty.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for PistonHeadData {
    fn default() -> Self {
        Self {
            short: false,
            ty: PistonHeadType::Normal,
            facing: PistonHeadFacing::North,
        }
    }
}
impl Value for PistonHeadData {
    fn value(&self) -> usize {
        (self.short.value() * 12usize) + (self.ty.value() * 6usize) + (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 24usize {
            return None;
        }
        let short = bool::from_value(val / 12usize).unwrap();
        val -= (short.value() - 0usize) * 12usize;
        let ty = PistonHeadType::from_value(val / 6usize).unwrap();
        val -= (ty.value() - 0usize) * 6usize;
        let facing = PistonHeadFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { short, ty, facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct MovingPistonData {
    pub facing: MovingPistonFacing,
    pub ty: MovingPistonType,
}
impl MovingPistonData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: MovingPistonFacing::from_snake_case(map.get("facing")?)?,
            ty: MovingPistonType::from_snake_case(map.get("type")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("type".to_string(), self.ty.to_snake_case());
        m
    }
}
impl Default for MovingPistonData {
    fn default() -> Self {
        Self {
            facing: MovingPistonFacing::North,
            ty: MovingPistonType::Normal,
        }
    }
}
impl Value for MovingPistonData {
    fn value(&self) -> usize {
        (self.facing.value() * 2usize) + (self.ty.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 12usize {
            return None;
        }
        let facing = MovingPistonFacing::from_value(val / 2usize).unwrap();
        val -= (facing.value() - 0usize) * 2usize;
        let ty = MovingPistonType::from_value(val / 1usize).unwrap();
        val -= (ty.value() - 0usize) * 1usize;
        Some(Self { facing, ty })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct TntData {
    pub unstable: bool,
}
impl TntData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            unstable: bool::from_snake_case(map.get("unstable")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("unstable".to_string(), self.unstable.to_snake_case());
        m
    }
}
impl Default for TntData {
    fn default() -> Self {
        Self { unstable: false }
    }
}
impl Value for TntData {
    fn value(&self) -> usize {
        (self.unstable.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let unstable = bool::from_value(val / 1usize).unwrap();
        val -= (unstable.value() - 0usize) * 1usize;
        Some(Self { unstable })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct WallTorchData {
    pub facing: WallTorchFacing,
}
impl WallTorchData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: WallTorchFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for WallTorchData {
    fn default() -> Self {
        Self {
            facing: WallTorchFacing::North,
        }
    }
}
impl Value for WallTorchData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = WallTorchFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct FireData {
    pub west: bool,
    pub north: bool,
    pub east: bool,
    pub age: i32,
    pub up: bool,
    pub south: bool,
}
impl FireData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            west: bool::from_snake_case(map.get("west")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            age: i32::from_snake_case(map.get("age")?)?,
            up: bool::from_snake_case(map.get("up")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("age".to_string(), self.age.to_snake_case());
        m.insert("up".to_string(), self.up.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m
    }
}
impl Default for FireData {
    fn default() -> Self {
        Self {
            west: false,
            north: false,
            east: false,
            age: 0,
            up: false,
            south: false,
        }
    }
}
impl Value for FireData {
    fn value(&self) -> usize {
        (self.west.value() * 256usize)
            + (self.north.value() * 128usize)
            + (self.east.value() * 64usize)
            + (self.age.value() * 4usize)
            + (self.up.value() * 2usize)
            + (self.south.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 512usize {
            return None;
        }
        let west = bool::from_value(val / 256usize).unwrap();
        val -= (west.value() - 0usize) * 256usize;
        let north = bool::from_value(val / 128usize).unwrap();
        val -= (north.value() - 0usize) * 128usize;
        let east = bool::from_value(val / 64usize).unwrap();
        val -= (east.value() - 0usize) * 64usize;
        let age = i32::from_value(val / 4usize).unwrap();
        val -= (age.value() - 0usize) * 4usize;
        let up = bool::from_value(val / 2usize).unwrap();
        val -= (up.value() - 0usize) * 2usize;
        let south = bool::from_value(val / 1usize).unwrap();
        val -= (south.value() - 0usize) * 1usize;
        Some(Self {
            west,
            north,
            east,
            age,
            up,
            south,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OakStairsData {
    pub half: OakStairsHalf,
    pub shape: OakStairsShape,
    pub facing: OakStairsFacing,
    pub waterlogged: bool,
}
impl OakStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            half: OakStairsHalf::from_snake_case(map.get("half")?)?,
            shape: OakStairsShape::from_snake_case(map.get("shape")?)?,
            facing: OakStairsFacing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for OakStairsData {
    fn default() -> Self {
        Self {
            half: OakStairsHalf::Bottom,
            shape: OakStairsShape::Straight,
            facing: OakStairsFacing::North,
            waterlogged: false,
        }
    }
}
impl Value for OakStairsData {
    fn value(&self) -> usize {
        (self.half.value() * 40usize)
            + (self.shape.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 80usize {
            return None;
        }
        let half = OakStairsHalf::from_value(val / 40usize).unwrap();
        val -= (half.value() - 0usize) * 40usize;
        let shape = OakStairsShape::from_value(val / 8usize).unwrap();
        val -= (shape.value() - 0usize) * 8usize;
        let facing = OakStairsFacing::from_value(val / 2usize).unwrap();
        val -= (facing.value() - 0usize) * 2usize;
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self {
            half,
            shape,
            facing,
            waterlogged,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ChestData {
    pub ty: ChestType,
    pub waterlogged: bool,
    pub facing: ChestFacing,
}
impl ChestData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            ty: ChestType::from_snake_case(map.get("type")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            facing: ChestFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("type".to_string(), self.ty.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for ChestData {
    fn default() -> Self {
        Self {
            ty: ChestType::Single,
            waterlogged: false,
            facing: ChestFacing::North,
        }
    }
}
impl Value for ChestData {
    fn value(&self) -> usize {
        (self.ty.value() * 8usize)
            + (self.waterlogged.value() * 4usize)
            + (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 24usize {
            return None;
        }
        let ty = ChestType::from_value(val / 8usize).unwrap();
        val -= (ty.value() - 0usize) * 8usize;
        let waterlogged = bool::from_value(val / 4usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 4usize;
        let facing = ChestFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self {
            ty,
            waterlogged,
            facing,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RedstoneWireData {
    pub west: RedstoneWireWest,
    pub north: RedstoneWireNorth,
    pub east: RedstoneWireEast,
    pub south: RedstoneWireSouth,
    pub power: i32,
}
impl RedstoneWireData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            west: RedstoneWireWest::from_snake_case(map.get("west")?)?,
            north: RedstoneWireNorth::from_snake_case(map.get("north")?)?,
            east: RedstoneWireEast::from_snake_case(map.get("east")?)?,
            south: RedstoneWireSouth::from_snake_case(map.get("south")?)?,
            power: i32::from_snake_case(map.get("power")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("power".to_string(), self.power.to_snake_case());
        m
    }
}
impl Default for RedstoneWireData {
    fn default() -> Self {
        Self {
            west: RedstoneWireWest::None,
            north: RedstoneWireNorth::None,
            east: RedstoneWireEast::None,
            south: RedstoneWireSouth::None,
            power: 0,
        }
    }
}
impl Value for RedstoneWireData {
    fn value(&self) -> usize {
        (self.west.value() * 432usize)
            + (self.north.value() * 144usize)
            + (self.east.value() * 48usize)
            + (self.south.value() * 16usize)
            + (self.power.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 1296usize {
            return None;
        }
        let west = RedstoneWireWest::from_value(val / 432usize).unwrap();
        val -= (west.value() - 0usize) * 432usize;
        let north = RedstoneWireNorth::from_value(val / 144usize).unwrap();
        val -= (north.value() - 0usize) * 144usize;
        let east = RedstoneWireEast::from_value(val / 48usize).unwrap();
        val -= (east.value() - 0usize) * 48usize;
        let south = RedstoneWireSouth::from_value(val / 16usize).unwrap();
        val -= (south.value() - 0usize) * 16usize;
        let power = i32::from_value(val / 1usize).unwrap();
        val -= (power.value() - 0usize) * 1usize;
        Some(Self {
            west,
            north,
            east,
            south,
            power,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct WheatData {
    pub age: i32,
}
impl WheatData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            age: i32::from_snake_case(map.get("age")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("age".to_string(), self.age.to_snake_case());
        m
    }
}
impl Default for WheatData {
    fn default() -> Self {
        Self { age: 0 }
    }
}
impl Value for WheatData {
    fn value(&self) -> usize {
        (self.age.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 8usize {
            return None;
        }
        let age = i32::from_value(val / 1usize).unwrap();
        val -= (age.value() - 0usize) * 1usize;
        Some(Self { age })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct FarmlandData {
    pub moisture: i32,
}
impl FarmlandData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            moisture: i32::from_snake_case(map.get("moisture")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("moisture".to_string(), self.moisture.to_snake_case());
        m
    }
}
impl Default for FarmlandData {
    fn default() -> Self {
        Self { moisture: 0 }
    }
}
impl Value for FarmlandData {
    fn value(&self) -> usize {
        (self.moisture.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 8usize {
            return None;
        }
        let moisture = i32::from_value(val / 1usize).unwrap();
        val -= (moisture.value() - 0usize) * 1usize;
        Some(Self { moisture })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct FurnaceData {
    pub facing: FurnaceFacing,
    pub lit: bool,
}
impl FurnaceData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: FurnaceFacing::from_snake_case(map.get("facing")?)?,
            lit: bool::from_snake_case(map.get("lit")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("lit".to_string(), self.lit.to_snake_case());
        m
    }
}
impl Default for FurnaceData {
    fn default() -> Self {
        Self {
            facing: FurnaceFacing::North,
            lit: false,
        }
    }
}
impl Value for FurnaceData {
    fn value(&self) -> usize {
        (self.facing.value() * 2usize) + (self.lit.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 8usize {
            return None;
        }
        let facing = FurnaceFacing::from_value(val / 2usize).unwrap();
        val -= (facing.value() - 0usize) * 2usize;
        let lit = bool::from_value(val / 1usize).unwrap();
        val -= (lit.value() - 0usize) * 1usize;
        Some(Self { facing, lit })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SignData {
    pub rotation: i32,
    pub waterlogged: bool,
}
impl SignData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for SignData {
    fn default() -> Self {
        Self {
            rotation: 0,
            waterlogged: false,
        }
    }
}
impl Value for SignData {
    fn value(&self) -> usize {
        (self.rotation.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 32usize {
            return None;
        }
        let rotation = i32::from_value(val / 2usize).unwrap();
        val -= (rotation.value() - 0usize) * 2usize;
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self {
            rotation,
            waterlogged,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OakDoorData {
    pub half: OakDoorHalf,
    pub powered: bool,
    pub facing: OakDoorFacing,
    pub open: bool,
    pub hinge: OakDoorHinge,
}
impl OakDoorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            half: OakDoorHalf::from_snake_case(map.get("half")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            facing: OakDoorFacing::from_snake_case(map.get("facing")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
            hinge: OakDoorHinge::from_snake_case(map.get("hinge")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("hinge".to_string(), self.hinge.to_snake_case());
        m
    }
}
impl Default for OakDoorData {
    fn default() -> Self {
        Self {
            half: OakDoorHalf::Lower,
            powered: false,
            facing: OakDoorFacing::North,
            open: false,
            hinge: OakDoorHinge::Left,
        }
    }
}
impl Value for OakDoorData {
    fn value(&self) -> usize {
        (self.half.value() * 32usize)
            + (self.powered.value() * 16usize)
            + (self.facing.value() * 4usize)
            + (self.open.value() * 2usize)
            + (self.hinge.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 64usize {
            return None;
        }
        let half = OakDoorHalf::from_value(val / 32usize).unwrap();
        val -= (half.value() - 0usize) * 32usize;
        let powered = bool::from_value(val / 16usize).unwrap();
        val -= (powered.value() - 0usize) * 16usize;
        let facing = OakDoorFacing::from_value(val / 4usize).unwrap();
        val -= (facing.value() - 0usize) * 4usize;
        let open = bool::from_value(val / 2usize).unwrap();
        val -= (open.value() - 0usize) * 2usize;
        let hinge = OakDoorHinge::from_value(val / 1usize).unwrap();
        val -= (hinge.value() - 0usize) * 1usize;
        Some(Self {
            half,
            powered,
            facing,
            open,
            hinge,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LadderData {
    pub facing: LadderFacing,
    pub waterlogged: bool,
}
impl LadderData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: LadderFacing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for LadderData {
    fn default() -> Self {
        Self {
            facing: LadderFacing::North,
            waterlogged: false,
        }
    }
}
impl Value for LadderData {
    fn value(&self) -> usize {
        (self.facing.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 8usize {
            return None;
        }
        let facing = LadderFacing::from_value(val / 2usize).unwrap();
        val -= (facing.value() - 0usize) * 2usize;
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self {
            facing,
            waterlogged,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RailData {
    pub shape: RailShape,
}
impl RailData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            shape: RailShape::from_snake_case(map.get("shape")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m
    }
}
impl Default for RailData {
    fn default() -> Self {
        Self {
            shape: RailShape::NorthSouth,
        }
    }
}
impl Value for RailData {
    fn value(&self) -> usize {
        (self.shape.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 10usize {
            return None;
        }
        let shape = RailShape::from_value(val / 1usize).unwrap();
        val -= (shape.value() - 0usize) * 1usize;
        Some(Self { shape })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CobblestoneStairsData {
    pub waterlogged: bool,
    pub facing: CobblestoneStairsFacing,
    pub half: CobblestoneStairsHalf,
    pub shape: CobblestoneStairsShape,
}
impl CobblestoneStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            facing: CobblestoneStairsFacing::from_snake_case(map.get("facing")?)?,
            half: CobblestoneStairsHalf::from_snake_case(map.get("half")?)?,
            shape: CobblestoneStairsShape::from_snake_case(map.get("shape")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m
    }
}
impl Default for CobblestoneStairsData {
    fn default() -> Self {
        Self {
            waterlogged: false,
            facing: CobblestoneStairsFacing::North,
            half: CobblestoneStairsHalf::Bottom,
            shape: CobblestoneStairsShape::Straight,
        }
    }
}
impl Value for CobblestoneStairsData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 40usize)
            + (self.facing.value() * 10usize)
            + (self.half.value() * 5usize)
            + (self.shape.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 80usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 40usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 40usize;
        let facing = CobblestoneStairsFacing::from_value(val / 10usize).unwrap();
        val -= (facing.value() - 0usize) * 10usize;
        let half = CobblestoneStairsHalf::from_value(val / 5usize).unwrap();
        val -= (half.value() - 0usize) * 5usize;
        let shape = CobblestoneStairsShape::from_value(val / 1usize).unwrap();
        val -= (shape.value() - 0usize) * 1usize;
        Some(Self {
            waterlogged,
            facing,
            half,
            shape,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct WallSignData {
    pub waterlogged: bool,
    pub facing: WallSignFacing,
}
impl WallSignData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            facing: WallSignFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for WallSignData {
    fn default() -> Self {
        Self {
            waterlogged: false,
            facing: WallSignFacing::North,
        }
    }
}
impl Value for WallSignData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 4usize) + (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 8usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 4usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 4usize;
        let facing = WallSignFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self {
            waterlogged,
            facing,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LeverData {
    pub facing: LeverFacing,
    pub face: LeverFace,
    pub powered: bool,
}
impl LeverData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: LeverFacing::from_snake_case(map.get("facing")?)?,
            face: LeverFace::from_snake_case(map.get("face")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("face".to_string(), self.face.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Default for LeverData {
    fn default() -> Self {
        Self {
            facing: LeverFacing::North,
            face: LeverFace::Wall,
            powered: false,
        }
    }
}
impl Value for LeverData {
    fn value(&self) -> usize {
        (self.facing.value() * 6usize)
            + (self.face.value() * 2usize)
            + (self.powered.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 24usize {
            return None;
        }
        let facing = LeverFacing::from_value(val / 6usize).unwrap();
        val -= (facing.value() - 0usize) * 6usize;
        let face = LeverFace::from_value(val / 2usize).unwrap();
        val -= (face.value() - 0usize) * 2usize;
        let powered = bool::from_value(val / 1usize).unwrap();
        val -= (powered.value() - 0usize) * 1usize;
        Some(Self {
            facing,
            face,
            powered,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StonePressurePlateData {
    pub powered: bool,
}
impl StonePressurePlateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Default for StonePressurePlateData {
    fn default() -> Self {
        Self { powered: false }
    }
}
impl Value for StonePressurePlateData {
    fn value(&self) -> usize {
        (self.powered.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let powered = bool::from_value(val / 1usize).unwrap();
        val -= (powered.value() - 0usize) * 1usize;
        Some(Self { powered })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct IronDoorData {
    pub half: IronDoorHalf,
    pub open: bool,
    pub facing: IronDoorFacing,
    pub hinge: IronDoorHinge,
    pub powered: bool,
}
impl IronDoorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            half: IronDoorHalf::from_snake_case(map.get("half")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
            facing: IronDoorFacing::from_snake_case(map.get("facing")?)?,
            hinge: IronDoorHinge::from_snake_case(map.get("hinge")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("hinge".to_string(), self.hinge.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Default for IronDoorData {
    fn default() -> Self {
        Self {
            half: IronDoorHalf::Lower,
            open: false,
            facing: IronDoorFacing::North,
            hinge: IronDoorHinge::Left,
            powered: false,
        }
    }
}
impl Value for IronDoorData {
    fn value(&self) -> usize {
        (self.half.value() * 32usize)
            + (self.open.value() * 16usize)
            + (self.facing.value() * 4usize)
            + (self.hinge.value() * 2usize)
            + (self.powered.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 64usize {
            return None;
        }
        let half = IronDoorHalf::from_value(val / 32usize).unwrap();
        val -= (half.value() - 0usize) * 32usize;
        let open = bool::from_value(val / 16usize).unwrap();
        val -= (open.value() - 0usize) * 16usize;
        let facing = IronDoorFacing::from_value(val / 4usize).unwrap();
        val -= (facing.value() - 0usize) * 4usize;
        let hinge = IronDoorHinge::from_value(val / 2usize).unwrap();
        val -= (hinge.value() - 0usize) * 2usize;
        let powered = bool::from_value(val / 1usize).unwrap();
        val -= (powered.value() - 0usize) * 1usize;
        Some(Self {
            half,
            open,
            facing,
            hinge,
            powered,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OakPressurePlateData {
    pub powered: bool,
}
impl OakPressurePlateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Default for OakPressurePlateData {
    fn default() -> Self {
        Self { powered: false }
    }
}
impl Value for OakPressurePlateData {
    fn value(&self) -> usize {
        (self.powered.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let powered = bool::from_value(val / 1usize).unwrap();
        val -= (powered.value() - 0usize) * 1usize;
        Some(Self { powered })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SprucePressurePlateData {
    pub powered: bool,
}
impl SprucePressurePlateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Default for SprucePressurePlateData {
    fn default() -> Self {
        Self { powered: false }
    }
}
impl Value for SprucePressurePlateData {
    fn value(&self) -> usize {
        (self.powered.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let powered = bool::from_value(val / 1usize).unwrap();
        val -= (powered.value() - 0usize) * 1usize;
        Some(Self { powered })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BirchPressurePlateData {
    pub powered: bool,
}
impl BirchPressurePlateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Default for BirchPressurePlateData {
    fn default() -> Self {
        Self { powered: false }
    }
}
impl Value for BirchPressurePlateData {
    fn value(&self) -> usize {
        (self.powered.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let powered = bool::from_value(val / 1usize).unwrap();
        val -= (powered.value() - 0usize) * 1usize;
        Some(Self { powered })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct JunglePressurePlateData {
    pub powered: bool,
}
impl JunglePressurePlateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Default for JunglePressurePlateData {
    fn default() -> Self {
        Self { powered: false }
    }
}
impl Value for JunglePressurePlateData {
    fn value(&self) -> usize {
        (self.powered.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let powered = bool::from_value(val / 1usize).unwrap();
        val -= (powered.value() - 0usize) * 1usize;
        Some(Self { powered })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AcaciaPressurePlateData {
    pub powered: bool,
}
impl AcaciaPressurePlateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Default for AcaciaPressurePlateData {
    fn default() -> Self {
        Self { powered: false }
    }
}
impl Value for AcaciaPressurePlateData {
    fn value(&self) -> usize {
        (self.powered.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let powered = bool::from_value(val / 1usize).unwrap();
        val -= (powered.value() - 0usize) * 1usize;
        Some(Self { powered })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DarkOakPressurePlateData {
    pub powered: bool,
}
impl DarkOakPressurePlateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Default for DarkOakPressurePlateData {
    fn default() -> Self {
        Self { powered: false }
    }
}
impl Value for DarkOakPressurePlateData {
    fn value(&self) -> usize {
        (self.powered.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let powered = bool::from_value(val / 1usize).unwrap();
        val -= (powered.value() - 0usize) * 1usize;
        Some(Self { powered })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RedstoneOreData {
    pub lit: bool,
}
impl RedstoneOreData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            lit: bool::from_snake_case(map.get("lit")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("lit".to_string(), self.lit.to_snake_case());
        m
    }
}
impl Default for RedstoneOreData {
    fn default() -> Self {
        Self { lit: false }
    }
}
impl Value for RedstoneOreData {
    fn value(&self) -> usize {
        (self.lit.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let lit = bool::from_value(val / 1usize).unwrap();
        val -= (lit.value() - 0usize) * 1usize;
        Some(Self { lit })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RedstoneTorchData {
    pub lit: bool,
}
impl RedstoneTorchData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            lit: bool::from_snake_case(map.get("lit")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("lit".to_string(), self.lit.to_snake_case());
        m
    }
}
impl Default for RedstoneTorchData {
    fn default() -> Self {
        Self { lit: true }
    }
}
impl Value for RedstoneTorchData {
    fn value(&self) -> usize {
        (self.lit.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let lit = bool::from_value(val / 1usize).unwrap();
        val -= (lit.value() - 0usize) * 1usize;
        Some(Self { lit })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RedstoneWallTorchData {
    pub facing: RedstoneWallTorchFacing,
    pub lit: bool,
}
impl RedstoneWallTorchData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: RedstoneWallTorchFacing::from_snake_case(map.get("facing")?)?,
            lit: bool::from_snake_case(map.get("lit")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("lit".to_string(), self.lit.to_snake_case());
        m
    }
}
impl Default for RedstoneWallTorchData {
    fn default() -> Self {
        Self {
            facing: RedstoneWallTorchFacing::North,
            lit: true,
        }
    }
}
impl Value for RedstoneWallTorchData {
    fn value(&self) -> usize {
        (self.facing.value() * 2usize) + (self.lit.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 8usize {
            return None;
        }
        let facing = RedstoneWallTorchFacing::from_value(val / 2usize).unwrap();
        val -= (facing.value() - 0usize) * 2usize;
        let lit = bool::from_value(val / 1usize).unwrap();
        val -= (lit.value() - 0usize) * 1usize;
        Some(Self { facing, lit })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StoneButtonData {
    pub powered: bool,
    pub face: StoneButtonFace,
    pub facing: StoneButtonFacing,
}
impl StoneButtonData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
            face: StoneButtonFace::from_snake_case(map.get("face")?)?,
            facing: StoneButtonFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("face".to_string(), self.face.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for StoneButtonData {
    fn default() -> Self {
        Self {
            powered: false,
            face: StoneButtonFace::Wall,
            facing: StoneButtonFacing::North,
        }
    }
}
impl Value for StoneButtonData {
    fn value(&self) -> usize {
        (self.powered.value() * 12usize)
            + (self.face.value() * 4usize)
            + (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 24usize {
            return None;
        }
        let powered = bool::from_value(val / 12usize).unwrap();
        val -= (powered.value() - 0usize) * 12usize;
        let face = StoneButtonFace::from_value(val / 4usize).unwrap();
        val -= (face.value() - 0usize) * 4usize;
        let facing = StoneButtonFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self {
            powered,
            face,
            facing,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SnowData {
    pub layers: i32,
}
impl SnowData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            layers: i32::from_snake_case(map.get("layers")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("layers".to_string(), self.layers.to_snake_case());
        m
    }
}
impl Default for SnowData {
    fn default() -> Self {
        Self { layers: 1 }
    }
}
impl Value for SnowData {
    fn value(&self) -> usize {
        ((self.layers.value() - 1) * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 8usize {
            return None;
        }
        let layers = i32::from_value(val / 1usize).unwrap() + 1i32;
        val -= (layers.value() - 1usize) * 1usize;
        Some(Self { layers })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CactusData {
    pub age: i32,
}
impl CactusData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            age: i32::from_snake_case(map.get("age")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("age".to_string(), self.age.to_snake_case());
        m
    }
}
impl Default for CactusData {
    fn default() -> Self {
        Self { age: 0 }
    }
}
impl Value for CactusData {
    fn value(&self) -> usize {
        (self.age.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let age = i32::from_value(val / 1usize).unwrap();
        val -= (age.value() - 0usize) * 1usize;
        Some(Self { age })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SugarCaneData {
    pub age: i32,
}
impl SugarCaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            age: i32::from_snake_case(map.get("age")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("age".to_string(), self.age.to_snake_case());
        m
    }
}
impl Default for SugarCaneData {
    fn default() -> Self {
        Self { age: 0 }
    }
}
impl Value for SugarCaneData {
    fn value(&self) -> usize {
        (self.age.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let age = i32::from_value(val / 1usize).unwrap();
        val -= (age.value() - 0usize) * 1usize;
        Some(Self { age })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct JukeboxData {
    pub has_record: bool,
}
impl JukeboxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            has_record: bool::from_snake_case(map.get("has_record")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("has_record".to_string(), self.has_record.to_snake_case());
        m
    }
}
impl Default for JukeboxData {
    fn default() -> Self {
        Self { has_record: false }
    }
}
impl Value for JukeboxData {
    fn value(&self) -> usize {
        (self.has_record.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let has_record = bool::from_value(val / 1usize).unwrap();
        val -= (has_record.value() - 0usize) * 1usize;
        Some(Self { has_record })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OakFenceData {
    pub east: bool,
    pub west: bool,
    pub waterlogged: bool,
    pub south: bool,
    pub north: bool,
}
impl OakFenceData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            east: bool::from_snake_case(map.get("east")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m
    }
}
impl Default for OakFenceData {
    fn default() -> Self {
        Self {
            east: false,
            west: false,
            waterlogged: false,
            south: false,
            north: false,
        }
    }
}
impl Value for OakFenceData {
    fn value(&self) -> usize {
        (self.east.value() * 16usize)
            + (self.west.value() * 8usize)
            + (self.waterlogged.value() * 4usize)
            + (self.south.value() * 2usize)
            + (self.north.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 32usize {
            return None;
        }
        let east = bool::from_value(val / 16usize).unwrap();
        val -= (east.value() - 0usize) * 16usize;
        let west = bool::from_value(val / 8usize).unwrap();
        val -= (west.value() - 0usize) * 8usize;
        let waterlogged = bool::from_value(val / 4usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 4usize;
        let south = bool::from_value(val / 2usize).unwrap();
        val -= (south.value() - 0usize) * 2usize;
        let north = bool::from_value(val / 1usize).unwrap();
        val -= (north.value() - 0usize) * 1usize;
        Some(Self {
            east,
            west,
            waterlogged,
            south,
            north,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct NetherPortalData {
    pub axis: NetherPortalAxis,
}
impl NetherPortalData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: NetherPortalAxis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Default for NetherPortalData {
    fn default() -> Self {
        Self {
            axis: NetherPortalAxis::X,
        }
    }
}
impl Value for NetherPortalData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let axis = NetherPortalAxis::from_value(val / 1usize).unwrap();
        val -= (axis.value() - 0usize) * 1usize;
        Some(Self { axis })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CarvedPumpkinData {
    pub facing: CarvedPumpkinFacing,
}
impl CarvedPumpkinData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: CarvedPumpkinFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for CarvedPumpkinData {
    fn default() -> Self {
        Self {
            facing: CarvedPumpkinFacing::North,
        }
    }
}
impl Value for CarvedPumpkinData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = CarvedPumpkinFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct JackOLanternData {
    pub facing: JackOLanternFacing,
}
impl JackOLanternData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: JackOLanternFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for JackOLanternData {
    fn default() -> Self {
        Self {
            facing: JackOLanternFacing::North,
        }
    }
}
impl Value for JackOLanternData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = JackOLanternFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CakeData {
    pub bites: i32,
}
impl CakeData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            bites: i32::from_snake_case(map.get("bites")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("bites".to_string(), self.bites.to_snake_case());
        m
    }
}
impl Default for CakeData {
    fn default() -> Self {
        Self { bites: 0 }
    }
}
impl Value for CakeData {
    fn value(&self) -> usize {
        (self.bites.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 7usize {
            return None;
        }
        let bites = i32::from_value(val / 1usize).unwrap();
        val -= (bites.value() - 0usize) * 1usize;
        Some(Self { bites })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RepeaterData {
    pub powered: bool,
    pub facing: RepeaterFacing,
    pub locked: bool,
    pub delay: i32,
}
impl RepeaterData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
            facing: RepeaterFacing::from_snake_case(map.get("facing")?)?,
            locked: bool::from_snake_case(map.get("locked")?)?,
            delay: i32::from_snake_case(map.get("delay")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("locked".to_string(), self.locked.to_snake_case());
        m.insert("delay".to_string(), self.delay.to_snake_case());
        m
    }
}
impl Default for RepeaterData {
    fn default() -> Self {
        Self {
            powered: false,
            facing: RepeaterFacing::North,
            locked: false,
            delay: 1,
        }
    }
}
impl Value for RepeaterData {
    fn value(&self) -> usize {
        (self.powered.value() * 32usize)
            + (self.facing.value() * 8usize)
            + (self.locked.value() * 4usize)
            + ((self.delay.value() - 1) * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 64usize {
            return None;
        }
        let powered = bool::from_value(val / 32usize).unwrap();
        val -= (powered.value() - 0usize) * 32usize;
        let facing = RepeaterFacing::from_value(val / 8usize).unwrap();
        val -= (facing.value() - 0usize) * 8usize;
        let locked = bool::from_value(val / 4usize).unwrap();
        val -= (locked.value() - 0usize) * 4usize;
        let delay = i32::from_value(val / 1usize).unwrap() + 1i32;
        val -= (delay.value() - 1usize) * 1usize;
        Some(Self {
            powered,
            facing,
            locked,
            delay,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OakTrapdoorData {
    pub open: bool,
    pub waterlogged: bool,
    pub half: OakTrapdoorHalf,
    pub facing: OakTrapdoorFacing,
    pub powered: bool,
}
impl OakTrapdoorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            open: bool::from_snake_case(map.get("open")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            half: OakTrapdoorHalf::from_snake_case(map.get("half")?)?,
            facing: OakTrapdoorFacing::from_snake_case(map.get("facing")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Default for OakTrapdoorData {
    fn default() -> Self {
        Self {
            open: false,
            waterlogged: false,
            half: OakTrapdoorHalf::Bottom,
            facing: OakTrapdoorFacing::North,
            powered: false,
        }
    }
}
impl Value for OakTrapdoorData {
    fn value(&self) -> usize {
        (self.open.value() * 32usize)
            + (self.waterlogged.value() * 16usize)
            + (self.half.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.powered.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 64usize {
            return None;
        }
        let open = bool::from_value(val / 32usize).unwrap();
        val -= (open.value() - 0usize) * 32usize;
        let waterlogged = bool::from_value(val / 16usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 16usize;
        let half = OakTrapdoorHalf::from_value(val / 8usize).unwrap();
        val -= (half.value() - 0usize) * 8usize;
        let facing = OakTrapdoorFacing::from_value(val / 2usize).unwrap();
        val -= (facing.value() - 0usize) * 2usize;
        let powered = bool::from_value(val / 1usize).unwrap();
        val -= (powered.value() - 0usize) * 1usize;
        Some(Self {
            open,
            waterlogged,
            half,
            facing,
            powered,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SpruceTrapdoorData {
    pub facing: SpruceTrapdoorFacing,
    pub powered: bool,
    pub half: SpruceTrapdoorHalf,
    pub open: bool,
    pub waterlogged: bool,
}
impl SpruceTrapdoorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: SpruceTrapdoorFacing::from_snake_case(map.get("facing")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            half: SpruceTrapdoorHalf::from_snake_case(map.get("half")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for SpruceTrapdoorData {
    fn default() -> Self {
        Self {
            facing: SpruceTrapdoorFacing::North,
            powered: false,
            half: SpruceTrapdoorHalf::Bottom,
            open: false,
            waterlogged: false,
        }
    }
}
impl Value for SpruceTrapdoorData {
    fn value(&self) -> usize {
        (self.facing.value() * 16usize)
            + (self.powered.value() * 8usize)
            + (self.half.value() * 4usize)
            + (self.open.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 64usize {
            return None;
        }
        let facing = SpruceTrapdoorFacing::from_value(val / 16usize).unwrap();
        val -= (facing.value() - 0usize) * 16usize;
        let powered = bool::from_value(val / 8usize).unwrap();
        val -= (powered.value() - 0usize) * 8usize;
        let half = SpruceTrapdoorHalf::from_value(val / 4usize).unwrap();
        val -= (half.value() - 0usize) * 4usize;
        let open = bool::from_value(val / 2usize).unwrap();
        val -= (open.value() - 0usize) * 2usize;
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self {
            facing,
            powered,
            half,
            open,
            waterlogged,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BirchTrapdoorData {
    pub waterlogged: bool,
    pub half: BirchTrapdoorHalf,
    pub powered: bool,
    pub facing: BirchTrapdoorFacing,
    pub open: bool,
}
impl BirchTrapdoorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            half: BirchTrapdoorHalf::from_snake_case(map.get("half")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            facing: BirchTrapdoorFacing::from_snake_case(map.get("facing")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m
    }
}
impl Default for BirchTrapdoorData {
    fn default() -> Self {
        Self {
            waterlogged: false,
            half: BirchTrapdoorHalf::Bottom,
            powered: false,
            facing: BirchTrapdoorFacing::North,
            open: false,
        }
    }
}
impl Value for BirchTrapdoorData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 32usize)
            + (self.half.value() * 16usize)
            + (self.powered.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.open.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 64usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 32usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 32usize;
        let half = BirchTrapdoorHalf::from_value(val / 16usize).unwrap();
        val -= (half.value() - 0usize) * 16usize;
        let powered = bool::from_value(val / 8usize).unwrap();
        val -= (powered.value() - 0usize) * 8usize;
        let facing = BirchTrapdoorFacing::from_value(val / 2usize).unwrap();
        val -= (facing.value() - 0usize) * 2usize;
        let open = bool::from_value(val / 1usize).unwrap();
        val -= (open.value() - 0usize) * 1usize;
        Some(Self {
            waterlogged,
            half,
            powered,
            facing,
            open,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct JungleTrapdoorData {
    pub powered: bool,
    pub open: bool,
    pub waterlogged: bool,
    pub facing: JungleTrapdoorFacing,
    pub half: JungleTrapdoorHalf,
}
impl JungleTrapdoorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            facing: JungleTrapdoorFacing::from_snake_case(map.get("facing")?)?,
            half: JungleTrapdoorHalf::from_snake_case(map.get("half")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m
    }
}
impl Default for JungleTrapdoorData {
    fn default() -> Self {
        Self {
            powered: false,
            open: false,
            waterlogged: false,
            facing: JungleTrapdoorFacing::North,
            half: JungleTrapdoorHalf::Bottom,
        }
    }
}
impl Value for JungleTrapdoorData {
    fn value(&self) -> usize {
        (self.powered.value() * 32usize)
            + (self.open.value() * 16usize)
            + (self.waterlogged.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.half.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 64usize {
            return None;
        }
        let powered = bool::from_value(val / 32usize).unwrap();
        val -= (powered.value() - 0usize) * 32usize;
        let open = bool::from_value(val / 16usize).unwrap();
        val -= (open.value() - 0usize) * 16usize;
        let waterlogged = bool::from_value(val / 8usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 8usize;
        let facing = JungleTrapdoorFacing::from_value(val / 2usize).unwrap();
        val -= (facing.value() - 0usize) * 2usize;
        let half = JungleTrapdoorHalf::from_value(val / 1usize).unwrap();
        val -= (half.value() - 0usize) * 1usize;
        Some(Self {
            powered,
            open,
            waterlogged,
            facing,
            half,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AcaciaTrapdoorData {
    pub waterlogged: bool,
    pub open: bool,
    pub half: AcaciaTrapdoorHalf,
    pub facing: AcaciaTrapdoorFacing,
    pub powered: bool,
}
impl AcaciaTrapdoorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
            half: AcaciaTrapdoorHalf::from_snake_case(map.get("half")?)?,
            facing: AcaciaTrapdoorFacing::from_snake_case(map.get("facing")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Default for AcaciaTrapdoorData {
    fn default() -> Self {
        Self {
            waterlogged: false,
            open: false,
            half: AcaciaTrapdoorHalf::Bottom,
            facing: AcaciaTrapdoorFacing::North,
            powered: false,
        }
    }
}
impl Value for AcaciaTrapdoorData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 32usize)
            + (self.open.value() * 16usize)
            + (self.half.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.powered.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 64usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 32usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 32usize;
        let open = bool::from_value(val / 16usize).unwrap();
        val -= (open.value() - 0usize) * 16usize;
        let half = AcaciaTrapdoorHalf::from_value(val / 8usize).unwrap();
        val -= (half.value() - 0usize) * 8usize;
        let facing = AcaciaTrapdoorFacing::from_value(val / 2usize).unwrap();
        val -= (facing.value() - 0usize) * 2usize;
        let powered = bool::from_value(val / 1usize).unwrap();
        val -= (powered.value() - 0usize) * 1usize;
        Some(Self {
            waterlogged,
            open,
            half,
            facing,
            powered,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DarkOakTrapdoorData {
    pub facing: DarkOakTrapdoorFacing,
    pub waterlogged: bool,
    pub open: bool,
    pub powered: bool,
    pub half: DarkOakTrapdoorHalf,
}
impl DarkOakTrapdoorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: DarkOakTrapdoorFacing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            half: DarkOakTrapdoorHalf::from_snake_case(map.get("half")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m
    }
}
impl Default for DarkOakTrapdoorData {
    fn default() -> Self {
        Self {
            facing: DarkOakTrapdoorFacing::North,
            waterlogged: false,
            open: false,
            powered: false,
            half: DarkOakTrapdoorHalf::Bottom,
        }
    }
}
impl Value for DarkOakTrapdoorData {
    fn value(&self) -> usize {
        (self.facing.value() * 16usize)
            + (self.waterlogged.value() * 8usize)
            + (self.open.value() * 4usize)
            + (self.powered.value() * 2usize)
            + (self.half.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 64usize {
            return None;
        }
        let facing = DarkOakTrapdoorFacing::from_value(val / 16usize).unwrap();
        val -= (facing.value() - 0usize) * 16usize;
        let waterlogged = bool::from_value(val / 8usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 8usize;
        let open = bool::from_value(val / 4usize).unwrap();
        val -= (open.value() - 0usize) * 4usize;
        let powered = bool::from_value(val / 2usize).unwrap();
        val -= (powered.value() - 0usize) * 2usize;
        let half = DarkOakTrapdoorHalf::from_value(val / 1usize).unwrap();
        val -= (half.value() - 0usize) * 1usize;
        Some(Self {
            facing,
            waterlogged,
            open,
            powered,
            half,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BrownMushroomBlockData {
    pub east: bool,
    pub north: bool,
    pub up: bool,
    pub south: bool,
    pub down: bool,
    pub west: bool,
}
impl BrownMushroomBlockData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            east: bool::from_snake_case(map.get("east")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            up: bool::from_snake_case(map.get("up")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            down: bool::from_snake_case(map.get("down")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("up".to_string(), self.up.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("down".to_string(), self.down.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m
    }
}
impl Default for BrownMushroomBlockData {
    fn default() -> Self {
        Self {
            east: true,
            north: true,
            up: true,
            south: true,
            down: true,
            west: true,
        }
    }
}
impl Value for BrownMushroomBlockData {
    fn value(&self) -> usize {
        (self.east.value() * 32usize)
            + (self.north.value() * 16usize)
            + (self.up.value() * 8usize)
            + (self.south.value() * 4usize)
            + (self.down.value() * 2usize)
            + (self.west.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 64usize {
            return None;
        }
        let east = bool::from_value(val / 32usize).unwrap();
        val -= (east.value() - 0usize) * 32usize;
        let north = bool::from_value(val / 16usize).unwrap();
        val -= (north.value() - 0usize) * 16usize;
        let up = bool::from_value(val / 8usize).unwrap();
        val -= (up.value() - 0usize) * 8usize;
        let south = bool::from_value(val / 4usize).unwrap();
        val -= (south.value() - 0usize) * 4usize;
        let down = bool::from_value(val / 2usize).unwrap();
        val -= (down.value() - 0usize) * 2usize;
        let west = bool::from_value(val / 1usize).unwrap();
        val -= (west.value() - 0usize) * 1usize;
        Some(Self {
            east,
            north,
            up,
            south,
            down,
            west,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RedMushroomBlockData {
    pub south: bool,
    pub down: bool,
    pub east: bool,
    pub up: bool,
    pub north: bool,
    pub west: bool,
}
impl RedMushroomBlockData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            south: bool::from_snake_case(map.get("south")?)?,
            down: bool::from_snake_case(map.get("down")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            up: bool::from_snake_case(map.get("up")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("down".to_string(), self.down.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("up".to_string(), self.up.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m
    }
}
impl Default for RedMushroomBlockData {
    fn default() -> Self {
        Self {
            south: true,
            down: true,
            east: true,
            up: true,
            north: true,
            west: true,
        }
    }
}
impl Value for RedMushroomBlockData {
    fn value(&self) -> usize {
        (self.south.value() * 32usize)
            + (self.down.value() * 16usize)
            + (self.east.value() * 8usize)
            + (self.up.value() * 4usize)
            + (self.north.value() * 2usize)
            + (self.west.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 64usize {
            return None;
        }
        let south = bool::from_value(val / 32usize).unwrap();
        val -= (south.value() - 0usize) * 32usize;
        let down = bool::from_value(val / 16usize).unwrap();
        val -= (down.value() - 0usize) * 16usize;
        let east = bool::from_value(val / 8usize).unwrap();
        val -= (east.value() - 0usize) * 8usize;
        let up = bool::from_value(val / 4usize).unwrap();
        val -= (up.value() - 0usize) * 4usize;
        let north = bool::from_value(val / 2usize).unwrap();
        val -= (north.value() - 0usize) * 2usize;
        let west = bool::from_value(val / 1usize).unwrap();
        val -= (west.value() - 0usize) * 1usize;
        Some(Self {
            south,
            down,
            east,
            up,
            north,
            west,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct MushroomStemData {
    pub north: bool,
    pub east: bool,
    pub up: bool,
    pub south: bool,
    pub down: bool,
    pub west: bool,
}
impl MushroomStemData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            north: bool::from_snake_case(map.get("north")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            up: bool::from_snake_case(map.get("up")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            down: bool::from_snake_case(map.get("down")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("up".to_string(), self.up.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("down".to_string(), self.down.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m
    }
}
impl Default for MushroomStemData {
    fn default() -> Self {
        Self {
            north: true,
            east: true,
            up: true,
            south: true,
            down: true,
            west: true,
        }
    }
}
impl Value for MushroomStemData {
    fn value(&self) -> usize {
        (self.north.value() * 32usize)
            + (self.east.value() * 16usize)
            + (self.up.value() * 8usize)
            + (self.south.value() * 4usize)
            + (self.down.value() * 2usize)
            + (self.west.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 64usize {
            return None;
        }
        let north = bool::from_value(val / 32usize).unwrap();
        val -= (north.value() - 0usize) * 32usize;
        let east = bool::from_value(val / 16usize).unwrap();
        val -= (east.value() - 0usize) * 16usize;
        let up = bool::from_value(val / 8usize).unwrap();
        val -= (up.value() - 0usize) * 8usize;
        let south = bool::from_value(val / 4usize).unwrap();
        val -= (south.value() - 0usize) * 4usize;
        let down = bool::from_value(val / 2usize).unwrap();
        val -= (down.value() - 0usize) * 2usize;
        let west = bool::from_value(val / 1usize).unwrap();
        val -= (west.value() - 0usize) * 1usize;
        Some(Self {
            north,
            east,
            up,
            south,
            down,
            west,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct IronBarsData {
    pub east: bool,
    pub south: bool,
    pub waterlogged: bool,
    pub west: bool,
    pub north: bool,
}
impl IronBarsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            east: bool::from_snake_case(map.get("east")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m
    }
}
impl Default for IronBarsData {
    fn default() -> Self {
        Self {
            east: false,
            south: false,
            waterlogged: false,
            west: false,
            north: false,
        }
    }
}
impl Value for IronBarsData {
    fn value(&self) -> usize {
        (self.east.value() * 16usize)
            + (self.south.value() * 8usize)
            + (self.waterlogged.value() * 4usize)
            + (self.west.value() * 2usize)
            + (self.north.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 32usize {
            return None;
        }
        let east = bool::from_value(val / 16usize).unwrap();
        val -= (east.value() - 0usize) * 16usize;
        let south = bool::from_value(val / 8usize).unwrap();
        val -= (south.value() - 0usize) * 8usize;
        let waterlogged = bool::from_value(val / 4usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 4usize;
        let west = bool::from_value(val / 2usize).unwrap();
        val -= (west.value() - 0usize) * 2usize;
        let north = bool::from_value(val / 1usize).unwrap();
        val -= (north.value() - 0usize) * 1usize;
        Some(Self {
            east,
            south,
            waterlogged,
            west,
            north,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct GlassPaneData {
    pub south: bool,
    pub east: bool,
    pub north: bool,
    pub west: bool,
    pub waterlogged: bool,
}
impl GlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            south: bool::from_snake_case(map.get("south")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for GlassPaneData {
    fn default() -> Self {
        Self {
            south: false,
            east: false,
            north: false,
            west: false,
            waterlogged: false,
        }
    }
}
impl Value for GlassPaneData {
    fn value(&self) -> usize {
        (self.south.value() * 16usize)
            + (self.east.value() * 8usize)
            + (self.north.value() * 4usize)
            + (self.west.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 32usize {
            return None;
        }
        let south = bool::from_value(val / 16usize).unwrap();
        val -= (south.value() - 0usize) * 16usize;
        let east = bool::from_value(val / 8usize).unwrap();
        val -= (east.value() - 0usize) * 8usize;
        let north = bool::from_value(val / 4usize).unwrap();
        val -= (north.value() - 0usize) * 4usize;
        let west = bool::from_value(val / 2usize).unwrap();
        val -= (west.value() - 0usize) * 2usize;
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self {
            south,
            east,
            north,
            west,
            waterlogged,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AttachedPumpkinStemData {
    pub facing: AttachedPumpkinStemFacing,
}
impl AttachedPumpkinStemData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: AttachedPumpkinStemFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for AttachedPumpkinStemData {
    fn default() -> Self {
        Self {
            facing: AttachedPumpkinStemFacing::North,
        }
    }
}
impl Value for AttachedPumpkinStemData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = AttachedPumpkinStemFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AttachedMelonStemData {
    pub facing: AttachedMelonStemFacing,
}
impl AttachedMelonStemData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: AttachedMelonStemFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for AttachedMelonStemData {
    fn default() -> Self {
        Self {
            facing: AttachedMelonStemFacing::North,
        }
    }
}
impl Value for AttachedMelonStemData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = AttachedMelonStemFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PumpkinStemData {
    pub age: i32,
}
impl PumpkinStemData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            age: i32::from_snake_case(map.get("age")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("age".to_string(), self.age.to_snake_case());
        m
    }
}
impl Default for PumpkinStemData {
    fn default() -> Self {
        Self { age: 0 }
    }
}
impl Value for PumpkinStemData {
    fn value(&self) -> usize {
        (self.age.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 8usize {
            return None;
        }
        let age = i32::from_value(val / 1usize).unwrap();
        val -= (age.value() - 0usize) * 1usize;
        Some(Self { age })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct MelonStemData {
    pub age: i32,
}
impl MelonStemData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            age: i32::from_snake_case(map.get("age")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("age".to_string(), self.age.to_snake_case());
        m
    }
}
impl Default for MelonStemData {
    fn default() -> Self {
        Self { age: 0 }
    }
}
impl Value for MelonStemData {
    fn value(&self) -> usize {
        (self.age.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 8usize {
            return None;
        }
        let age = i32::from_value(val / 1usize).unwrap();
        val -= (age.value() - 0usize) * 1usize;
        Some(Self { age })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct VineData {
    pub east: bool,
    pub north: bool,
    pub south: bool,
    pub up: bool,
    pub west: bool,
}
impl VineData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            east: bool::from_snake_case(map.get("east")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            up: bool::from_snake_case(map.get("up")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("up".to_string(), self.up.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m
    }
}
impl Default for VineData {
    fn default() -> Self {
        Self {
            east: false,
            north: false,
            south: false,
            up: false,
            west: false,
        }
    }
}
impl Value for VineData {
    fn value(&self) -> usize {
        (self.east.value() * 16usize)
            + (self.north.value() * 8usize)
            + (self.south.value() * 4usize)
            + (self.up.value() * 2usize)
            + (self.west.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 32usize {
            return None;
        }
        let east = bool::from_value(val / 16usize).unwrap();
        val -= (east.value() - 0usize) * 16usize;
        let north = bool::from_value(val / 8usize).unwrap();
        val -= (north.value() - 0usize) * 8usize;
        let south = bool::from_value(val / 4usize).unwrap();
        val -= (south.value() - 0usize) * 4usize;
        let up = bool::from_value(val / 2usize).unwrap();
        val -= (up.value() - 0usize) * 2usize;
        let west = bool::from_value(val / 1usize).unwrap();
        val -= (west.value() - 0usize) * 1usize;
        Some(Self {
            east,
            north,
            south,
            up,
            west,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OakFenceGateData {
    pub powered: bool,
    pub facing: OakFenceGateFacing,
    pub in_wall: bool,
    pub open: bool,
}
impl OakFenceGateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
            facing: OakFenceGateFacing::from_snake_case(map.get("facing")?)?,
            in_wall: bool::from_snake_case(map.get("in_wall")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("in_wall".to_string(), self.in_wall.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m
    }
}
impl Default for OakFenceGateData {
    fn default() -> Self {
        Self {
            powered: false,
            facing: OakFenceGateFacing::North,
            in_wall: false,
            open: false,
        }
    }
}
impl Value for OakFenceGateData {
    fn value(&self) -> usize {
        (self.powered.value() * 16usize)
            + (self.facing.value() * 4usize)
            + (self.in_wall.value() * 2usize)
            + (self.open.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 32usize {
            return None;
        }
        let powered = bool::from_value(val / 16usize).unwrap();
        val -= (powered.value() - 0usize) * 16usize;
        let facing = OakFenceGateFacing::from_value(val / 4usize).unwrap();
        val -= (facing.value() - 0usize) * 4usize;
        let in_wall = bool::from_value(val / 2usize).unwrap();
        val -= (in_wall.value() - 0usize) * 2usize;
        let open = bool::from_value(val / 1usize).unwrap();
        val -= (open.value() - 0usize) * 1usize;
        Some(Self {
            powered,
            facing,
            in_wall,
            open,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BrickStairsData {
    pub shape: BrickStairsShape,
    pub half: BrickStairsHalf,
    pub facing: BrickStairsFacing,
    pub waterlogged: bool,
}
impl BrickStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            shape: BrickStairsShape::from_snake_case(map.get("shape")?)?,
            half: BrickStairsHalf::from_snake_case(map.get("half")?)?,
            facing: BrickStairsFacing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for BrickStairsData {
    fn default() -> Self {
        Self {
            shape: BrickStairsShape::Straight,
            half: BrickStairsHalf::Bottom,
            facing: BrickStairsFacing::North,
            waterlogged: false,
        }
    }
}
impl Value for BrickStairsData {
    fn value(&self) -> usize {
        (self.shape.value() * 16usize)
            + (self.half.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 80usize {
            return None;
        }
        let shape = BrickStairsShape::from_value(val / 16usize).unwrap();
        val -= (shape.value() - 0usize) * 16usize;
        let half = BrickStairsHalf::from_value(val / 8usize).unwrap();
        val -= (half.value() - 0usize) * 8usize;
        let facing = BrickStairsFacing::from_value(val / 2usize).unwrap();
        val -= (facing.value() - 0usize) * 2usize;
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self {
            shape,
            half,
            facing,
            waterlogged,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StoneBrickStairsData {
    pub waterlogged: bool,
    pub facing: StoneBrickStairsFacing,
    pub half: StoneBrickStairsHalf,
    pub shape: StoneBrickStairsShape,
}
impl StoneBrickStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            facing: StoneBrickStairsFacing::from_snake_case(map.get("facing")?)?,
            half: StoneBrickStairsHalf::from_snake_case(map.get("half")?)?,
            shape: StoneBrickStairsShape::from_snake_case(map.get("shape")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m
    }
}
impl Default for StoneBrickStairsData {
    fn default() -> Self {
        Self {
            waterlogged: false,
            facing: StoneBrickStairsFacing::North,
            half: StoneBrickStairsHalf::Bottom,
            shape: StoneBrickStairsShape::Straight,
        }
    }
}
impl Value for StoneBrickStairsData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 40usize)
            + (self.facing.value() * 10usize)
            + (self.half.value() * 5usize)
            + (self.shape.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 80usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 40usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 40usize;
        let facing = StoneBrickStairsFacing::from_value(val / 10usize).unwrap();
        val -= (facing.value() - 0usize) * 10usize;
        let half = StoneBrickStairsHalf::from_value(val / 5usize).unwrap();
        val -= (half.value() - 0usize) * 5usize;
        let shape = StoneBrickStairsShape::from_value(val / 1usize).unwrap();
        val -= (shape.value() - 0usize) * 1usize;
        Some(Self {
            waterlogged,
            facing,
            half,
            shape,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct MyceliumData {
    pub snowy: bool,
}
impl MyceliumData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            snowy: bool::from_snake_case(map.get("snowy")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("snowy".to_string(), self.snowy.to_snake_case());
        m
    }
}
impl Default for MyceliumData {
    fn default() -> Self {
        Self { snowy: false }
    }
}
impl Value for MyceliumData {
    fn value(&self) -> usize {
        (self.snowy.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let snowy = bool::from_value(val / 1usize).unwrap();
        val -= (snowy.value() - 0usize) * 1usize;
        Some(Self { snowy })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct NetherBrickFenceData {
    pub west: bool,
    pub south: bool,
    pub north: bool,
    pub waterlogged: bool,
    pub east: bool,
}
impl NetherBrickFenceData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            west: bool::from_snake_case(map.get("west")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m
    }
}
impl Default for NetherBrickFenceData {
    fn default() -> Self {
        Self {
            west: false,
            south: false,
            north: false,
            waterlogged: false,
            east: false,
        }
    }
}
impl Value for NetherBrickFenceData {
    fn value(&self) -> usize {
        (self.west.value() * 16usize)
            + (self.south.value() * 8usize)
            + (self.north.value() * 4usize)
            + (self.waterlogged.value() * 2usize)
            + (self.east.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 32usize {
            return None;
        }
        let west = bool::from_value(val / 16usize).unwrap();
        val -= (west.value() - 0usize) * 16usize;
        let south = bool::from_value(val / 8usize).unwrap();
        val -= (south.value() - 0usize) * 8usize;
        let north = bool::from_value(val / 4usize).unwrap();
        val -= (north.value() - 0usize) * 4usize;
        let waterlogged = bool::from_value(val / 2usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 2usize;
        let east = bool::from_value(val / 1usize).unwrap();
        val -= (east.value() - 0usize) * 1usize;
        Some(Self {
            west,
            south,
            north,
            waterlogged,
            east,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct NetherBrickStairsData {
    pub shape: NetherBrickStairsShape,
    pub half: NetherBrickStairsHalf,
    pub facing: NetherBrickStairsFacing,
    pub waterlogged: bool,
}
impl NetherBrickStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            shape: NetherBrickStairsShape::from_snake_case(map.get("shape")?)?,
            half: NetherBrickStairsHalf::from_snake_case(map.get("half")?)?,
            facing: NetherBrickStairsFacing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for NetherBrickStairsData {
    fn default() -> Self {
        Self {
            shape: NetherBrickStairsShape::Straight,
            half: NetherBrickStairsHalf::Bottom,
            facing: NetherBrickStairsFacing::North,
            waterlogged: false,
        }
    }
}
impl Value for NetherBrickStairsData {
    fn value(&self) -> usize {
        (self.shape.value() * 16usize)
            + (self.half.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 80usize {
            return None;
        }
        let shape = NetherBrickStairsShape::from_value(val / 16usize).unwrap();
        val -= (shape.value() - 0usize) * 16usize;
        let half = NetherBrickStairsHalf::from_value(val / 8usize).unwrap();
        val -= (half.value() - 0usize) * 8usize;
        let facing = NetherBrickStairsFacing::from_value(val / 2usize).unwrap();
        val -= (facing.value() - 0usize) * 2usize;
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self {
            shape,
            half,
            facing,
            waterlogged,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct NetherWartData {
    pub age: i32,
}
impl NetherWartData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            age: i32::from_snake_case(map.get("age")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("age".to_string(), self.age.to_snake_case());
        m
    }
}
impl Default for NetherWartData {
    fn default() -> Self {
        Self { age: 0 }
    }
}
impl Value for NetherWartData {
    fn value(&self) -> usize {
        (self.age.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let age = i32::from_value(val / 1usize).unwrap();
        val -= (age.value() - 0usize) * 1usize;
        Some(Self { age })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BrewingStandData {
    pub has_bottle_0: bool,
    pub has_bottle_1: bool,
    pub has_bottle_2: bool,
}
impl BrewingStandData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            has_bottle_0: bool::from_snake_case(map.get("has_bottle_0")?)?,
            has_bottle_1: bool::from_snake_case(map.get("has_bottle_1")?)?,
            has_bottle_2: bool::from_snake_case(map.get("has_bottle_2")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert(
            "has_bottle_0".to_string(),
            self.has_bottle_0.to_snake_case(),
        );
        m.insert(
            "has_bottle_1".to_string(),
            self.has_bottle_1.to_snake_case(),
        );
        m.insert(
            "has_bottle_2".to_string(),
            self.has_bottle_2.to_snake_case(),
        );
        m
    }
}
impl Default for BrewingStandData {
    fn default() -> Self {
        Self {
            has_bottle_0: false,
            has_bottle_1: false,
            has_bottle_2: false,
        }
    }
}
impl Value for BrewingStandData {
    fn value(&self) -> usize {
        (self.has_bottle_0.value() * 4usize)
            + (self.has_bottle_1.value() * 2usize)
            + (self.has_bottle_2.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 8usize {
            return None;
        }
        let has_bottle_0 = bool::from_value(val / 4usize).unwrap();
        val -= (has_bottle_0.value() - 0usize) * 4usize;
        let has_bottle_1 = bool::from_value(val / 2usize).unwrap();
        val -= (has_bottle_1.value() - 0usize) * 2usize;
        let has_bottle_2 = bool::from_value(val / 1usize).unwrap();
        val -= (has_bottle_2.value() - 0usize) * 1usize;
        Some(Self {
            has_bottle_0,
            has_bottle_1,
            has_bottle_2,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CauldronData {
    pub level: i32,
}
impl CauldronData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            level: i32::from_snake_case(map.get("level")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("level".to_string(), self.level.to_snake_case());
        m
    }
}
impl Default for CauldronData {
    fn default() -> Self {
        Self { level: 0 }
    }
}
impl Value for CauldronData {
    fn value(&self) -> usize {
        (self.level.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let level = i32::from_value(val / 1usize).unwrap();
        val -= (level.value() - 0usize) * 1usize;
        Some(Self { level })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct EndPortalFrameData {
    pub facing: EndPortalFrameFacing,
    pub eye: bool,
}
impl EndPortalFrameData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: EndPortalFrameFacing::from_snake_case(map.get("facing")?)?,
            eye: bool::from_snake_case(map.get("eye")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("eye".to_string(), self.eye.to_snake_case());
        m
    }
}
impl Default for EndPortalFrameData {
    fn default() -> Self {
        Self {
            facing: EndPortalFrameFacing::North,
            eye: false,
        }
    }
}
impl Value for EndPortalFrameData {
    fn value(&self) -> usize {
        (self.facing.value() * 2usize) + (self.eye.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 8usize {
            return None;
        }
        let facing = EndPortalFrameFacing::from_value(val / 2usize).unwrap();
        val -= (facing.value() - 0usize) * 2usize;
        let eye = bool::from_value(val / 1usize).unwrap();
        val -= (eye.value() - 0usize) * 1usize;
        Some(Self { facing, eye })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RedstoneLampData {
    pub lit: bool,
}
impl RedstoneLampData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            lit: bool::from_snake_case(map.get("lit")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("lit".to_string(), self.lit.to_snake_case());
        m
    }
}
impl Default for RedstoneLampData {
    fn default() -> Self {
        Self { lit: false }
    }
}
impl Value for RedstoneLampData {
    fn value(&self) -> usize {
        (self.lit.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let lit = bool::from_value(val / 1usize).unwrap();
        val -= (lit.value() - 0usize) * 1usize;
        Some(Self { lit })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CocoaData {
    pub age: i32,
    pub facing: CocoaFacing,
}
impl CocoaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            age: i32::from_snake_case(map.get("age")?)?,
            facing: CocoaFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("age".to_string(), self.age.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for CocoaData {
    fn default() -> Self {
        Self {
            age: 0,
            facing: CocoaFacing::North,
        }
    }
}
impl Value for CocoaData {
    fn value(&self) -> usize {
        (self.age.value() * 4usize) + (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 12usize {
            return None;
        }
        let age = i32::from_value(val / 4usize).unwrap();
        val -= (age.value() - 0usize) * 4usize;
        let facing = CocoaFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { age, facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SandstoneStairsData {
    pub waterlogged: bool,
    pub half: SandstoneStairsHalf,
    pub facing: SandstoneStairsFacing,
    pub shape: SandstoneStairsShape,
}
impl SandstoneStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            half: SandstoneStairsHalf::from_snake_case(map.get("half")?)?,
            facing: SandstoneStairsFacing::from_snake_case(map.get("facing")?)?,
            shape: SandstoneStairsShape::from_snake_case(map.get("shape")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m
    }
}
impl Default for SandstoneStairsData {
    fn default() -> Self {
        Self {
            waterlogged: false,
            half: SandstoneStairsHalf::Bottom,
            facing: SandstoneStairsFacing::North,
            shape: SandstoneStairsShape::Straight,
        }
    }
}
impl Value for SandstoneStairsData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 40usize)
            + (self.half.value() * 20usize)
            + (self.facing.value() * 5usize)
            + (self.shape.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 80usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 40usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 40usize;
        let half = SandstoneStairsHalf::from_value(val / 20usize).unwrap();
        val -= (half.value() - 0usize) * 20usize;
        let facing = SandstoneStairsFacing::from_value(val / 5usize).unwrap();
        val -= (facing.value() - 0usize) * 5usize;
        let shape = SandstoneStairsShape::from_value(val / 1usize).unwrap();
        val -= (shape.value() - 0usize) * 1usize;
        Some(Self {
            waterlogged,
            half,
            facing,
            shape,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct EnderChestData {
    pub waterlogged: bool,
    pub facing: EnderChestFacing,
}
impl EnderChestData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            facing: EnderChestFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for EnderChestData {
    fn default() -> Self {
        Self {
            waterlogged: false,
            facing: EnderChestFacing::North,
        }
    }
}
impl Value for EnderChestData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 4usize) + (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 8usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 4usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 4usize;
        let facing = EnderChestFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self {
            waterlogged,
            facing,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct TripwireHookData {
    pub facing: TripwireHookFacing,
    pub attached: bool,
    pub powered: bool,
}
impl TripwireHookData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: TripwireHookFacing::from_snake_case(map.get("facing")?)?,
            attached: bool::from_snake_case(map.get("attached")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("attached".to_string(), self.attached.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Default for TripwireHookData {
    fn default() -> Self {
        Self {
            facing: TripwireHookFacing::North,
            attached: false,
            powered: false,
        }
    }
}
impl Value for TripwireHookData {
    fn value(&self) -> usize {
        (self.facing.value() * 4usize)
            + (self.attached.value() * 2usize)
            + (self.powered.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let facing = TripwireHookFacing::from_value(val / 4usize).unwrap();
        val -= (facing.value() - 0usize) * 4usize;
        let attached = bool::from_value(val / 2usize).unwrap();
        val -= (attached.value() - 0usize) * 2usize;
        let powered = bool::from_value(val / 1usize).unwrap();
        val -= (powered.value() - 0usize) * 1usize;
        Some(Self {
            facing,
            attached,
            powered,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct TripwireData {
    pub south: bool,
    pub west: bool,
    pub east: bool,
    pub attached: bool,
    pub north: bool,
    pub powered: bool,
    pub disarmed: bool,
}
impl TripwireData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            south: bool::from_snake_case(map.get("south")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            attached: bool::from_snake_case(map.get("attached")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            disarmed: bool::from_snake_case(map.get("disarmed")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("attached".to_string(), self.attached.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("disarmed".to_string(), self.disarmed.to_snake_case());
        m
    }
}
impl Default for TripwireData {
    fn default() -> Self {
        Self {
            south: false,
            west: false,
            east: false,
            attached: false,
            north: false,
            powered: false,
            disarmed: false,
        }
    }
}
impl Value for TripwireData {
    fn value(&self) -> usize {
        (self.south.value() * 64usize)
            + (self.west.value() * 32usize)
            + (self.east.value() * 16usize)
            + (self.attached.value() * 8usize)
            + (self.north.value() * 4usize)
            + (self.powered.value() * 2usize)
            + (self.disarmed.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 128usize {
            return None;
        }
        let south = bool::from_value(val / 64usize).unwrap();
        val -= (south.value() - 0usize) * 64usize;
        let west = bool::from_value(val / 32usize).unwrap();
        val -= (west.value() - 0usize) * 32usize;
        let east = bool::from_value(val / 16usize).unwrap();
        val -= (east.value() - 0usize) * 16usize;
        let attached = bool::from_value(val / 8usize).unwrap();
        val -= (attached.value() - 0usize) * 8usize;
        let north = bool::from_value(val / 4usize).unwrap();
        val -= (north.value() - 0usize) * 4usize;
        let powered = bool::from_value(val / 2usize).unwrap();
        val -= (powered.value() - 0usize) * 2usize;
        let disarmed = bool::from_value(val / 1usize).unwrap();
        val -= (disarmed.value() - 0usize) * 1usize;
        Some(Self {
            south,
            west,
            east,
            attached,
            north,
            powered,
            disarmed,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SpruceStairsData {
    pub facing: SpruceStairsFacing,
    pub half: SpruceStairsHalf,
    pub shape: SpruceStairsShape,
    pub waterlogged: bool,
}
impl SpruceStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: SpruceStairsFacing::from_snake_case(map.get("facing")?)?,
            half: SpruceStairsHalf::from_snake_case(map.get("half")?)?,
            shape: SpruceStairsShape::from_snake_case(map.get("shape")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for SpruceStairsData {
    fn default() -> Self {
        Self {
            facing: SpruceStairsFacing::North,
            half: SpruceStairsHalf::Bottom,
            shape: SpruceStairsShape::Straight,
            waterlogged: false,
        }
    }
}
impl Value for SpruceStairsData {
    fn value(&self) -> usize {
        (self.facing.value() * 20usize)
            + (self.half.value() * 10usize)
            + (self.shape.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 80usize {
            return None;
        }
        let facing = SpruceStairsFacing::from_value(val / 20usize).unwrap();
        val -= (facing.value() - 0usize) * 20usize;
        let half = SpruceStairsHalf::from_value(val / 10usize).unwrap();
        val -= (half.value() - 0usize) * 10usize;
        let shape = SpruceStairsShape::from_value(val / 2usize).unwrap();
        val -= (shape.value() - 0usize) * 2usize;
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self {
            facing,
            half,
            shape,
            waterlogged,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BirchStairsData {
    pub shape: BirchStairsShape,
    pub waterlogged: bool,
    pub half: BirchStairsHalf,
    pub facing: BirchStairsFacing,
}
impl BirchStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            shape: BirchStairsShape::from_snake_case(map.get("shape")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            half: BirchStairsHalf::from_snake_case(map.get("half")?)?,
            facing: BirchStairsFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for BirchStairsData {
    fn default() -> Self {
        Self {
            shape: BirchStairsShape::Straight,
            waterlogged: false,
            half: BirchStairsHalf::Bottom,
            facing: BirchStairsFacing::North,
        }
    }
}
impl Value for BirchStairsData {
    fn value(&self) -> usize {
        (self.shape.value() * 16usize)
            + (self.waterlogged.value() * 8usize)
            + (self.half.value() * 4usize)
            + (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 80usize {
            return None;
        }
        let shape = BirchStairsShape::from_value(val / 16usize).unwrap();
        val -= (shape.value() - 0usize) * 16usize;
        let waterlogged = bool::from_value(val / 8usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 8usize;
        let half = BirchStairsHalf::from_value(val / 4usize).unwrap();
        val -= (half.value() - 0usize) * 4usize;
        let facing = BirchStairsFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self {
            shape,
            waterlogged,
            half,
            facing,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct JungleStairsData {
    pub facing: JungleStairsFacing,
    pub waterlogged: bool,
    pub shape: JungleStairsShape,
    pub half: JungleStairsHalf,
}
impl JungleStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: JungleStairsFacing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            shape: JungleStairsShape::from_snake_case(map.get("shape")?)?,
            half: JungleStairsHalf::from_snake_case(map.get("half")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m
    }
}
impl Default for JungleStairsData {
    fn default() -> Self {
        Self {
            facing: JungleStairsFacing::North,
            waterlogged: false,
            shape: JungleStairsShape::Straight,
            half: JungleStairsHalf::Bottom,
        }
    }
}
impl Value for JungleStairsData {
    fn value(&self) -> usize {
        (self.facing.value() * 20usize)
            + (self.waterlogged.value() * 10usize)
            + (self.shape.value() * 2usize)
            + (self.half.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 80usize {
            return None;
        }
        let facing = JungleStairsFacing::from_value(val / 20usize).unwrap();
        val -= (facing.value() - 0usize) * 20usize;
        let waterlogged = bool::from_value(val / 10usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 10usize;
        let shape = JungleStairsShape::from_value(val / 2usize).unwrap();
        val -= (shape.value() - 0usize) * 2usize;
        let half = JungleStairsHalf::from_value(val / 1usize).unwrap();
        val -= (half.value() - 0usize) * 1usize;
        Some(Self {
            facing,
            waterlogged,
            shape,
            half,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CommandBlockData {
    pub conditional: bool,
    pub facing: CommandBlockFacing,
}
impl CommandBlockData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            conditional: bool::from_snake_case(map.get("conditional")?)?,
            facing: CommandBlockFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("conditional".to_string(), self.conditional.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for CommandBlockData {
    fn default() -> Self {
        Self {
            conditional: false,
            facing: CommandBlockFacing::North,
        }
    }
}
impl Value for CommandBlockData {
    fn value(&self) -> usize {
        (self.conditional.value() * 6usize) + (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 12usize {
            return None;
        }
        let conditional = bool::from_value(val / 6usize).unwrap();
        val -= (conditional.value() - 0usize) * 6usize;
        let facing = CommandBlockFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self {
            conditional,
            facing,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CobblestoneWallData {
    pub east: bool,
    pub up: bool,
    pub south: bool,
    pub north: bool,
    pub west: bool,
    pub waterlogged: bool,
}
impl CobblestoneWallData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            east: bool::from_snake_case(map.get("east")?)?,
            up: bool::from_snake_case(map.get("up")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("up".to_string(), self.up.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for CobblestoneWallData {
    fn default() -> Self {
        Self {
            east: false,
            up: true,
            south: false,
            north: false,
            west: false,
            waterlogged: false,
        }
    }
}
impl Value for CobblestoneWallData {
    fn value(&self) -> usize {
        (self.east.value() * 32usize)
            + (self.up.value() * 16usize)
            + (self.south.value() * 8usize)
            + (self.north.value() * 4usize)
            + (self.west.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 64usize {
            return None;
        }
        let east = bool::from_value(val / 32usize).unwrap();
        val -= (east.value() - 0usize) * 32usize;
        let up = bool::from_value(val / 16usize).unwrap();
        val -= (up.value() - 0usize) * 16usize;
        let south = bool::from_value(val / 8usize).unwrap();
        val -= (south.value() - 0usize) * 8usize;
        let north = bool::from_value(val / 4usize).unwrap();
        val -= (north.value() - 0usize) * 4usize;
        let west = bool::from_value(val / 2usize).unwrap();
        val -= (west.value() - 0usize) * 2usize;
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self {
            east,
            up,
            south,
            north,
            west,
            waterlogged,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct MossyCobblestoneWallData {
    pub south: bool,
    pub north: bool,
    pub waterlogged: bool,
    pub east: bool,
    pub up: bool,
    pub west: bool,
}
impl MossyCobblestoneWallData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            south: bool::from_snake_case(map.get("south")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            up: bool::from_snake_case(map.get("up")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("up".to_string(), self.up.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m
    }
}
impl Default for MossyCobblestoneWallData {
    fn default() -> Self {
        Self {
            south: false,
            north: false,
            waterlogged: false,
            east: false,
            up: true,
            west: false,
        }
    }
}
impl Value for MossyCobblestoneWallData {
    fn value(&self) -> usize {
        (self.south.value() * 32usize)
            + (self.north.value() * 16usize)
            + (self.waterlogged.value() * 8usize)
            + (self.east.value() * 4usize)
            + (self.up.value() * 2usize)
            + (self.west.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 64usize {
            return None;
        }
        let south = bool::from_value(val / 32usize).unwrap();
        val -= (south.value() - 0usize) * 32usize;
        let north = bool::from_value(val / 16usize).unwrap();
        val -= (north.value() - 0usize) * 16usize;
        let waterlogged = bool::from_value(val / 8usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 8usize;
        let east = bool::from_value(val / 4usize).unwrap();
        val -= (east.value() - 0usize) * 4usize;
        let up = bool::from_value(val / 2usize).unwrap();
        val -= (up.value() - 0usize) * 2usize;
        let west = bool::from_value(val / 1usize).unwrap();
        val -= (west.value() - 0usize) * 1usize;
        Some(Self {
            south,
            north,
            waterlogged,
            east,
            up,
            west,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CarrotsData {
    pub age: i32,
}
impl CarrotsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            age: i32::from_snake_case(map.get("age")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("age".to_string(), self.age.to_snake_case());
        m
    }
}
impl Default for CarrotsData {
    fn default() -> Self {
        Self { age: 0 }
    }
}
impl Value for CarrotsData {
    fn value(&self) -> usize {
        (self.age.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 8usize {
            return None;
        }
        let age = i32::from_value(val / 1usize).unwrap();
        val -= (age.value() - 0usize) * 1usize;
        Some(Self { age })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PotatoesData {
    pub age: i32,
}
impl PotatoesData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            age: i32::from_snake_case(map.get("age")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("age".to_string(), self.age.to_snake_case());
        m
    }
}
impl Default for PotatoesData {
    fn default() -> Self {
        Self { age: 0 }
    }
}
impl Value for PotatoesData {
    fn value(&self) -> usize {
        (self.age.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 8usize {
            return None;
        }
        let age = i32::from_value(val / 1usize).unwrap();
        val -= (age.value() - 0usize) * 1usize;
        Some(Self { age })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OakButtonData {
    pub facing: OakButtonFacing,
    pub powered: bool,
    pub face: OakButtonFace,
}
impl OakButtonData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: OakButtonFacing::from_snake_case(map.get("facing")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            face: OakButtonFace::from_snake_case(map.get("face")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("face".to_string(), self.face.to_snake_case());
        m
    }
}
impl Default for OakButtonData {
    fn default() -> Self {
        Self {
            facing: OakButtonFacing::North,
            powered: false,
            face: OakButtonFace::Wall,
        }
    }
}
impl Value for OakButtonData {
    fn value(&self) -> usize {
        (self.facing.value() * 6usize)
            + (self.powered.value() * 3usize)
            + (self.face.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 24usize {
            return None;
        }
        let facing = OakButtonFacing::from_value(val / 6usize).unwrap();
        val -= (facing.value() - 0usize) * 6usize;
        let powered = bool::from_value(val / 3usize).unwrap();
        val -= (powered.value() - 0usize) * 3usize;
        let face = OakButtonFace::from_value(val / 1usize).unwrap();
        val -= (face.value() - 0usize) * 1usize;
        Some(Self {
            facing,
            powered,
            face,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SpruceButtonData {
    pub powered: bool,
    pub facing: SpruceButtonFacing,
    pub face: SpruceButtonFace,
}
impl SpruceButtonData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
            facing: SpruceButtonFacing::from_snake_case(map.get("facing")?)?,
            face: SpruceButtonFace::from_snake_case(map.get("face")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("face".to_string(), self.face.to_snake_case());
        m
    }
}
impl Default for SpruceButtonData {
    fn default() -> Self {
        Self {
            powered: false,
            facing: SpruceButtonFacing::North,
            face: SpruceButtonFace::Wall,
        }
    }
}
impl Value for SpruceButtonData {
    fn value(&self) -> usize {
        (self.powered.value() * 12usize)
            + (self.facing.value() * 3usize)
            + (self.face.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 24usize {
            return None;
        }
        let powered = bool::from_value(val / 12usize).unwrap();
        val -= (powered.value() - 0usize) * 12usize;
        let facing = SpruceButtonFacing::from_value(val / 3usize).unwrap();
        val -= (facing.value() - 0usize) * 3usize;
        let face = SpruceButtonFace::from_value(val / 1usize).unwrap();
        val -= (face.value() - 0usize) * 1usize;
        Some(Self {
            powered,
            facing,
            face,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BirchButtonData {
    pub powered: bool,
    pub face: BirchButtonFace,
    pub facing: BirchButtonFacing,
}
impl BirchButtonData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
            face: BirchButtonFace::from_snake_case(map.get("face")?)?,
            facing: BirchButtonFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("face".to_string(), self.face.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for BirchButtonData {
    fn default() -> Self {
        Self {
            powered: false,
            face: BirchButtonFace::Wall,
            facing: BirchButtonFacing::North,
        }
    }
}
impl Value for BirchButtonData {
    fn value(&self) -> usize {
        (self.powered.value() * 12usize)
            + (self.face.value() * 4usize)
            + (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 24usize {
            return None;
        }
        let powered = bool::from_value(val / 12usize).unwrap();
        val -= (powered.value() - 0usize) * 12usize;
        let face = BirchButtonFace::from_value(val / 4usize).unwrap();
        val -= (face.value() - 0usize) * 4usize;
        let facing = BirchButtonFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self {
            powered,
            face,
            facing,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct JungleButtonData {
    pub face: JungleButtonFace,
    pub facing: JungleButtonFacing,
    pub powered: bool,
}
impl JungleButtonData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            face: JungleButtonFace::from_snake_case(map.get("face")?)?,
            facing: JungleButtonFacing::from_snake_case(map.get("facing")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("face".to_string(), self.face.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Default for JungleButtonData {
    fn default() -> Self {
        Self {
            face: JungleButtonFace::Wall,
            facing: JungleButtonFacing::North,
            powered: false,
        }
    }
}
impl Value for JungleButtonData {
    fn value(&self) -> usize {
        (self.face.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.powered.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 24usize {
            return None;
        }
        let face = JungleButtonFace::from_value(val / 8usize).unwrap();
        val -= (face.value() - 0usize) * 8usize;
        let facing = JungleButtonFacing::from_value(val / 2usize).unwrap();
        val -= (facing.value() - 0usize) * 2usize;
        let powered = bool::from_value(val / 1usize).unwrap();
        val -= (powered.value() - 0usize) * 1usize;
        Some(Self {
            face,
            facing,
            powered,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AcaciaButtonData {
    pub facing: AcaciaButtonFacing,
    pub powered: bool,
    pub face: AcaciaButtonFace,
}
impl AcaciaButtonData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: AcaciaButtonFacing::from_snake_case(map.get("facing")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            face: AcaciaButtonFace::from_snake_case(map.get("face")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("face".to_string(), self.face.to_snake_case());
        m
    }
}
impl Default for AcaciaButtonData {
    fn default() -> Self {
        Self {
            facing: AcaciaButtonFacing::North,
            powered: false,
            face: AcaciaButtonFace::Wall,
        }
    }
}
impl Value for AcaciaButtonData {
    fn value(&self) -> usize {
        (self.facing.value() * 6usize)
            + (self.powered.value() * 3usize)
            + (self.face.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 24usize {
            return None;
        }
        let facing = AcaciaButtonFacing::from_value(val / 6usize).unwrap();
        val -= (facing.value() - 0usize) * 6usize;
        let powered = bool::from_value(val / 3usize).unwrap();
        val -= (powered.value() - 0usize) * 3usize;
        let face = AcaciaButtonFace::from_value(val / 1usize).unwrap();
        val -= (face.value() - 0usize) * 1usize;
        Some(Self {
            facing,
            powered,
            face,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DarkOakButtonData {
    pub face: DarkOakButtonFace,
    pub powered: bool,
    pub facing: DarkOakButtonFacing,
}
impl DarkOakButtonData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            face: DarkOakButtonFace::from_snake_case(map.get("face")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            facing: DarkOakButtonFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("face".to_string(), self.face.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for DarkOakButtonData {
    fn default() -> Self {
        Self {
            face: DarkOakButtonFace::Wall,
            powered: false,
            facing: DarkOakButtonFacing::North,
        }
    }
}
impl Value for DarkOakButtonData {
    fn value(&self) -> usize {
        (self.face.value() * 8usize)
            + (self.powered.value() * 4usize)
            + (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 24usize {
            return None;
        }
        let face = DarkOakButtonFace::from_value(val / 8usize).unwrap();
        val -= (face.value() - 0usize) * 8usize;
        let powered = bool::from_value(val / 4usize).unwrap();
        val -= (powered.value() - 0usize) * 4usize;
        let facing = DarkOakButtonFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self {
            face,
            powered,
            facing,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SkeletonWallSkullData {
    pub facing: SkeletonWallSkullFacing,
}
impl SkeletonWallSkullData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: SkeletonWallSkullFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for SkeletonWallSkullData {
    fn default() -> Self {
        Self {
            facing: SkeletonWallSkullFacing::North,
        }
    }
}
impl Value for SkeletonWallSkullData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = SkeletonWallSkullFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SkeletonSkullData {
    pub rotation: i32,
}
impl SkeletonSkullData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Default for SkeletonSkullData {
    fn default() -> Self {
        Self { rotation: 0 }
    }
}
impl Value for SkeletonSkullData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let rotation = i32::from_value(val / 1usize).unwrap();
        val -= (rotation.value() - 0usize) * 1usize;
        Some(Self { rotation })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct WitherSkeletonWallSkullData {
    pub facing: WitherSkeletonWallSkullFacing,
}
impl WitherSkeletonWallSkullData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: WitherSkeletonWallSkullFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for WitherSkeletonWallSkullData {
    fn default() -> Self {
        Self {
            facing: WitherSkeletonWallSkullFacing::North,
        }
    }
}
impl Value for WitherSkeletonWallSkullData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = WitherSkeletonWallSkullFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct WitherSkeletonSkullData {
    pub rotation: i32,
}
impl WitherSkeletonSkullData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Default for WitherSkeletonSkullData {
    fn default() -> Self {
        Self { rotation: 0 }
    }
}
impl Value for WitherSkeletonSkullData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let rotation = i32::from_value(val / 1usize).unwrap();
        val -= (rotation.value() - 0usize) * 1usize;
        Some(Self { rotation })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ZombieWallHeadData {
    pub facing: ZombieWallHeadFacing,
}
impl ZombieWallHeadData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: ZombieWallHeadFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for ZombieWallHeadData {
    fn default() -> Self {
        Self {
            facing: ZombieWallHeadFacing::North,
        }
    }
}
impl Value for ZombieWallHeadData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = ZombieWallHeadFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ZombieHeadData {
    pub rotation: i32,
}
impl ZombieHeadData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Default for ZombieHeadData {
    fn default() -> Self {
        Self { rotation: 0 }
    }
}
impl Value for ZombieHeadData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let rotation = i32::from_value(val / 1usize).unwrap();
        val -= (rotation.value() - 0usize) * 1usize;
        Some(Self { rotation })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PlayerWallHeadData {
    pub facing: PlayerWallHeadFacing,
}
impl PlayerWallHeadData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: PlayerWallHeadFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for PlayerWallHeadData {
    fn default() -> Self {
        Self {
            facing: PlayerWallHeadFacing::North,
        }
    }
}
impl Value for PlayerWallHeadData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = PlayerWallHeadFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PlayerHeadData {
    pub rotation: i32,
}
impl PlayerHeadData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Default for PlayerHeadData {
    fn default() -> Self {
        Self { rotation: 0 }
    }
}
impl Value for PlayerHeadData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let rotation = i32::from_value(val / 1usize).unwrap();
        val -= (rotation.value() - 0usize) * 1usize;
        Some(Self { rotation })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CreeperWallHeadData {
    pub facing: CreeperWallHeadFacing,
}
impl CreeperWallHeadData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: CreeperWallHeadFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for CreeperWallHeadData {
    fn default() -> Self {
        Self {
            facing: CreeperWallHeadFacing::North,
        }
    }
}
impl Value for CreeperWallHeadData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = CreeperWallHeadFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CreeperHeadData {
    pub rotation: i32,
}
impl CreeperHeadData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Default for CreeperHeadData {
    fn default() -> Self {
        Self { rotation: 0 }
    }
}
impl Value for CreeperHeadData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let rotation = i32::from_value(val / 1usize).unwrap();
        val -= (rotation.value() - 0usize) * 1usize;
        Some(Self { rotation })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DragonWallHeadData {
    pub facing: DragonWallHeadFacing,
}
impl DragonWallHeadData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: DragonWallHeadFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for DragonWallHeadData {
    fn default() -> Self {
        Self {
            facing: DragonWallHeadFacing::North,
        }
    }
}
impl Value for DragonWallHeadData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = DragonWallHeadFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DragonHeadData {
    pub rotation: i32,
}
impl DragonHeadData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Default for DragonHeadData {
    fn default() -> Self {
        Self { rotation: 0 }
    }
}
impl Value for DragonHeadData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let rotation = i32::from_value(val / 1usize).unwrap();
        val -= (rotation.value() - 0usize) * 1usize;
        Some(Self { rotation })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AnvilData {
    pub facing: AnvilFacing,
}
impl AnvilData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: AnvilFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for AnvilData {
    fn default() -> Self {
        Self {
            facing: AnvilFacing::North,
        }
    }
}
impl Value for AnvilData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = AnvilFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ChippedAnvilData {
    pub facing: ChippedAnvilFacing,
}
impl ChippedAnvilData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: ChippedAnvilFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for ChippedAnvilData {
    fn default() -> Self {
        Self {
            facing: ChippedAnvilFacing::North,
        }
    }
}
impl Value for ChippedAnvilData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = ChippedAnvilFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DamagedAnvilData {
    pub facing: DamagedAnvilFacing,
}
impl DamagedAnvilData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: DamagedAnvilFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for DamagedAnvilData {
    fn default() -> Self {
        Self {
            facing: DamagedAnvilFacing::North,
        }
    }
}
impl Value for DamagedAnvilData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = DamagedAnvilFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct TrappedChestData {
    pub ty: TrappedChestType,
    pub facing: TrappedChestFacing,
    pub waterlogged: bool,
}
impl TrappedChestData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            ty: TrappedChestType::from_snake_case(map.get("type")?)?,
            facing: TrappedChestFacing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("type".to_string(), self.ty.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for TrappedChestData {
    fn default() -> Self {
        Self {
            ty: TrappedChestType::Single,
            facing: TrappedChestFacing::North,
            waterlogged: false,
        }
    }
}
impl Value for TrappedChestData {
    fn value(&self) -> usize {
        (self.ty.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 24usize {
            return None;
        }
        let ty = TrappedChestType::from_value(val / 8usize).unwrap();
        val -= (ty.value() - 0usize) * 8usize;
        let facing = TrappedChestFacing::from_value(val / 2usize).unwrap();
        val -= (facing.value() - 0usize) * 2usize;
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self {
            ty,
            facing,
            waterlogged,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LightWeightedPressurePlateData {
    pub power: i32,
}
impl LightWeightedPressurePlateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            power: i32::from_snake_case(map.get("power")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("power".to_string(), self.power.to_snake_case());
        m
    }
}
impl Default for LightWeightedPressurePlateData {
    fn default() -> Self {
        Self { power: 0 }
    }
}
impl Value for LightWeightedPressurePlateData {
    fn value(&self) -> usize {
        (self.power.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let power = i32::from_value(val / 1usize).unwrap();
        val -= (power.value() - 0usize) * 1usize;
        Some(Self { power })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct HeavyWeightedPressurePlateData {
    pub power: i32,
}
impl HeavyWeightedPressurePlateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            power: i32::from_snake_case(map.get("power")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("power".to_string(), self.power.to_snake_case());
        m
    }
}
impl Default for HeavyWeightedPressurePlateData {
    fn default() -> Self {
        Self { power: 0 }
    }
}
impl Value for HeavyWeightedPressurePlateData {
    fn value(&self) -> usize {
        (self.power.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let power = i32::from_value(val / 1usize).unwrap();
        val -= (power.value() - 0usize) * 1usize;
        Some(Self { power })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ComparatorData {
    pub mode: ComparatorMode,
    pub powered: bool,
    pub facing: ComparatorFacing,
}
impl ComparatorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            mode: ComparatorMode::from_snake_case(map.get("mode")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            facing: ComparatorFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("mode".to_string(), self.mode.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for ComparatorData {
    fn default() -> Self {
        Self {
            mode: ComparatorMode::Compare,
            powered: false,
            facing: ComparatorFacing::North,
        }
    }
}
impl Value for ComparatorData {
    fn value(&self) -> usize {
        (self.mode.value() * 8usize)
            + (self.powered.value() * 4usize)
            + (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let mode = ComparatorMode::from_value(val / 8usize).unwrap();
        val -= (mode.value() - 0usize) * 8usize;
        let powered = bool::from_value(val / 4usize).unwrap();
        val -= (powered.value() - 0usize) * 4usize;
        let facing = ComparatorFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self {
            mode,
            powered,
            facing,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DaylightDetectorData {
    pub power: i32,
    pub inverted: bool,
}
impl DaylightDetectorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            power: i32::from_snake_case(map.get("power")?)?,
            inverted: bool::from_snake_case(map.get("inverted")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("power".to_string(), self.power.to_snake_case());
        m.insert("inverted".to_string(), self.inverted.to_snake_case());
        m
    }
}
impl Default for DaylightDetectorData {
    fn default() -> Self {
        Self {
            power: 0,
            inverted: false,
        }
    }
}
impl Value for DaylightDetectorData {
    fn value(&self) -> usize {
        (self.power.value() * 2usize) + (self.inverted.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 32usize {
            return None;
        }
        let power = i32::from_value(val / 2usize).unwrap();
        val -= (power.value() - 0usize) * 2usize;
        let inverted = bool::from_value(val / 1usize).unwrap();
        val -= (inverted.value() - 0usize) * 1usize;
        Some(Self { power, inverted })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct HopperData {
    pub facing: HopperFacing,
    pub enabled: bool,
}
impl HopperData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: HopperFacing::from_snake_case(map.get("facing")?)?,
            enabled: bool::from_snake_case(map.get("enabled")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("enabled".to_string(), self.enabled.to_snake_case());
        m
    }
}
impl Default for HopperData {
    fn default() -> Self {
        Self {
            facing: HopperFacing::Down,
            enabled: true,
        }
    }
}
impl Value for HopperData {
    fn value(&self) -> usize {
        (self.facing.value() * 2usize) + (self.enabled.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 10usize {
            return None;
        }
        let facing = HopperFacing::from_value(val / 2usize).unwrap();
        val -= (facing.value() - 0usize) * 2usize;
        let enabled = bool::from_value(val / 1usize).unwrap();
        val -= (enabled.value() - 0usize) * 1usize;
        Some(Self { facing, enabled })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct QuartzPillarData {
    pub axis: QuartzPillarAxis,
}
impl QuartzPillarData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: QuartzPillarAxis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Default for QuartzPillarData {
    fn default() -> Self {
        Self {
            axis: QuartzPillarAxis::Y,
        }
    }
}
impl Value for QuartzPillarData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 3usize {
            return None;
        }
        let axis = QuartzPillarAxis::from_value(val / 1usize).unwrap();
        val -= (axis.value() - 0usize) * 1usize;
        Some(Self { axis })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct QuartzStairsData {
    pub shape: QuartzStairsShape,
    pub half: QuartzStairsHalf,
    pub waterlogged: bool,
    pub facing: QuartzStairsFacing,
}
impl QuartzStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            shape: QuartzStairsShape::from_snake_case(map.get("shape")?)?,
            half: QuartzStairsHalf::from_snake_case(map.get("half")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            facing: QuartzStairsFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for QuartzStairsData {
    fn default() -> Self {
        Self {
            shape: QuartzStairsShape::Straight,
            half: QuartzStairsHalf::Bottom,
            waterlogged: false,
            facing: QuartzStairsFacing::North,
        }
    }
}
impl Value for QuartzStairsData {
    fn value(&self) -> usize {
        (self.shape.value() * 16usize)
            + (self.half.value() * 8usize)
            + (self.waterlogged.value() * 4usize)
            + (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 80usize {
            return None;
        }
        let shape = QuartzStairsShape::from_value(val / 16usize).unwrap();
        val -= (shape.value() - 0usize) * 16usize;
        let half = QuartzStairsHalf::from_value(val / 8usize).unwrap();
        val -= (half.value() - 0usize) * 8usize;
        let waterlogged = bool::from_value(val / 4usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 4usize;
        let facing = QuartzStairsFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self {
            shape,
            half,
            waterlogged,
            facing,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ActivatorRailData {
    pub shape: ActivatorRailShape,
    pub powered: bool,
}
impl ActivatorRailData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            shape: ActivatorRailShape::from_snake_case(map.get("shape")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Default for ActivatorRailData {
    fn default() -> Self {
        Self {
            shape: ActivatorRailShape::NorthSouth,
            powered: false,
        }
    }
}
impl Value for ActivatorRailData {
    fn value(&self) -> usize {
        (self.shape.value() * 2usize) + (self.powered.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 12usize {
            return None;
        }
        let shape = ActivatorRailShape::from_value(val / 2usize).unwrap();
        val -= (shape.value() - 0usize) * 2usize;
        let powered = bool::from_value(val / 1usize).unwrap();
        val -= (powered.value() - 0usize) * 1usize;
        Some(Self { shape, powered })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DropperData {
    pub facing: DropperFacing,
    pub triggered: bool,
}
impl DropperData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: DropperFacing::from_snake_case(map.get("facing")?)?,
            triggered: bool::from_snake_case(map.get("triggered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("triggered".to_string(), self.triggered.to_snake_case());
        m
    }
}
impl Default for DropperData {
    fn default() -> Self {
        Self {
            facing: DropperFacing::North,
            triggered: false,
        }
    }
}
impl Value for DropperData {
    fn value(&self) -> usize {
        (self.facing.value() * 2usize) + (self.triggered.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 12usize {
            return None;
        }
        let facing = DropperFacing::from_value(val / 2usize).unwrap();
        val -= (facing.value() - 0usize) * 2usize;
        let triggered = bool::from_value(val / 1usize).unwrap();
        val -= (triggered.value() - 0usize) * 1usize;
        Some(Self { facing, triggered })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct WhiteStainedGlassPaneData {
    pub south: bool,
    pub east: bool,
    pub west: bool,
    pub north: bool,
    pub waterlogged: bool,
}
impl WhiteStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            south: bool::from_snake_case(map.get("south")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for WhiteStainedGlassPaneData {
    fn default() -> Self {
        Self {
            south: false,
            east: false,
            west: false,
            north: false,
            waterlogged: false,
        }
    }
}
impl Value for WhiteStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.south.value() * 16usize)
            + (self.east.value() * 8usize)
            + (self.west.value() * 4usize)
            + (self.north.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 32usize {
            return None;
        }
        let south = bool::from_value(val / 16usize).unwrap();
        val -= (south.value() - 0usize) * 16usize;
        let east = bool::from_value(val / 8usize).unwrap();
        val -= (east.value() - 0usize) * 8usize;
        let west = bool::from_value(val / 4usize).unwrap();
        val -= (west.value() - 0usize) * 4usize;
        let north = bool::from_value(val / 2usize).unwrap();
        val -= (north.value() - 0usize) * 2usize;
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self {
            south,
            east,
            west,
            north,
            waterlogged,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OrangeStainedGlassPaneData {
    pub north: bool,
    pub south: bool,
    pub west: bool,
    pub waterlogged: bool,
    pub east: bool,
}
impl OrangeStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            north: bool::from_snake_case(map.get("north")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m
    }
}
impl Default for OrangeStainedGlassPaneData {
    fn default() -> Self {
        Self {
            north: false,
            south: false,
            west: false,
            waterlogged: false,
            east: false,
        }
    }
}
impl Value for OrangeStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.north.value() * 16usize)
            + (self.south.value() * 8usize)
            + (self.west.value() * 4usize)
            + (self.waterlogged.value() * 2usize)
            + (self.east.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 32usize {
            return None;
        }
        let north = bool::from_value(val / 16usize).unwrap();
        val -= (north.value() - 0usize) * 16usize;
        let south = bool::from_value(val / 8usize).unwrap();
        val -= (south.value() - 0usize) * 8usize;
        let west = bool::from_value(val / 4usize).unwrap();
        val -= (west.value() - 0usize) * 4usize;
        let waterlogged = bool::from_value(val / 2usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 2usize;
        let east = bool::from_value(val / 1usize).unwrap();
        val -= (east.value() - 0usize) * 1usize;
        Some(Self {
            north,
            south,
            west,
            waterlogged,
            east,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct MagentaStainedGlassPaneData {
    pub waterlogged: bool,
    pub south: bool,
    pub east: bool,
    pub west: bool,
    pub north: bool,
}
impl MagentaStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m
    }
}
impl Default for MagentaStainedGlassPaneData {
    fn default() -> Self {
        Self {
            waterlogged: false,
            south: false,
            east: false,
            west: false,
            north: false,
        }
    }
}
impl Value for MagentaStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 16usize)
            + (self.south.value() * 8usize)
            + (self.east.value() * 4usize)
            + (self.west.value() * 2usize)
            + (self.north.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 32usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 16usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 16usize;
        let south = bool::from_value(val / 8usize).unwrap();
        val -= (south.value() - 0usize) * 8usize;
        let east = bool::from_value(val / 4usize).unwrap();
        val -= (east.value() - 0usize) * 4usize;
        let west = bool::from_value(val / 2usize).unwrap();
        val -= (west.value() - 0usize) * 2usize;
        let north = bool::from_value(val / 1usize).unwrap();
        val -= (north.value() - 0usize) * 1usize;
        Some(Self {
            waterlogged,
            south,
            east,
            west,
            north,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LightBlueStainedGlassPaneData {
    pub north: bool,
    pub west: bool,
    pub east: bool,
    pub south: bool,
    pub waterlogged: bool,
}
impl LightBlueStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            north: bool::from_snake_case(map.get("north")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for LightBlueStainedGlassPaneData {
    fn default() -> Self {
        Self {
            north: false,
            west: false,
            east: false,
            south: false,
            waterlogged: false,
        }
    }
}
impl Value for LightBlueStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.north.value() * 16usize)
            + (self.west.value() * 8usize)
            + (self.east.value() * 4usize)
            + (self.south.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 32usize {
            return None;
        }
        let north = bool::from_value(val / 16usize).unwrap();
        val -= (north.value() - 0usize) * 16usize;
        let west = bool::from_value(val / 8usize).unwrap();
        val -= (west.value() - 0usize) * 8usize;
        let east = bool::from_value(val / 4usize).unwrap();
        val -= (east.value() - 0usize) * 4usize;
        let south = bool::from_value(val / 2usize).unwrap();
        val -= (south.value() - 0usize) * 2usize;
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self {
            north,
            west,
            east,
            south,
            waterlogged,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct YellowStainedGlassPaneData {
    pub waterlogged: bool,
    pub west: bool,
    pub east: bool,
    pub north: bool,
    pub south: bool,
}
impl YellowStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m
    }
}
impl Default for YellowStainedGlassPaneData {
    fn default() -> Self {
        Self {
            waterlogged: false,
            west: false,
            east: false,
            north: false,
            south: false,
        }
    }
}
impl Value for YellowStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 16usize)
            + (self.west.value() * 8usize)
            + (self.east.value() * 4usize)
            + (self.north.value() * 2usize)
            + (self.south.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 32usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 16usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 16usize;
        let west = bool::from_value(val / 8usize).unwrap();
        val -= (west.value() - 0usize) * 8usize;
        let east = bool::from_value(val / 4usize).unwrap();
        val -= (east.value() - 0usize) * 4usize;
        let north = bool::from_value(val / 2usize).unwrap();
        val -= (north.value() - 0usize) * 2usize;
        let south = bool::from_value(val / 1usize).unwrap();
        val -= (south.value() - 0usize) * 1usize;
        Some(Self {
            waterlogged,
            west,
            east,
            north,
            south,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LimeStainedGlassPaneData {
    pub east: bool,
    pub waterlogged: bool,
    pub west: bool,
    pub north: bool,
    pub south: bool,
}
impl LimeStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            east: bool::from_snake_case(map.get("east")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m
    }
}
impl Default for LimeStainedGlassPaneData {
    fn default() -> Self {
        Self {
            east: false,
            waterlogged: false,
            west: false,
            north: false,
            south: false,
        }
    }
}
impl Value for LimeStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.east.value() * 16usize)
            + (self.waterlogged.value() * 8usize)
            + (self.west.value() * 4usize)
            + (self.north.value() * 2usize)
            + (self.south.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 32usize {
            return None;
        }
        let east = bool::from_value(val / 16usize).unwrap();
        val -= (east.value() - 0usize) * 16usize;
        let waterlogged = bool::from_value(val / 8usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 8usize;
        let west = bool::from_value(val / 4usize).unwrap();
        val -= (west.value() - 0usize) * 4usize;
        let north = bool::from_value(val / 2usize).unwrap();
        val -= (north.value() - 0usize) * 2usize;
        let south = bool::from_value(val / 1usize).unwrap();
        val -= (south.value() - 0usize) * 1usize;
        Some(Self {
            east,
            waterlogged,
            west,
            north,
            south,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PinkStainedGlassPaneData {
    pub waterlogged: bool,
    pub west: bool,
    pub east: bool,
    pub south: bool,
    pub north: bool,
}
impl PinkStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m
    }
}
impl Default for PinkStainedGlassPaneData {
    fn default() -> Self {
        Self {
            waterlogged: false,
            west: false,
            east: false,
            south: false,
            north: false,
        }
    }
}
impl Value for PinkStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 16usize)
            + (self.west.value() * 8usize)
            + (self.east.value() * 4usize)
            + (self.south.value() * 2usize)
            + (self.north.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 32usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 16usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 16usize;
        let west = bool::from_value(val / 8usize).unwrap();
        val -= (west.value() - 0usize) * 8usize;
        let east = bool::from_value(val / 4usize).unwrap();
        val -= (east.value() - 0usize) * 4usize;
        let south = bool::from_value(val / 2usize).unwrap();
        val -= (south.value() - 0usize) * 2usize;
        let north = bool::from_value(val / 1usize).unwrap();
        val -= (north.value() - 0usize) * 1usize;
        Some(Self {
            waterlogged,
            west,
            east,
            south,
            north,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct GrayStainedGlassPaneData {
    pub north: bool,
    pub east: bool,
    pub south: bool,
    pub waterlogged: bool,
    pub west: bool,
}
impl GrayStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            north: bool::from_snake_case(map.get("north")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m
    }
}
impl Default for GrayStainedGlassPaneData {
    fn default() -> Self {
        Self {
            north: false,
            east: false,
            south: false,
            waterlogged: false,
            west: false,
        }
    }
}
impl Value for GrayStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.north.value() * 16usize)
            + (self.east.value() * 8usize)
            + (self.south.value() * 4usize)
            + (self.waterlogged.value() * 2usize)
            + (self.west.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 32usize {
            return None;
        }
        let north = bool::from_value(val / 16usize).unwrap();
        val -= (north.value() - 0usize) * 16usize;
        let east = bool::from_value(val / 8usize).unwrap();
        val -= (east.value() - 0usize) * 8usize;
        let south = bool::from_value(val / 4usize).unwrap();
        val -= (south.value() - 0usize) * 4usize;
        let waterlogged = bool::from_value(val / 2usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 2usize;
        let west = bool::from_value(val / 1usize).unwrap();
        val -= (west.value() - 0usize) * 1usize;
        Some(Self {
            north,
            east,
            south,
            waterlogged,
            west,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LightGrayStainedGlassPaneData {
    pub north: bool,
    pub waterlogged: bool,
    pub west: bool,
    pub south: bool,
    pub east: bool,
}
impl LightGrayStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            north: bool::from_snake_case(map.get("north")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m
    }
}
impl Default for LightGrayStainedGlassPaneData {
    fn default() -> Self {
        Self {
            north: false,
            waterlogged: false,
            west: false,
            south: false,
            east: false,
        }
    }
}
impl Value for LightGrayStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.north.value() * 16usize)
            + (self.waterlogged.value() * 8usize)
            + (self.west.value() * 4usize)
            + (self.south.value() * 2usize)
            + (self.east.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 32usize {
            return None;
        }
        let north = bool::from_value(val / 16usize).unwrap();
        val -= (north.value() - 0usize) * 16usize;
        let waterlogged = bool::from_value(val / 8usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 8usize;
        let west = bool::from_value(val / 4usize).unwrap();
        val -= (west.value() - 0usize) * 4usize;
        let south = bool::from_value(val / 2usize).unwrap();
        val -= (south.value() - 0usize) * 2usize;
        let east = bool::from_value(val / 1usize).unwrap();
        val -= (east.value() - 0usize) * 1usize;
        Some(Self {
            north,
            waterlogged,
            west,
            south,
            east,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CyanStainedGlassPaneData {
    pub south: bool,
    pub east: bool,
    pub west: bool,
    pub north: bool,
    pub waterlogged: bool,
}
impl CyanStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            south: bool::from_snake_case(map.get("south")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for CyanStainedGlassPaneData {
    fn default() -> Self {
        Self {
            south: false,
            east: false,
            west: false,
            north: false,
            waterlogged: false,
        }
    }
}
impl Value for CyanStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.south.value() * 16usize)
            + (self.east.value() * 8usize)
            + (self.west.value() * 4usize)
            + (self.north.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 32usize {
            return None;
        }
        let south = bool::from_value(val / 16usize).unwrap();
        val -= (south.value() - 0usize) * 16usize;
        let east = bool::from_value(val / 8usize).unwrap();
        val -= (east.value() - 0usize) * 8usize;
        let west = bool::from_value(val / 4usize).unwrap();
        val -= (west.value() - 0usize) * 4usize;
        let north = bool::from_value(val / 2usize).unwrap();
        val -= (north.value() - 0usize) * 2usize;
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self {
            south,
            east,
            west,
            north,
            waterlogged,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PurpleStainedGlassPaneData {
    pub east: bool,
    pub north: bool,
    pub waterlogged: bool,
    pub west: bool,
    pub south: bool,
}
impl PurpleStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            east: bool::from_snake_case(map.get("east")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m
    }
}
impl Default for PurpleStainedGlassPaneData {
    fn default() -> Self {
        Self {
            east: false,
            north: false,
            waterlogged: false,
            west: false,
            south: false,
        }
    }
}
impl Value for PurpleStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.east.value() * 16usize)
            + (self.north.value() * 8usize)
            + (self.waterlogged.value() * 4usize)
            + (self.west.value() * 2usize)
            + (self.south.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 32usize {
            return None;
        }
        let east = bool::from_value(val / 16usize).unwrap();
        val -= (east.value() - 0usize) * 16usize;
        let north = bool::from_value(val / 8usize).unwrap();
        val -= (north.value() - 0usize) * 8usize;
        let waterlogged = bool::from_value(val / 4usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 4usize;
        let west = bool::from_value(val / 2usize).unwrap();
        val -= (west.value() - 0usize) * 2usize;
        let south = bool::from_value(val / 1usize).unwrap();
        val -= (south.value() - 0usize) * 1usize;
        Some(Self {
            east,
            north,
            waterlogged,
            west,
            south,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BlueStainedGlassPaneData {
    pub east: bool,
    pub north: bool,
    pub west: bool,
    pub south: bool,
    pub waterlogged: bool,
}
impl BlueStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            east: bool::from_snake_case(map.get("east")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for BlueStainedGlassPaneData {
    fn default() -> Self {
        Self {
            east: false,
            north: false,
            west: false,
            south: false,
            waterlogged: false,
        }
    }
}
impl Value for BlueStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.east.value() * 16usize)
            + (self.north.value() * 8usize)
            + (self.west.value() * 4usize)
            + (self.south.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 32usize {
            return None;
        }
        let east = bool::from_value(val / 16usize).unwrap();
        val -= (east.value() - 0usize) * 16usize;
        let north = bool::from_value(val / 8usize).unwrap();
        val -= (north.value() - 0usize) * 8usize;
        let west = bool::from_value(val / 4usize).unwrap();
        val -= (west.value() - 0usize) * 4usize;
        let south = bool::from_value(val / 2usize).unwrap();
        val -= (south.value() - 0usize) * 2usize;
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self {
            east,
            north,
            west,
            south,
            waterlogged,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BrownStainedGlassPaneData {
    pub waterlogged: bool,
    pub west: bool,
    pub east: bool,
    pub north: bool,
    pub south: bool,
}
impl BrownStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m
    }
}
impl Default for BrownStainedGlassPaneData {
    fn default() -> Self {
        Self {
            waterlogged: false,
            west: false,
            east: false,
            north: false,
            south: false,
        }
    }
}
impl Value for BrownStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 16usize)
            + (self.west.value() * 8usize)
            + (self.east.value() * 4usize)
            + (self.north.value() * 2usize)
            + (self.south.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 32usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 16usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 16usize;
        let west = bool::from_value(val / 8usize).unwrap();
        val -= (west.value() - 0usize) * 8usize;
        let east = bool::from_value(val / 4usize).unwrap();
        val -= (east.value() - 0usize) * 4usize;
        let north = bool::from_value(val / 2usize).unwrap();
        val -= (north.value() - 0usize) * 2usize;
        let south = bool::from_value(val / 1usize).unwrap();
        val -= (south.value() - 0usize) * 1usize;
        Some(Self {
            waterlogged,
            west,
            east,
            north,
            south,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct GreenStainedGlassPaneData {
    pub east: bool,
    pub south: bool,
    pub waterlogged: bool,
    pub west: bool,
    pub north: bool,
}
impl GreenStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            east: bool::from_snake_case(map.get("east")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m
    }
}
impl Default for GreenStainedGlassPaneData {
    fn default() -> Self {
        Self {
            east: false,
            south: false,
            waterlogged: false,
            west: false,
            north: false,
        }
    }
}
impl Value for GreenStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.east.value() * 16usize)
            + (self.south.value() * 8usize)
            + (self.waterlogged.value() * 4usize)
            + (self.west.value() * 2usize)
            + (self.north.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 32usize {
            return None;
        }
        let east = bool::from_value(val / 16usize).unwrap();
        val -= (east.value() - 0usize) * 16usize;
        let south = bool::from_value(val / 8usize).unwrap();
        val -= (south.value() - 0usize) * 8usize;
        let waterlogged = bool::from_value(val / 4usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 4usize;
        let west = bool::from_value(val / 2usize).unwrap();
        val -= (west.value() - 0usize) * 2usize;
        let north = bool::from_value(val / 1usize).unwrap();
        val -= (north.value() - 0usize) * 1usize;
        Some(Self {
            east,
            south,
            waterlogged,
            west,
            north,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RedStainedGlassPaneData {
    pub east: bool,
    pub south: bool,
    pub north: bool,
    pub west: bool,
    pub waterlogged: bool,
}
impl RedStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            east: bool::from_snake_case(map.get("east")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for RedStainedGlassPaneData {
    fn default() -> Self {
        Self {
            east: false,
            south: false,
            north: false,
            west: false,
            waterlogged: false,
        }
    }
}
impl Value for RedStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.east.value() * 16usize)
            + (self.south.value() * 8usize)
            + (self.north.value() * 4usize)
            + (self.west.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 32usize {
            return None;
        }
        let east = bool::from_value(val / 16usize).unwrap();
        val -= (east.value() - 0usize) * 16usize;
        let south = bool::from_value(val / 8usize).unwrap();
        val -= (south.value() - 0usize) * 8usize;
        let north = bool::from_value(val / 4usize).unwrap();
        val -= (north.value() - 0usize) * 4usize;
        let west = bool::from_value(val / 2usize).unwrap();
        val -= (west.value() - 0usize) * 2usize;
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self {
            east,
            south,
            north,
            west,
            waterlogged,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BlackStainedGlassPaneData {
    pub west: bool,
    pub waterlogged: bool,
    pub east: bool,
    pub north: bool,
    pub south: bool,
}
impl BlackStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            west: bool::from_snake_case(map.get("west")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m
    }
}
impl Default for BlackStainedGlassPaneData {
    fn default() -> Self {
        Self {
            west: false,
            waterlogged: false,
            east: false,
            north: false,
            south: false,
        }
    }
}
impl Value for BlackStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.west.value() * 16usize)
            + (self.waterlogged.value() * 8usize)
            + (self.east.value() * 4usize)
            + (self.north.value() * 2usize)
            + (self.south.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 32usize {
            return None;
        }
        let west = bool::from_value(val / 16usize).unwrap();
        val -= (west.value() - 0usize) * 16usize;
        let waterlogged = bool::from_value(val / 8usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 8usize;
        let east = bool::from_value(val / 4usize).unwrap();
        val -= (east.value() - 0usize) * 4usize;
        let north = bool::from_value(val / 2usize).unwrap();
        val -= (north.value() - 0usize) * 2usize;
        let south = bool::from_value(val / 1usize).unwrap();
        val -= (south.value() - 0usize) * 1usize;
        Some(Self {
            west,
            waterlogged,
            east,
            north,
            south,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AcaciaStairsData {
    pub facing: AcaciaStairsFacing,
    pub half: AcaciaStairsHalf,
    pub shape: AcaciaStairsShape,
    pub waterlogged: bool,
}
impl AcaciaStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: AcaciaStairsFacing::from_snake_case(map.get("facing")?)?,
            half: AcaciaStairsHalf::from_snake_case(map.get("half")?)?,
            shape: AcaciaStairsShape::from_snake_case(map.get("shape")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for AcaciaStairsData {
    fn default() -> Self {
        Self {
            facing: AcaciaStairsFacing::North,
            half: AcaciaStairsHalf::Bottom,
            shape: AcaciaStairsShape::Straight,
            waterlogged: false,
        }
    }
}
impl Value for AcaciaStairsData {
    fn value(&self) -> usize {
        (self.facing.value() * 20usize)
            + (self.half.value() * 10usize)
            + (self.shape.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 80usize {
            return None;
        }
        let facing = AcaciaStairsFacing::from_value(val / 20usize).unwrap();
        val -= (facing.value() - 0usize) * 20usize;
        let half = AcaciaStairsHalf::from_value(val / 10usize).unwrap();
        val -= (half.value() - 0usize) * 10usize;
        let shape = AcaciaStairsShape::from_value(val / 2usize).unwrap();
        val -= (shape.value() - 0usize) * 2usize;
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self {
            facing,
            half,
            shape,
            waterlogged,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DarkOakStairsData {
    pub half: DarkOakStairsHalf,
    pub facing: DarkOakStairsFacing,
    pub shape: DarkOakStairsShape,
    pub waterlogged: bool,
}
impl DarkOakStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            half: DarkOakStairsHalf::from_snake_case(map.get("half")?)?,
            facing: DarkOakStairsFacing::from_snake_case(map.get("facing")?)?,
            shape: DarkOakStairsShape::from_snake_case(map.get("shape")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for DarkOakStairsData {
    fn default() -> Self {
        Self {
            half: DarkOakStairsHalf::Bottom,
            facing: DarkOakStairsFacing::North,
            shape: DarkOakStairsShape::Straight,
            waterlogged: false,
        }
    }
}
impl Value for DarkOakStairsData {
    fn value(&self) -> usize {
        (self.half.value() * 40usize)
            + (self.facing.value() * 10usize)
            + (self.shape.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 80usize {
            return None;
        }
        let half = DarkOakStairsHalf::from_value(val / 40usize).unwrap();
        val -= (half.value() - 0usize) * 40usize;
        let facing = DarkOakStairsFacing::from_value(val / 10usize).unwrap();
        val -= (facing.value() - 0usize) * 10usize;
        let shape = DarkOakStairsShape::from_value(val / 2usize).unwrap();
        val -= (shape.value() - 0usize) * 2usize;
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self {
            half,
            facing,
            shape,
            waterlogged,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct IronTrapdoorData {
    pub facing: IronTrapdoorFacing,
    pub half: IronTrapdoorHalf,
    pub open: bool,
    pub waterlogged: bool,
    pub powered: bool,
}
impl IronTrapdoorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: IronTrapdoorFacing::from_snake_case(map.get("facing")?)?,
            half: IronTrapdoorHalf::from_snake_case(map.get("half")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Default for IronTrapdoorData {
    fn default() -> Self {
        Self {
            facing: IronTrapdoorFacing::North,
            half: IronTrapdoorHalf::Bottom,
            open: false,
            waterlogged: false,
            powered: false,
        }
    }
}
impl Value for IronTrapdoorData {
    fn value(&self) -> usize {
        (self.facing.value() * 16usize)
            + (self.half.value() * 8usize)
            + (self.open.value() * 4usize)
            + (self.waterlogged.value() * 2usize)
            + (self.powered.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 64usize {
            return None;
        }
        let facing = IronTrapdoorFacing::from_value(val / 16usize).unwrap();
        val -= (facing.value() - 0usize) * 16usize;
        let half = IronTrapdoorHalf::from_value(val / 8usize).unwrap();
        val -= (half.value() - 0usize) * 8usize;
        let open = bool::from_value(val / 4usize).unwrap();
        val -= (open.value() - 0usize) * 4usize;
        let waterlogged = bool::from_value(val / 2usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 2usize;
        let powered = bool::from_value(val / 1usize).unwrap();
        val -= (powered.value() - 0usize) * 1usize;
        Some(Self {
            facing,
            half,
            open,
            waterlogged,
            powered,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PrismarineStairsData {
    pub waterlogged: bool,
    pub half: PrismarineStairsHalf,
    pub facing: PrismarineStairsFacing,
    pub shape: PrismarineStairsShape,
}
impl PrismarineStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            half: PrismarineStairsHalf::from_snake_case(map.get("half")?)?,
            facing: PrismarineStairsFacing::from_snake_case(map.get("facing")?)?,
            shape: PrismarineStairsShape::from_snake_case(map.get("shape")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m
    }
}
impl Default for PrismarineStairsData {
    fn default() -> Self {
        Self {
            waterlogged: false,
            half: PrismarineStairsHalf::Bottom,
            facing: PrismarineStairsFacing::North,
            shape: PrismarineStairsShape::Straight,
        }
    }
}
impl Value for PrismarineStairsData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 40usize)
            + (self.half.value() * 20usize)
            + (self.facing.value() * 5usize)
            + (self.shape.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 80usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 40usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 40usize;
        let half = PrismarineStairsHalf::from_value(val / 20usize).unwrap();
        val -= (half.value() - 0usize) * 20usize;
        let facing = PrismarineStairsFacing::from_value(val / 5usize).unwrap();
        val -= (facing.value() - 0usize) * 5usize;
        let shape = PrismarineStairsShape::from_value(val / 1usize).unwrap();
        val -= (shape.value() - 0usize) * 1usize;
        Some(Self {
            waterlogged,
            half,
            facing,
            shape,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PrismarineBrickStairsData {
    pub facing: PrismarineBrickStairsFacing,
    pub waterlogged: bool,
    pub half: PrismarineBrickStairsHalf,
    pub shape: PrismarineBrickStairsShape,
}
impl PrismarineBrickStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: PrismarineBrickStairsFacing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            half: PrismarineBrickStairsHalf::from_snake_case(map.get("half")?)?,
            shape: PrismarineBrickStairsShape::from_snake_case(map.get("shape")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m
    }
}
impl Default for PrismarineBrickStairsData {
    fn default() -> Self {
        Self {
            facing: PrismarineBrickStairsFacing::North,
            waterlogged: false,
            half: PrismarineBrickStairsHalf::Bottom,
            shape: PrismarineBrickStairsShape::Straight,
        }
    }
}
impl Value for PrismarineBrickStairsData {
    fn value(&self) -> usize {
        (self.facing.value() * 20usize)
            + (self.waterlogged.value() * 10usize)
            + (self.half.value() * 5usize)
            + (self.shape.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 80usize {
            return None;
        }
        let facing = PrismarineBrickStairsFacing::from_value(val / 20usize).unwrap();
        val -= (facing.value() - 0usize) * 20usize;
        let waterlogged = bool::from_value(val / 10usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 10usize;
        let half = PrismarineBrickStairsHalf::from_value(val / 5usize).unwrap();
        val -= (half.value() - 0usize) * 5usize;
        let shape = PrismarineBrickStairsShape::from_value(val / 1usize).unwrap();
        val -= (shape.value() - 0usize) * 1usize;
        Some(Self {
            facing,
            waterlogged,
            half,
            shape,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DarkPrismarineStairsData {
    pub half: DarkPrismarineStairsHalf,
    pub shape: DarkPrismarineStairsShape,
    pub waterlogged: bool,
    pub facing: DarkPrismarineStairsFacing,
}
impl DarkPrismarineStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            half: DarkPrismarineStairsHalf::from_snake_case(map.get("half")?)?,
            shape: DarkPrismarineStairsShape::from_snake_case(map.get("shape")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            facing: DarkPrismarineStairsFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for DarkPrismarineStairsData {
    fn default() -> Self {
        Self {
            half: DarkPrismarineStairsHalf::Bottom,
            shape: DarkPrismarineStairsShape::Straight,
            waterlogged: false,
            facing: DarkPrismarineStairsFacing::North,
        }
    }
}
impl Value for DarkPrismarineStairsData {
    fn value(&self) -> usize {
        (self.half.value() * 40usize)
            + (self.shape.value() * 8usize)
            + (self.waterlogged.value() * 4usize)
            + (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 80usize {
            return None;
        }
        let half = DarkPrismarineStairsHalf::from_value(val / 40usize).unwrap();
        val -= (half.value() - 0usize) * 40usize;
        let shape = DarkPrismarineStairsShape::from_value(val / 8usize).unwrap();
        val -= (shape.value() - 0usize) * 8usize;
        let waterlogged = bool::from_value(val / 4usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 4usize;
        let facing = DarkPrismarineStairsFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self {
            half,
            shape,
            waterlogged,
            facing,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PrismarineSlabData {
    pub waterlogged: bool,
    pub ty: PrismarineSlabType,
}
impl PrismarineSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            ty: PrismarineSlabType::from_snake_case(map.get("type")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("type".to_string(), self.ty.to_snake_case());
        m
    }
}
impl Default for PrismarineSlabData {
    fn default() -> Self {
        Self {
            waterlogged: false,
            ty: PrismarineSlabType::Bottom,
        }
    }
}
impl Value for PrismarineSlabData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 3usize) + (self.ty.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 6usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 3usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 3usize;
        let ty = PrismarineSlabType::from_value(val / 1usize).unwrap();
        val -= (ty.value() - 0usize) * 1usize;
        Some(Self { waterlogged, ty })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PrismarineBrickSlabData {
    pub ty: PrismarineBrickSlabType,
    pub waterlogged: bool,
}
impl PrismarineBrickSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            ty: PrismarineBrickSlabType::from_snake_case(map.get("type")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("type".to_string(), self.ty.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for PrismarineBrickSlabData {
    fn default() -> Self {
        Self {
            ty: PrismarineBrickSlabType::Bottom,
            waterlogged: false,
        }
    }
}
impl Value for PrismarineBrickSlabData {
    fn value(&self) -> usize {
        (self.ty.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 6usize {
            return None;
        }
        let ty = PrismarineBrickSlabType::from_value(val / 2usize).unwrap();
        val -= (ty.value() - 0usize) * 2usize;
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self { ty, waterlogged })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DarkPrismarineSlabData {
    pub ty: DarkPrismarineSlabType,
    pub waterlogged: bool,
}
impl DarkPrismarineSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            ty: DarkPrismarineSlabType::from_snake_case(map.get("type")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("type".to_string(), self.ty.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for DarkPrismarineSlabData {
    fn default() -> Self {
        Self {
            ty: DarkPrismarineSlabType::Bottom,
            waterlogged: false,
        }
    }
}
impl Value for DarkPrismarineSlabData {
    fn value(&self) -> usize {
        (self.ty.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 6usize {
            return None;
        }
        let ty = DarkPrismarineSlabType::from_value(val / 2usize).unwrap();
        val -= (ty.value() - 0usize) * 2usize;
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self { ty, waterlogged })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct HayBlockData {
    pub axis: HayBlockAxis,
}
impl HayBlockData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: HayBlockAxis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Default for HayBlockData {
    fn default() -> Self {
        Self {
            axis: HayBlockAxis::Y,
        }
    }
}
impl Value for HayBlockData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 3usize {
            return None;
        }
        let axis = HayBlockAxis::from_value(val / 1usize).unwrap();
        val -= (axis.value() - 0usize) * 1usize;
        Some(Self { axis })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SunflowerData {
    pub half: SunflowerHalf,
}
impl SunflowerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            half: SunflowerHalf::from_snake_case(map.get("half")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("half".to_string(), self.half.to_snake_case());
        m
    }
}
impl Default for SunflowerData {
    fn default() -> Self {
        Self {
            half: SunflowerHalf::Lower,
        }
    }
}
impl Value for SunflowerData {
    fn value(&self) -> usize {
        (self.half.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let half = SunflowerHalf::from_value(val / 1usize).unwrap();
        val -= (half.value() - 0usize) * 1usize;
        Some(Self { half })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LilacData {
    pub half: LilacHalf,
}
impl LilacData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            half: LilacHalf::from_snake_case(map.get("half")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("half".to_string(), self.half.to_snake_case());
        m
    }
}
impl Default for LilacData {
    fn default() -> Self {
        Self {
            half: LilacHalf::Lower,
        }
    }
}
impl Value for LilacData {
    fn value(&self) -> usize {
        (self.half.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let half = LilacHalf::from_value(val / 1usize).unwrap();
        val -= (half.value() - 0usize) * 1usize;
        Some(Self { half })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RoseBushData {
    pub half: RoseBushHalf,
}
impl RoseBushData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            half: RoseBushHalf::from_snake_case(map.get("half")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("half".to_string(), self.half.to_snake_case());
        m
    }
}
impl Default for RoseBushData {
    fn default() -> Self {
        Self {
            half: RoseBushHalf::Lower,
        }
    }
}
impl Value for RoseBushData {
    fn value(&self) -> usize {
        (self.half.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let half = RoseBushHalf::from_value(val / 1usize).unwrap();
        val -= (half.value() - 0usize) * 1usize;
        Some(Self { half })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PeonyData {
    pub half: PeonyHalf,
}
impl PeonyData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            half: PeonyHalf::from_snake_case(map.get("half")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("half".to_string(), self.half.to_snake_case());
        m
    }
}
impl Default for PeonyData {
    fn default() -> Self {
        Self {
            half: PeonyHalf::Lower,
        }
    }
}
impl Value for PeonyData {
    fn value(&self) -> usize {
        (self.half.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let half = PeonyHalf::from_value(val / 1usize).unwrap();
        val -= (half.value() - 0usize) * 1usize;
        Some(Self { half })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct TallGrassData {
    pub half: TallGrassHalf,
}
impl TallGrassData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            half: TallGrassHalf::from_snake_case(map.get("half")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("half".to_string(), self.half.to_snake_case());
        m
    }
}
impl Default for TallGrassData {
    fn default() -> Self {
        Self {
            half: TallGrassHalf::Lower,
        }
    }
}
impl Value for TallGrassData {
    fn value(&self) -> usize {
        (self.half.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let half = TallGrassHalf::from_value(val / 1usize).unwrap();
        val -= (half.value() - 0usize) * 1usize;
        Some(Self { half })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LargeFernData {
    pub half: LargeFernHalf,
}
impl LargeFernData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            half: LargeFernHalf::from_snake_case(map.get("half")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("half".to_string(), self.half.to_snake_case());
        m
    }
}
impl Default for LargeFernData {
    fn default() -> Self {
        Self {
            half: LargeFernHalf::Lower,
        }
    }
}
impl Value for LargeFernData {
    fn value(&self) -> usize {
        (self.half.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let half = LargeFernHalf::from_value(val / 1usize).unwrap();
        val -= (half.value() - 0usize) * 1usize;
        Some(Self { half })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct WhiteBannerData {
    pub rotation: i32,
}
impl WhiteBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Default for WhiteBannerData {
    fn default() -> Self {
        Self { rotation: 0 }
    }
}
impl Value for WhiteBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let rotation = i32::from_value(val / 1usize).unwrap();
        val -= (rotation.value() - 0usize) * 1usize;
        Some(Self { rotation })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OrangeBannerData {
    pub rotation: i32,
}
impl OrangeBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Default for OrangeBannerData {
    fn default() -> Self {
        Self { rotation: 0 }
    }
}
impl Value for OrangeBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let rotation = i32::from_value(val / 1usize).unwrap();
        val -= (rotation.value() - 0usize) * 1usize;
        Some(Self { rotation })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct MagentaBannerData {
    pub rotation: i32,
}
impl MagentaBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Default for MagentaBannerData {
    fn default() -> Self {
        Self { rotation: 0 }
    }
}
impl Value for MagentaBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let rotation = i32::from_value(val / 1usize).unwrap();
        val -= (rotation.value() - 0usize) * 1usize;
        Some(Self { rotation })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LightBlueBannerData {
    pub rotation: i32,
}
impl LightBlueBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Default for LightBlueBannerData {
    fn default() -> Self {
        Self { rotation: 0 }
    }
}
impl Value for LightBlueBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let rotation = i32::from_value(val / 1usize).unwrap();
        val -= (rotation.value() - 0usize) * 1usize;
        Some(Self { rotation })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct YellowBannerData {
    pub rotation: i32,
}
impl YellowBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Default for YellowBannerData {
    fn default() -> Self {
        Self { rotation: 0 }
    }
}
impl Value for YellowBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let rotation = i32::from_value(val / 1usize).unwrap();
        val -= (rotation.value() - 0usize) * 1usize;
        Some(Self { rotation })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LimeBannerData {
    pub rotation: i32,
}
impl LimeBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Default for LimeBannerData {
    fn default() -> Self {
        Self { rotation: 0 }
    }
}
impl Value for LimeBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let rotation = i32::from_value(val / 1usize).unwrap();
        val -= (rotation.value() - 0usize) * 1usize;
        Some(Self { rotation })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PinkBannerData {
    pub rotation: i32,
}
impl PinkBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Default for PinkBannerData {
    fn default() -> Self {
        Self { rotation: 0 }
    }
}
impl Value for PinkBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let rotation = i32::from_value(val / 1usize).unwrap();
        val -= (rotation.value() - 0usize) * 1usize;
        Some(Self { rotation })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct GrayBannerData {
    pub rotation: i32,
}
impl GrayBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Default for GrayBannerData {
    fn default() -> Self {
        Self { rotation: 0 }
    }
}
impl Value for GrayBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let rotation = i32::from_value(val / 1usize).unwrap();
        val -= (rotation.value() - 0usize) * 1usize;
        Some(Self { rotation })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LightGrayBannerData {
    pub rotation: i32,
}
impl LightGrayBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Default for LightGrayBannerData {
    fn default() -> Self {
        Self { rotation: 0 }
    }
}
impl Value for LightGrayBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let rotation = i32::from_value(val / 1usize).unwrap();
        val -= (rotation.value() - 0usize) * 1usize;
        Some(Self { rotation })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CyanBannerData {
    pub rotation: i32,
}
impl CyanBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Default for CyanBannerData {
    fn default() -> Self {
        Self { rotation: 0 }
    }
}
impl Value for CyanBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let rotation = i32::from_value(val / 1usize).unwrap();
        val -= (rotation.value() - 0usize) * 1usize;
        Some(Self { rotation })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PurpleBannerData {
    pub rotation: i32,
}
impl PurpleBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Default for PurpleBannerData {
    fn default() -> Self {
        Self { rotation: 0 }
    }
}
impl Value for PurpleBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let rotation = i32::from_value(val / 1usize).unwrap();
        val -= (rotation.value() - 0usize) * 1usize;
        Some(Self { rotation })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BlueBannerData {
    pub rotation: i32,
}
impl BlueBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Default for BlueBannerData {
    fn default() -> Self {
        Self { rotation: 0 }
    }
}
impl Value for BlueBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let rotation = i32::from_value(val / 1usize).unwrap();
        val -= (rotation.value() - 0usize) * 1usize;
        Some(Self { rotation })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BrownBannerData {
    pub rotation: i32,
}
impl BrownBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Default for BrownBannerData {
    fn default() -> Self {
        Self { rotation: 0 }
    }
}
impl Value for BrownBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let rotation = i32::from_value(val / 1usize).unwrap();
        val -= (rotation.value() - 0usize) * 1usize;
        Some(Self { rotation })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct GreenBannerData {
    pub rotation: i32,
}
impl GreenBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Default for GreenBannerData {
    fn default() -> Self {
        Self { rotation: 0 }
    }
}
impl Value for GreenBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let rotation = i32::from_value(val / 1usize).unwrap();
        val -= (rotation.value() - 0usize) * 1usize;
        Some(Self { rotation })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RedBannerData {
    pub rotation: i32,
}
impl RedBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Default for RedBannerData {
    fn default() -> Self {
        Self { rotation: 0 }
    }
}
impl Value for RedBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let rotation = i32::from_value(val / 1usize).unwrap();
        val -= (rotation.value() - 0usize) * 1usize;
        Some(Self { rotation })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BlackBannerData {
    pub rotation: i32,
}
impl BlackBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Default for BlackBannerData {
    fn default() -> Self {
        Self { rotation: 0 }
    }
}
impl Value for BlackBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 16usize {
            return None;
        }
        let rotation = i32::from_value(val / 1usize).unwrap();
        val -= (rotation.value() - 0usize) * 1usize;
        Some(Self { rotation })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct WhiteWallBannerData {
    pub facing: WhiteWallBannerFacing,
}
impl WhiteWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: WhiteWallBannerFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for WhiteWallBannerData {
    fn default() -> Self {
        Self {
            facing: WhiteWallBannerFacing::North,
        }
    }
}
impl Value for WhiteWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = WhiteWallBannerFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OrangeWallBannerData {
    pub facing: OrangeWallBannerFacing,
}
impl OrangeWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: OrangeWallBannerFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for OrangeWallBannerData {
    fn default() -> Self {
        Self {
            facing: OrangeWallBannerFacing::North,
        }
    }
}
impl Value for OrangeWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = OrangeWallBannerFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct MagentaWallBannerData {
    pub facing: MagentaWallBannerFacing,
}
impl MagentaWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: MagentaWallBannerFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for MagentaWallBannerData {
    fn default() -> Self {
        Self {
            facing: MagentaWallBannerFacing::North,
        }
    }
}
impl Value for MagentaWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = MagentaWallBannerFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LightBlueWallBannerData {
    pub facing: LightBlueWallBannerFacing,
}
impl LightBlueWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: LightBlueWallBannerFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for LightBlueWallBannerData {
    fn default() -> Self {
        Self {
            facing: LightBlueWallBannerFacing::North,
        }
    }
}
impl Value for LightBlueWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = LightBlueWallBannerFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct YellowWallBannerData {
    pub facing: YellowWallBannerFacing,
}
impl YellowWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: YellowWallBannerFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for YellowWallBannerData {
    fn default() -> Self {
        Self {
            facing: YellowWallBannerFacing::North,
        }
    }
}
impl Value for YellowWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = YellowWallBannerFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LimeWallBannerData {
    pub facing: LimeWallBannerFacing,
}
impl LimeWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: LimeWallBannerFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for LimeWallBannerData {
    fn default() -> Self {
        Self {
            facing: LimeWallBannerFacing::North,
        }
    }
}
impl Value for LimeWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = LimeWallBannerFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PinkWallBannerData {
    pub facing: PinkWallBannerFacing,
}
impl PinkWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: PinkWallBannerFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for PinkWallBannerData {
    fn default() -> Self {
        Self {
            facing: PinkWallBannerFacing::North,
        }
    }
}
impl Value for PinkWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = PinkWallBannerFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct GrayWallBannerData {
    pub facing: GrayWallBannerFacing,
}
impl GrayWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: GrayWallBannerFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for GrayWallBannerData {
    fn default() -> Self {
        Self {
            facing: GrayWallBannerFacing::North,
        }
    }
}
impl Value for GrayWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = GrayWallBannerFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LightGrayWallBannerData {
    pub facing: LightGrayWallBannerFacing,
}
impl LightGrayWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: LightGrayWallBannerFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for LightGrayWallBannerData {
    fn default() -> Self {
        Self {
            facing: LightGrayWallBannerFacing::North,
        }
    }
}
impl Value for LightGrayWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = LightGrayWallBannerFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CyanWallBannerData {
    pub facing: CyanWallBannerFacing,
}
impl CyanWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: CyanWallBannerFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for CyanWallBannerData {
    fn default() -> Self {
        Self {
            facing: CyanWallBannerFacing::North,
        }
    }
}
impl Value for CyanWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = CyanWallBannerFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PurpleWallBannerData {
    pub facing: PurpleWallBannerFacing,
}
impl PurpleWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: PurpleWallBannerFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for PurpleWallBannerData {
    fn default() -> Self {
        Self {
            facing: PurpleWallBannerFacing::North,
        }
    }
}
impl Value for PurpleWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = PurpleWallBannerFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BlueWallBannerData {
    pub facing: BlueWallBannerFacing,
}
impl BlueWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: BlueWallBannerFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for BlueWallBannerData {
    fn default() -> Self {
        Self {
            facing: BlueWallBannerFacing::North,
        }
    }
}
impl Value for BlueWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = BlueWallBannerFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BrownWallBannerData {
    pub facing: BrownWallBannerFacing,
}
impl BrownWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: BrownWallBannerFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for BrownWallBannerData {
    fn default() -> Self {
        Self {
            facing: BrownWallBannerFacing::North,
        }
    }
}
impl Value for BrownWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = BrownWallBannerFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct GreenWallBannerData {
    pub facing: GreenWallBannerFacing,
}
impl GreenWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: GreenWallBannerFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for GreenWallBannerData {
    fn default() -> Self {
        Self {
            facing: GreenWallBannerFacing::North,
        }
    }
}
impl Value for GreenWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = GreenWallBannerFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RedWallBannerData {
    pub facing: RedWallBannerFacing,
}
impl RedWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: RedWallBannerFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for RedWallBannerData {
    fn default() -> Self {
        Self {
            facing: RedWallBannerFacing::North,
        }
    }
}
impl Value for RedWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = RedWallBannerFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BlackWallBannerData {
    pub facing: BlackWallBannerFacing,
}
impl BlackWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: BlackWallBannerFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for BlackWallBannerData {
    fn default() -> Self {
        Self {
            facing: BlackWallBannerFacing::North,
        }
    }
}
impl Value for BlackWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = BlackWallBannerFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RedSandstoneStairsData {
    pub shape: RedSandstoneStairsShape,
    pub half: RedSandstoneStairsHalf,
    pub facing: RedSandstoneStairsFacing,
    pub waterlogged: bool,
}
impl RedSandstoneStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            shape: RedSandstoneStairsShape::from_snake_case(map.get("shape")?)?,
            half: RedSandstoneStairsHalf::from_snake_case(map.get("half")?)?,
            facing: RedSandstoneStairsFacing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for RedSandstoneStairsData {
    fn default() -> Self {
        Self {
            shape: RedSandstoneStairsShape::Straight,
            half: RedSandstoneStairsHalf::Bottom,
            facing: RedSandstoneStairsFacing::North,
            waterlogged: false,
        }
    }
}
impl Value for RedSandstoneStairsData {
    fn value(&self) -> usize {
        (self.shape.value() * 16usize)
            + (self.half.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 80usize {
            return None;
        }
        let shape = RedSandstoneStairsShape::from_value(val / 16usize).unwrap();
        val -= (shape.value() - 0usize) * 16usize;
        let half = RedSandstoneStairsHalf::from_value(val / 8usize).unwrap();
        val -= (half.value() - 0usize) * 8usize;
        let facing = RedSandstoneStairsFacing::from_value(val / 2usize).unwrap();
        val -= (facing.value() - 0usize) * 2usize;
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self {
            shape,
            half,
            facing,
            waterlogged,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OakSlabData {
    pub waterlogged: bool,
    pub ty: OakSlabType,
}
impl OakSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            ty: OakSlabType::from_snake_case(map.get("type")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("type".to_string(), self.ty.to_snake_case());
        m
    }
}
impl Default for OakSlabData {
    fn default() -> Self {
        Self {
            waterlogged: false,
            ty: OakSlabType::Bottom,
        }
    }
}
impl Value for OakSlabData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 3usize) + (self.ty.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 6usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 3usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 3usize;
        let ty = OakSlabType::from_value(val / 1usize).unwrap();
        val -= (ty.value() - 0usize) * 1usize;
        Some(Self { waterlogged, ty })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SpruceSlabData {
    pub ty: SpruceSlabType,
    pub waterlogged: bool,
}
impl SpruceSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            ty: SpruceSlabType::from_snake_case(map.get("type")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("type".to_string(), self.ty.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for SpruceSlabData {
    fn default() -> Self {
        Self {
            ty: SpruceSlabType::Bottom,
            waterlogged: false,
        }
    }
}
impl Value for SpruceSlabData {
    fn value(&self) -> usize {
        (self.ty.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 6usize {
            return None;
        }
        let ty = SpruceSlabType::from_value(val / 2usize).unwrap();
        val -= (ty.value() - 0usize) * 2usize;
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self { ty, waterlogged })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BirchSlabData {
    pub waterlogged: bool,
    pub ty: BirchSlabType,
}
impl BirchSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            ty: BirchSlabType::from_snake_case(map.get("type")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("type".to_string(), self.ty.to_snake_case());
        m
    }
}
impl Default for BirchSlabData {
    fn default() -> Self {
        Self {
            waterlogged: false,
            ty: BirchSlabType::Bottom,
        }
    }
}
impl Value for BirchSlabData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 3usize) + (self.ty.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 6usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 3usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 3usize;
        let ty = BirchSlabType::from_value(val / 1usize).unwrap();
        val -= (ty.value() - 0usize) * 1usize;
        Some(Self { waterlogged, ty })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct JungleSlabData {
    pub ty: JungleSlabType,
    pub waterlogged: bool,
}
impl JungleSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            ty: JungleSlabType::from_snake_case(map.get("type")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("type".to_string(), self.ty.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for JungleSlabData {
    fn default() -> Self {
        Self {
            ty: JungleSlabType::Bottom,
            waterlogged: false,
        }
    }
}
impl Value for JungleSlabData {
    fn value(&self) -> usize {
        (self.ty.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 6usize {
            return None;
        }
        let ty = JungleSlabType::from_value(val / 2usize).unwrap();
        val -= (ty.value() - 0usize) * 2usize;
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self { ty, waterlogged })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AcaciaSlabData {
    pub ty: AcaciaSlabType,
    pub waterlogged: bool,
}
impl AcaciaSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            ty: AcaciaSlabType::from_snake_case(map.get("type")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("type".to_string(), self.ty.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for AcaciaSlabData {
    fn default() -> Self {
        Self {
            ty: AcaciaSlabType::Bottom,
            waterlogged: false,
        }
    }
}
impl Value for AcaciaSlabData {
    fn value(&self) -> usize {
        (self.ty.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 6usize {
            return None;
        }
        let ty = AcaciaSlabType::from_value(val / 2usize).unwrap();
        val -= (ty.value() - 0usize) * 2usize;
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self { ty, waterlogged })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DarkOakSlabData {
    pub waterlogged: bool,
    pub ty: DarkOakSlabType,
}
impl DarkOakSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            ty: DarkOakSlabType::from_snake_case(map.get("type")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("type".to_string(), self.ty.to_snake_case());
        m
    }
}
impl Default for DarkOakSlabData {
    fn default() -> Self {
        Self {
            waterlogged: false,
            ty: DarkOakSlabType::Bottom,
        }
    }
}
impl Value for DarkOakSlabData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 3usize) + (self.ty.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 6usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 3usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 3usize;
        let ty = DarkOakSlabType::from_value(val / 1usize).unwrap();
        val -= (ty.value() - 0usize) * 1usize;
        Some(Self { waterlogged, ty })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StoneSlabData {
    pub ty: StoneSlabType,
    pub waterlogged: bool,
}
impl StoneSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            ty: StoneSlabType::from_snake_case(map.get("type")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("type".to_string(), self.ty.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for StoneSlabData {
    fn default() -> Self {
        Self {
            ty: StoneSlabType::Bottom,
            waterlogged: false,
        }
    }
}
impl Value for StoneSlabData {
    fn value(&self) -> usize {
        (self.ty.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 6usize {
            return None;
        }
        let ty = StoneSlabType::from_value(val / 2usize).unwrap();
        val -= (ty.value() - 0usize) * 2usize;
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self { ty, waterlogged })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SandstoneSlabData {
    pub ty: SandstoneSlabType,
    pub waterlogged: bool,
}
impl SandstoneSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            ty: SandstoneSlabType::from_snake_case(map.get("type")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("type".to_string(), self.ty.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for SandstoneSlabData {
    fn default() -> Self {
        Self {
            ty: SandstoneSlabType::Bottom,
            waterlogged: false,
        }
    }
}
impl Value for SandstoneSlabData {
    fn value(&self) -> usize {
        (self.ty.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 6usize {
            return None;
        }
        let ty = SandstoneSlabType::from_value(val / 2usize).unwrap();
        val -= (ty.value() - 0usize) * 2usize;
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self { ty, waterlogged })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PetrifiedOakSlabData {
    pub ty: PetrifiedOakSlabType,
    pub waterlogged: bool,
}
impl PetrifiedOakSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            ty: PetrifiedOakSlabType::from_snake_case(map.get("type")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("type".to_string(), self.ty.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for PetrifiedOakSlabData {
    fn default() -> Self {
        Self {
            ty: PetrifiedOakSlabType::Bottom,
            waterlogged: false,
        }
    }
}
impl Value for PetrifiedOakSlabData {
    fn value(&self) -> usize {
        (self.ty.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 6usize {
            return None;
        }
        let ty = PetrifiedOakSlabType::from_value(val / 2usize).unwrap();
        val -= (ty.value() - 0usize) * 2usize;
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self { ty, waterlogged })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CobblestoneSlabData {
    pub ty: CobblestoneSlabType,
    pub waterlogged: bool,
}
impl CobblestoneSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            ty: CobblestoneSlabType::from_snake_case(map.get("type")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("type".to_string(), self.ty.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for CobblestoneSlabData {
    fn default() -> Self {
        Self {
            ty: CobblestoneSlabType::Bottom,
            waterlogged: false,
        }
    }
}
impl Value for CobblestoneSlabData {
    fn value(&self) -> usize {
        (self.ty.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 6usize {
            return None;
        }
        let ty = CobblestoneSlabType::from_value(val / 2usize).unwrap();
        val -= (ty.value() - 0usize) * 2usize;
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self { ty, waterlogged })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BrickSlabData {
    pub ty: BrickSlabType,
    pub waterlogged: bool,
}
impl BrickSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            ty: BrickSlabType::from_snake_case(map.get("type")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("type".to_string(), self.ty.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for BrickSlabData {
    fn default() -> Self {
        Self {
            ty: BrickSlabType::Bottom,
            waterlogged: false,
        }
    }
}
impl Value for BrickSlabData {
    fn value(&self) -> usize {
        (self.ty.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 6usize {
            return None;
        }
        let ty = BrickSlabType::from_value(val / 2usize).unwrap();
        val -= (ty.value() - 0usize) * 2usize;
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self { ty, waterlogged })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StoneBrickSlabData {
    pub waterlogged: bool,
    pub ty: StoneBrickSlabType,
}
impl StoneBrickSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            ty: StoneBrickSlabType::from_snake_case(map.get("type")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("type".to_string(), self.ty.to_snake_case());
        m
    }
}
impl Default for StoneBrickSlabData {
    fn default() -> Self {
        Self {
            waterlogged: false,
            ty: StoneBrickSlabType::Bottom,
        }
    }
}
impl Value for StoneBrickSlabData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 3usize) + (self.ty.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 6usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 3usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 3usize;
        let ty = StoneBrickSlabType::from_value(val / 1usize).unwrap();
        val -= (ty.value() - 0usize) * 1usize;
        Some(Self { waterlogged, ty })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct NetherBrickSlabData {
    pub ty: NetherBrickSlabType,
    pub waterlogged: bool,
}
impl NetherBrickSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            ty: NetherBrickSlabType::from_snake_case(map.get("type")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("type".to_string(), self.ty.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for NetherBrickSlabData {
    fn default() -> Self {
        Self {
            ty: NetherBrickSlabType::Bottom,
            waterlogged: false,
        }
    }
}
impl Value for NetherBrickSlabData {
    fn value(&self) -> usize {
        (self.ty.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 6usize {
            return None;
        }
        let ty = NetherBrickSlabType::from_value(val / 2usize).unwrap();
        val -= (ty.value() - 0usize) * 2usize;
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self { ty, waterlogged })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct QuartzSlabData {
    pub ty: QuartzSlabType,
    pub waterlogged: bool,
}
impl QuartzSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            ty: QuartzSlabType::from_snake_case(map.get("type")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("type".to_string(), self.ty.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for QuartzSlabData {
    fn default() -> Self {
        Self {
            ty: QuartzSlabType::Bottom,
            waterlogged: false,
        }
    }
}
impl Value for QuartzSlabData {
    fn value(&self) -> usize {
        (self.ty.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 6usize {
            return None;
        }
        let ty = QuartzSlabType::from_value(val / 2usize).unwrap();
        val -= (ty.value() - 0usize) * 2usize;
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self { ty, waterlogged })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RedSandstoneSlabData {
    pub waterlogged: bool,
    pub ty: RedSandstoneSlabType,
}
impl RedSandstoneSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            ty: RedSandstoneSlabType::from_snake_case(map.get("type")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("type".to_string(), self.ty.to_snake_case());
        m
    }
}
impl Default for RedSandstoneSlabData {
    fn default() -> Self {
        Self {
            waterlogged: false,
            ty: RedSandstoneSlabType::Bottom,
        }
    }
}
impl Value for RedSandstoneSlabData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 3usize) + (self.ty.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 6usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 3usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 3usize;
        let ty = RedSandstoneSlabType::from_value(val / 1usize).unwrap();
        val -= (ty.value() - 0usize) * 1usize;
        Some(Self { waterlogged, ty })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PurpurSlabData {
    pub ty: PurpurSlabType,
    pub waterlogged: bool,
}
impl PurpurSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            ty: PurpurSlabType::from_snake_case(map.get("type")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("type".to_string(), self.ty.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for PurpurSlabData {
    fn default() -> Self {
        Self {
            ty: PurpurSlabType::Bottom,
            waterlogged: false,
        }
    }
}
impl Value for PurpurSlabData {
    fn value(&self) -> usize {
        (self.ty.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 6usize {
            return None;
        }
        let ty = PurpurSlabType::from_value(val / 2usize).unwrap();
        val -= (ty.value() - 0usize) * 2usize;
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self { ty, waterlogged })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SpruceFenceGateData {
    pub powered: bool,
    pub open: bool,
    pub facing: SpruceFenceGateFacing,
    pub in_wall: bool,
}
impl SpruceFenceGateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
            facing: SpruceFenceGateFacing::from_snake_case(map.get("facing")?)?,
            in_wall: bool::from_snake_case(map.get("in_wall")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("in_wall".to_string(), self.in_wall.to_snake_case());
        m
    }
}
impl Default for SpruceFenceGateData {
    fn default() -> Self {
        Self {
            powered: false,
            open: false,
            facing: SpruceFenceGateFacing::North,
            in_wall: false,
        }
    }
}
impl Value for SpruceFenceGateData {
    fn value(&self) -> usize {
        (self.powered.value() * 16usize)
            + (self.open.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.in_wall.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 32usize {
            return None;
        }
        let powered = bool::from_value(val / 16usize).unwrap();
        val -= (powered.value() - 0usize) * 16usize;
        let open = bool::from_value(val / 8usize).unwrap();
        val -= (open.value() - 0usize) * 8usize;
        let facing = SpruceFenceGateFacing::from_value(val / 2usize).unwrap();
        val -= (facing.value() - 0usize) * 2usize;
        let in_wall = bool::from_value(val / 1usize).unwrap();
        val -= (in_wall.value() - 0usize) * 1usize;
        Some(Self {
            powered,
            open,
            facing,
            in_wall,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BirchFenceGateData {
    pub in_wall: bool,
    pub open: bool,
    pub facing: BirchFenceGateFacing,
    pub powered: bool,
}
impl BirchFenceGateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            in_wall: bool::from_snake_case(map.get("in_wall")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
            facing: BirchFenceGateFacing::from_snake_case(map.get("facing")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("in_wall".to_string(), self.in_wall.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Default for BirchFenceGateData {
    fn default() -> Self {
        Self {
            in_wall: false,
            open: false,
            facing: BirchFenceGateFacing::North,
            powered: false,
        }
    }
}
impl Value for BirchFenceGateData {
    fn value(&self) -> usize {
        (self.in_wall.value() * 16usize)
            + (self.open.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.powered.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 32usize {
            return None;
        }
        let in_wall = bool::from_value(val / 16usize).unwrap();
        val -= (in_wall.value() - 0usize) * 16usize;
        let open = bool::from_value(val / 8usize).unwrap();
        val -= (open.value() - 0usize) * 8usize;
        let facing = BirchFenceGateFacing::from_value(val / 2usize).unwrap();
        val -= (facing.value() - 0usize) * 2usize;
        let powered = bool::from_value(val / 1usize).unwrap();
        val -= (powered.value() - 0usize) * 1usize;
        Some(Self {
            in_wall,
            open,
            facing,
            powered,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct JungleFenceGateData {
    pub facing: JungleFenceGateFacing,
    pub open: bool,
    pub powered: bool,
    pub in_wall: bool,
}
impl JungleFenceGateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: JungleFenceGateFacing::from_snake_case(map.get("facing")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            in_wall: bool::from_snake_case(map.get("in_wall")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("in_wall".to_string(), self.in_wall.to_snake_case());
        m
    }
}
impl Default for JungleFenceGateData {
    fn default() -> Self {
        Self {
            facing: JungleFenceGateFacing::North,
            open: false,
            powered: false,
            in_wall: false,
        }
    }
}
impl Value for JungleFenceGateData {
    fn value(&self) -> usize {
        (self.facing.value() * 8usize)
            + (self.open.value() * 4usize)
            + (self.powered.value() * 2usize)
            + (self.in_wall.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 32usize {
            return None;
        }
        let facing = JungleFenceGateFacing::from_value(val / 8usize).unwrap();
        val -= (facing.value() - 0usize) * 8usize;
        let open = bool::from_value(val / 4usize).unwrap();
        val -= (open.value() - 0usize) * 4usize;
        let powered = bool::from_value(val / 2usize).unwrap();
        val -= (powered.value() - 0usize) * 2usize;
        let in_wall = bool::from_value(val / 1usize).unwrap();
        val -= (in_wall.value() - 0usize) * 1usize;
        Some(Self {
            facing,
            open,
            powered,
            in_wall,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AcaciaFenceGateData {
    pub open: bool,
    pub powered: bool,
    pub in_wall: bool,
    pub facing: AcaciaFenceGateFacing,
}
impl AcaciaFenceGateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            open: bool::from_snake_case(map.get("open")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            in_wall: bool::from_snake_case(map.get("in_wall")?)?,
            facing: AcaciaFenceGateFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("in_wall".to_string(), self.in_wall.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for AcaciaFenceGateData {
    fn default() -> Self {
        Self {
            open: false,
            powered: false,
            in_wall: false,
            facing: AcaciaFenceGateFacing::North,
        }
    }
}
impl Value for AcaciaFenceGateData {
    fn value(&self) -> usize {
        (self.open.value() * 16usize)
            + (self.powered.value() * 8usize)
            + (self.in_wall.value() * 4usize)
            + (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 32usize {
            return None;
        }
        let open = bool::from_value(val / 16usize).unwrap();
        val -= (open.value() - 0usize) * 16usize;
        let powered = bool::from_value(val / 8usize).unwrap();
        val -= (powered.value() - 0usize) * 8usize;
        let in_wall = bool::from_value(val / 4usize).unwrap();
        val -= (in_wall.value() - 0usize) * 4usize;
        let facing = AcaciaFenceGateFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self {
            open,
            powered,
            in_wall,
            facing,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DarkOakFenceGateData {
    pub facing: DarkOakFenceGateFacing,
    pub in_wall: bool,
    pub powered: bool,
    pub open: bool,
}
impl DarkOakFenceGateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: DarkOakFenceGateFacing::from_snake_case(map.get("facing")?)?,
            in_wall: bool::from_snake_case(map.get("in_wall")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("in_wall".to_string(), self.in_wall.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m
    }
}
impl Default for DarkOakFenceGateData {
    fn default() -> Self {
        Self {
            facing: DarkOakFenceGateFacing::North,
            in_wall: false,
            powered: false,
            open: false,
        }
    }
}
impl Value for DarkOakFenceGateData {
    fn value(&self) -> usize {
        (self.facing.value() * 8usize)
            + (self.in_wall.value() * 4usize)
            + (self.powered.value() * 2usize)
            + (self.open.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 32usize {
            return None;
        }
        let facing = DarkOakFenceGateFacing::from_value(val / 8usize).unwrap();
        val -= (facing.value() - 0usize) * 8usize;
        let in_wall = bool::from_value(val / 4usize).unwrap();
        val -= (in_wall.value() - 0usize) * 4usize;
        let powered = bool::from_value(val / 2usize).unwrap();
        val -= (powered.value() - 0usize) * 2usize;
        let open = bool::from_value(val / 1usize).unwrap();
        val -= (open.value() - 0usize) * 1usize;
        Some(Self {
            facing,
            in_wall,
            powered,
            open,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SpruceFenceData {
    pub waterlogged: bool,
    pub north: bool,
    pub west: bool,
    pub east: bool,
    pub south: bool,
}
impl SpruceFenceData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m
    }
}
impl Default for SpruceFenceData {
    fn default() -> Self {
        Self {
            waterlogged: false,
            north: false,
            west: false,
            east: false,
            south: false,
        }
    }
}
impl Value for SpruceFenceData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 16usize)
            + (self.north.value() * 8usize)
            + (self.west.value() * 4usize)
            + (self.east.value() * 2usize)
            + (self.south.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 32usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 16usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 16usize;
        let north = bool::from_value(val / 8usize).unwrap();
        val -= (north.value() - 0usize) * 8usize;
        let west = bool::from_value(val / 4usize).unwrap();
        val -= (west.value() - 0usize) * 4usize;
        let east = bool::from_value(val / 2usize).unwrap();
        val -= (east.value() - 0usize) * 2usize;
        let south = bool::from_value(val / 1usize).unwrap();
        val -= (south.value() - 0usize) * 1usize;
        Some(Self {
            waterlogged,
            north,
            west,
            east,
            south,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BirchFenceData {
    pub south: bool,
    pub east: bool,
    pub north: bool,
    pub waterlogged: bool,
    pub west: bool,
}
impl BirchFenceData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            south: bool::from_snake_case(map.get("south")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m
    }
}
impl Default for BirchFenceData {
    fn default() -> Self {
        Self {
            south: false,
            east: false,
            north: false,
            waterlogged: false,
            west: false,
        }
    }
}
impl Value for BirchFenceData {
    fn value(&self) -> usize {
        (self.south.value() * 16usize)
            + (self.east.value() * 8usize)
            + (self.north.value() * 4usize)
            + (self.waterlogged.value() * 2usize)
            + (self.west.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 32usize {
            return None;
        }
        let south = bool::from_value(val / 16usize).unwrap();
        val -= (south.value() - 0usize) * 16usize;
        let east = bool::from_value(val / 8usize).unwrap();
        val -= (east.value() - 0usize) * 8usize;
        let north = bool::from_value(val / 4usize).unwrap();
        val -= (north.value() - 0usize) * 4usize;
        let waterlogged = bool::from_value(val / 2usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 2usize;
        let west = bool::from_value(val / 1usize).unwrap();
        val -= (west.value() - 0usize) * 1usize;
        Some(Self {
            south,
            east,
            north,
            waterlogged,
            west,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct JungleFenceData {
    pub south: bool,
    pub north: bool,
    pub waterlogged: bool,
    pub west: bool,
    pub east: bool,
}
impl JungleFenceData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            south: bool::from_snake_case(map.get("south")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m
    }
}
impl Default for JungleFenceData {
    fn default() -> Self {
        Self {
            south: false,
            north: false,
            waterlogged: false,
            west: false,
            east: false,
        }
    }
}
impl Value for JungleFenceData {
    fn value(&self) -> usize {
        (self.south.value() * 16usize)
            + (self.north.value() * 8usize)
            + (self.waterlogged.value() * 4usize)
            + (self.west.value() * 2usize)
            + (self.east.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 32usize {
            return None;
        }
        let south = bool::from_value(val / 16usize).unwrap();
        val -= (south.value() - 0usize) * 16usize;
        let north = bool::from_value(val / 8usize).unwrap();
        val -= (north.value() - 0usize) * 8usize;
        let waterlogged = bool::from_value(val / 4usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 4usize;
        let west = bool::from_value(val / 2usize).unwrap();
        val -= (west.value() - 0usize) * 2usize;
        let east = bool::from_value(val / 1usize).unwrap();
        val -= (east.value() - 0usize) * 1usize;
        Some(Self {
            south,
            north,
            waterlogged,
            west,
            east,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AcaciaFenceData {
    pub north: bool,
    pub east: bool,
    pub south: bool,
    pub waterlogged: bool,
    pub west: bool,
}
impl AcaciaFenceData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            north: bool::from_snake_case(map.get("north")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m
    }
}
impl Default for AcaciaFenceData {
    fn default() -> Self {
        Self {
            north: false,
            east: false,
            south: false,
            waterlogged: false,
            west: false,
        }
    }
}
impl Value for AcaciaFenceData {
    fn value(&self) -> usize {
        (self.north.value() * 16usize)
            + (self.east.value() * 8usize)
            + (self.south.value() * 4usize)
            + (self.waterlogged.value() * 2usize)
            + (self.west.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 32usize {
            return None;
        }
        let north = bool::from_value(val / 16usize).unwrap();
        val -= (north.value() - 0usize) * 16usize;
        let east = bool::from_value(val / 8usize).unwrap();
        val -= (east.value() - 0usize) * 8usize;
        let south = bool::from_value(val / 4usize).unwrap();
        val -= (south.value() - 0usize) * 4usize;
        let waterlogged = bool::from_value(val / 2usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 2usize;
        let west = bool::from_value(val / 1usize).unwrap();
        val -= (west.value() - 0usize) * 1usize;
        Some(Self {
            north,
            east,
            south,
            waterlogged,
            west,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DarkOakFenceData {
    pub north: bool,
    pub waterlogged: bool,
    pub east: bool,
    pub south: bool,
    pub west: bool,
}
impl DarkOakFenceData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            north: bool::from_snake_case(map.get("north")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m
    }
}
impl Default for DarkOakFenceData {
    fn default() -> Self {
        Self {
            north: false,
            waterlogged: false,
            east: false,
            south: false,
            west: false,
        }
    }
}
impl Value for DarkOakFenceData {
    fn value(&self) -> usize {
        (self.north.value() * 16usize)
            + (self.waterlogged.value() * 8usize)
            + (self.east.value() * 4usize)
            + (self.south.value() * 2usize)
            + (self.west.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 32usize {
            return None;
        }
        let north = bool::from_value(val / 16usize).unwrap();
        val -= (north.value() - 0usize) * 16usize;
        let waterlogged = bool::from_value(val / 8usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 8usize;
        let east = bool::from_value(val / 4usize).unwrap();
        val -= (east.value() - 0usize) * 4usize;
        let south = bool::from_value(val / 2usize).unwrap();
        val -= (south.value() - 0usize) * 2usize;
        let west = bool::from_value(val / 1usize).unwrap();
        val -= (west.value() - 0usize) * 1usize;
        Some(Self {
            north,
            waterlogged,
            east,
            south,
            west,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SpruceDoorData {
    pub powered: bool,
    pub hinge: SpruceDoorHinge,
    pub facing: SpruceDoorFacing,
    pub half: SpruceDoorHalf,
    pub open: bool,
}
impl SpruceDoorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
            hinge: SpruceDoorHinge::from_snake_case(map.get("hinge")?)?,
            facing: SpruceDoorFacing::from_snake_case(map.get("facing")?)?,
            half: SpruceDoorHalf::from_snake_case(map.get("half")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("hinge".to_string(), self.hinge.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m
    }
}
impl Default for SpruceDoorData {
    fn default() -> Self {
        Self {
            powered: false,
            hinge: SpruceDoorHinge::Left,
            facing: SpruceDoorFacing::North,
            half: SpruceDoorHalf::Lower,
            open: false,
        }
    }
}
impl Value for SpruceDoorData {
    fn value(&self) -> usize {
        (self.powered.value() * 32usize)
            + (self.hinge.value() * 16usize)
            + (self.facing.value() * 4usize)
            + (self.half.value() * 2usize)
            + (self.open.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 64usize {
            return None;
        }
        let powered = bool::from_value(val / 32usize).unwrap();
        val -= (powered.value() - 0usize) * 32usize;
        let hinge = SpruceDoorHinge::from_value(val / 16usize).unwrap();
        val -= (hinge.value() - 0usize) * 16usize;
        let facing = SpruceDoorFacing::from_value(val / 4usize).unwrap();
        val -= (facing.value() - 0usize) * 4usize;
        let half = SpruceDoorHalf::from_value(val / 2usize).unwrap();
        val -= (half.value() - 0usize) * 2usize;
        let open = bool::from_value(val / 1usize).unwrap();
        val -= (open.value() - 0usize) * 1usize;
        Some(Self {
            powered,
            hinge,
            facing,
            half,
            open,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BirchDoorData {
    pub half: BirchDoorHalf,
    pub open: bool,
    pub powered: bool,
    pub hinge: BirchDoorHinge,
    pub facing: BirchDoorFacing,
}
impl BirchDoorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            half: BirchDoorHalf::from_snake_case(map.get("half")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            hinge: BirchDoorHinge::from_snake_case(map.get("hinge")?)?,
            facing: BirchDoorFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("hinge".to_string(), self.hinge.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for BirchDoorData {
    fn default() -> Self {
        Self {
            half: BirchDoorHalf::Lower,
            open: false,
            powered: false,
            hinge: BirchDoorHinge::Left,
            facing: BirchDoorFacing::North,
        }
    }
}
impl Value for BirchDoorData {
    fn value(&self) -> usize {
        (self.half.value() * 32usize)
            + (self.open.value() * 16usize)
            + (self.powered.value() * 8usize)
            + (self.hinge.value() * 4usize)
            + (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 64usize {
            return None;
        }
        let half = BirchDoorHalf::from_value(val / 32usize).unwrap();
        val -= (half.value() - 0usize) * 32usize;
        let open = bool::from_value(val / 16usize).unwrap();
        val -= (open.value() - 0usize) * 16usize;
        let powered = bool::from_value(val / 8usize).unwrap();
        val -= (powered.value() - 0usize) * 8usize;
        let hinge = BirchDoorHinge::from_value(val / 4usize).unwrap();
        val -= (hinge.value() - 0usize) * 4usize;
        let facing = BirchDoorFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self {
            half,
            open,
            powered,
            hinge,
            facing,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct JungleDoorData {
    pub facing: JungleDoorFacing,
    pub powered: bool,
    pub open: bool,
    pub hinge: JungleDoorHinge,
    pub half: JungleDoorHalf,
}
impl JungleDoorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: JungleDoorFacing::from_snake_case(map.get("facing")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
            hinge: JungleDoorHinge::from_snake_case(map.get("hinge")?)?,
            half: JungleDoorHalf::from_snake_case(map.get("half")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("hinge".to_string(), self.hinge.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m
    }
}
impl Default for JungleDoorData {
    fn default() -> Self {
        Self {
            facing: JungleDoorFacing::North,
            powered: false,
            open: false,
            hinge: JungleDoorHinge::Left,
            half: JungleDoorHalf::Lower,
        }
    }
}
impl Value for JungleDoorData {
    fn value(&self) -> usize {
        (self.facing.value() * 16usize)
            + (self.powered.value() * 8usize)
            + (self.open.value() * 4usize)
            + (self.hinge.value() * 2usize)
            + (self.half.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 64usize {
            return None;
        }
        let facing = JungleDoorFacing::from_value(val / 16usize).unwrap();
        val -= (facing.value() - 0usize) * 16usize;
        let powered = bool::from_value(val / 8usize).unwrap();
        val -= (powered.value() - 0usize) * 8usize;
        let open = bool::from_value(val / 4usize).unwrap();
        val -= (open.value() - 0usize) * 4usize;
        let hinge = JungleDoorHinge::from_value(val / 2usize).unwrap();
        val -= (hinge.value() - 0usize) * 2usize;
        let half = JungleDoorHalf::from_value(val / 1usize).unwrap();
        val -= (half.value() - 0usize) * 1usize;
        Some(Self {
            facing,
            powered,
            open,
            hinge,
            half,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AcaciaDoorData {
    pub facing: AcaciaDoorFacing,
    pub half: AcaciaDoorHalf,
    pub hinge: AcaciaDoorHinge,
    pub open: bool,
    pub powered: bool,
}
impl AcaciaDoorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: AcaciaDoorFacing::from_snake_case(map.get("facing")?)?,
            half: AcaciaDoorHalf::from_snake_case(map.get("half")?)?,
            hinge: AcaciaDoorHinge::from_snake_case(map.get("hinge")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("hinge".to_string(), self.hinge.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Default for AcaciaDoorData {
    fn default() -> Self {
        Self {
            facing: AcaciaDoorFacing::North,
            half: AcaciaDoorHalf::Lower,
            hinge: AcaciaDoorHinge::Left,
            open: false,
            powered: false,
        }
    }
}
impl Value for AcaciaDoorData {
    fn value(&self) -> usize {
        (self.facing.value() * 16usize)
            + (self.half.value() * 8usize)
            + (self.hinge.value() * 4usize)
            + (self.open.value() * 2usize)
            + (self.powered.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 64usize {
            return None;
        }
        let facing = AcaciaDoorFacing::from_value(val / 16usize).unwrap();
        val -= (facing.value() - 0usize) * 16usize;
        let half = AcaciaDoorHalf::from_value(val / 8usize).unwrap();
        val -= (half.value() - 0usize) * 8usize;
        let hinge = AcaciaDoorHinge::from_value(val / 4usize).unwrap();
        val -= (hinge.value() - 0usize) * 4usize;
        let open = bool::from_value(val / 2usize).unwrap();
        val -= (open.value() - 0usize) * 2usize;
        let powered = bool::from_value(val / 1usize).unwrap();
        val -= (powered.value() - 0usize) * 1usize;
        Some(Self {
            facing,
            half,
            hinge,
            open,
            powered,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DarkOakDoorData {
    pub facing: DarkOakDoorFacing,
    pub powered: bool,
    pub half: DarkOakDoorHalf,
    pub open: bool,
    pub hinge: DarkOakDoorHinge,
}
impl DarkOakDoorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: DarkOakDoorFacing::from_snake_case(map.get("facing")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            half: DarkOakDoorHalf::from_snake_case(map.get("half")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
            hinge: DarkOakDoorHinge::from_snake_case(map.get("hinge")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("hinge".to_string(), self.hinge.to_snake_case());
        m
    }
}
impl Default for DarkOakDoorData {
    fn default() -> Self {
        Self {
            facing: DarkOakDoorFacing::North,
            powered: false,
            half: DarkOakDoorHalf::Lower,
            open: false,
            hinge: DarkOakDoorHinge::Left,
        }
    }
}
impl Value for DarkOakDoorData {
    fn value(&self) -> usize {
        (self.facing.value() * 16usize)
            + (self.powered.value() * 8usize)
            + (self.half.value() * 4usize)
            + (self.open.value() * 2usize)
            + (self.hinge.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 64usize {
            return None;
        }
        let facing = DarkOakDoorFacing::from_value(val / 16usize).unwrap();
        val -= (facing.value() - 0usize) * 16usize;
        let powered = bool::from_value(val / 8usize).unwrap();
        val -= (powered.value() - 0usize) * 8usize;
        let half = DarkOakDoorHalf::from_value(val / 4usize).unwrap();
        val -= (half.value() - 0usize) * 4usize;
        let open = bool::from_value(val / 2usize).unwrap();
        val -= (open.value() - 0usize) * 2usize;
        let hinge = DarkOakDoorHinge::from_value(val / 1usize).unwrap();
        val -= (hinge.value() - 0usize) * 1usize;
        Some(Self {
            facing,
            powered,
            half,
            open,
            hinge,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct EndRodData {
    pub facing: EndRodFacing,
}
impl EndRodData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: EndRodFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for EndRodData {
    fn default() -> Self {
        Self {
            facing: EndRodFacing::Up,
        }
    }
}
impl Value for EndRodData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 6usize {
            return None;
        }
        let facing = EndRodFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ChorusPlantData {
    pub north: bool,
    pub down: bool,
    pub south: bool,
    pub east: bool,
    pub up: bool,
    pub west: bool,
}
impl ChorusPlantData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            north: bool::from_snake_case(map.get("north")?)?,
            down: bool::from_snake_case(map.get("down")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            up: bool::from_snake_case(map.get("up")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("down".to_string(), self.down.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("up".to_string(), self.up.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m
    }
}
impl Default for ChorusPlantData {
    fn default() -> Self {
        Self {
            north: false,
            down: false,
            south: false,
            east: false,
            up: false,
            west: false,
        }
    }
}
impl Value for ChorusPlantData {
    fn value(&self) -> usize {
        (self.north.value() * 32usize)
            + (self.down.value() * 16usize)
            + (self.south.value() * 8usize)
            + (self.east.value() * 4usize)
            + (self.up.value() * 2usize)
            + (self.west.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 64usize {
            return None;
        }
        let north = bool::from_value(val / 32usize).unwrap();
        val -= (north.value() - 0usize) * 32usize;
        let down = bool::from_value(val / 16usize).unwrap();
        val -= (down.value() - 0usize) * 16usize;
        let south = bool::from_value(val / 8usize).unwrap();
        val -= (south.value() - 0usize) * 8usize;
        let east = bool::from_value(val / 4usize).unwrap();
        val -= (east.value() - 0usize) * 4usize;
        let up = bool::from_value(val / 2usize).unwrap();
        val -= (up.value() - 0usize) * 2usize;
        let west = bool::from_value(val / 1usize).unwrap();
        val -= (west.value() - 0usize) * 1usize;
        Some(Self {
            north,
            down,
            south,
            east,
            up,
            west,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ChorusFlowerData {
    pub age: i32,
}
impl ChorusFlowerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            age: i32::from_snake_case(map.get("age")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("age".to_string(), self.age.to_snake_case());
        m
    }
}
impl Default for ChorusFlowerData {
    fn default() -> Self {
        Self { age: 0 }
    }
}
impl Value for ChorusFlowerData {
    fn value(&self) -> usize {
        (self.age.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 6usize {
            return None;
        }
        let age = i32::from_value(val / 1usize).unwrap();
        val -= (age.value() - 0usize) * 1usize;
        Some(Self { age })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PurpurPillarData {
    pub axis: PurpurPillarAxis,
}
impl PurpurPillarData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: PurpurPillarAxis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Default for PurpurPillarData {
    fn default() -> Self {
        Self {
            axis: PurpurPillarAxis::Y,
        }
    }
}
impl Value for PurpurPillarData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 3usize {
            return None;
        }
        let axis = PurpurPillarAxis::from_value(val / 1usize).unwrap();
        val -= (axis.value() - 0usize) * 1usize;
        Some(Self { axis })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PurpurStairsData {
    pub waterlogged: bool,
    pub half: PurpurStairsHalf,
    pub facing: PurpurStairsFacing,
    pub shape: PurpurStairsShape,
}
impl PurpurStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            half: PurpurStairsHalf::from_snake_case(map.get("half")?)?,
            facing: PurpurStairsFacing::from_snake_case(map.get("facing")?)?,
            shape: PurpurStairsShape::from_snake_case(map.get("shape")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m
    }
}
impl Default for PurpurStairsData {
    fn default() -> Self {
        Self {
            waterlogged: false,
            half: PurpurStairsHalf::Bottom,
            facing: PurpurStairsFacing::North,
            shape: PurpurStairsShape::Straight,
        }
    }
}
impl Value for PurpurStairsData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 40usize)
            + (self.half.value() * 20usize)
            + (self.facing.value() * 5usize)
            + (self.shape.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 80usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 40usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 40usize;
        let half = PurpurStairsHalf::from_value(val / 20usize).unwrap();
        val -= (half.value() - 0usize) * 20usize;
        let facing = PurpurStairsFacing::from_value(val / 5usize).unwrap();
        val -= (facing.value() - 0usize) * 5usize;
        let shape = PurpurStairsShape::from_value(val / 1usize).unwrap();
        val -= (shape.value() - 0usize) * 1usize;
        Some(Self {
            waterlogged,
            half,
            facing,
            shape,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BeetrootsData {
    pub age: i32,
}
impl BeetrootsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            age: i32::from_snake_case(map.get("age")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("age".to_string(), self.age.to_snake_case());
        m
    }
}
impl Default for BeetrootsData {
    fn default() -> Self {
        Self { age: 0 }
    }
}
impl Value for BeetrootsData {
    fn value(&self) -> usize {
        (self.age.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let age = i32::from_value(val / 1usize).unwrap();
        val -= (age.value() - 0usize) * 1usize;
        Some(Self { age })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RepeatingCommandBlockData {
    pub facing: RepeatingCommandBlockFacing,
    pub conditional: bool,
}
impl RepeatingCommandBlockData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: RepeatingCommandBlockFacing::from_snake_case(map.get("facing")?)?,
            conditional: bool::from_snake_case(map.get("conditional")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("conditional".to_string(), self.conditional.to_snake_case());
        m
    }
}
impl Default for RepeatingCommandBlockData {
    fn default() -> Self {
        Self {
            facing: RepeatingCommandBlockFacing::North,
            conditional: false,
        }
    }
}
impl Value for RepeatingCommandBlockData {
    fn value(&self) -> usize {
        (self.facing.value() * 2usize) + (self.conditional.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 12usize {
            return None;
        }
        let facing = RepeatingCommandBlockFacing::from_value(val / 2usize).unwrap();
        val -= (facing.value() - 0usize) * 2usize;
        let conditional = bool::from_value(val / 1usize).unwrap();
        val -= (conditional.value() - 0usize) * 1usize;
        Some(Self {
            facing,
            conditional,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ChainCommandBlockData {
    pub facing: ChainCommandBlockFacing,
    pub conditional: bool,
}
impl ChainCommandBlockData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: ChainCommandBlockFacing::from_snake_case(map.get("facing")?)?,
            conditional: bool::from_snake_case(map.get("conditional")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("conditional".to_string(), self.conditional.to_snake_case());
        m
    }
}
impl Default for ChainCommandBlockData {
    fn default() -> Self {
        Self {
            facing: ChainCommandBlockFacing::North,
            conditional: false,
        }
    }
}
impl Value for ChainCommandBlockData {
    fn value(&self) -> usize {
        (self.facing.value() * 2usize) + (self.conditional.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 12usize {
            return None;
        }
        let facing = ChainCommandBlockFacing::from_value(val / 2usize).unwrap();
        val -= (facing.value() - 0usize) * 2usize;
        let conditional = bool::from_value(val / 1usize).unwrap();
        val -= (conditional.value() - 0usize) * 1usize;
        Some(Self {
            facing,
            conditional,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct FrostedIceData {
    pub age: i32,
}
impl FrostedIceData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            age: i32::from_snake_case(map.get("age")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("age".to_string(), self.age.to_snake_case());
        m
    }
}
impl Default for FrostedIceData {
    fn default() -> Self {
        Self { age: 0 }
    }
}
impl Value for FrostedIceData {
    fn value(&self) -> usize {
        (self.age.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let age = i32::from_value(val / 1usize).unwrap();
        val -= (age.value() - 0usize) * 1usize;
        Some(Self { age })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BoneBlockData {
    pub axis: BoneBlockAxis,
}
impl BoneBlockData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: BoneBlockAxis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Default for BoneBlockData {
    fn default() -> Self {
        Self {
            axis: BoneBlockAxis::Y,
        }
    }
}
impl Value for BoneBlockData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 3usize {
            return None;
        }
        let axis = BoneBlockAxis::from_value(val / 1usize).unwrap();
        val -= (axis.value() - 0usize) * 1usize;
        Some(Self { axis })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ObserverData {
    pub facing: ObserverFacing,
    pub powered: bool,
}
impl ObserverData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: ObserverFacing::from_snake_case(map.get("facing")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Default for ObserverData {
    fn default() -> Self {
        Self {
            facing: ObserverFacing::South,
            powered: false,
        }
    }
}
impl Value for ObserverData {
    fn value(&self) -> usize {
        (self.facing.value() * 2usize) + (self.powered.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 12usize {
            return None;
        }
        let facing = ObserverFacing::from_value(val / 2usize).unwrap();
        val -= (facing.value() - 0usize) * 2usize;
        let powered = bool::from_value(val / 1usize).unwrap();
        val -= (powered.value() - 0usize) * 1usize;
        Some(Self { facing, powered })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ShulkerBoxData {
    pub facing: ShulkerBoxFacing,
}
impl ShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: ShulkerBoxFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for ShulkerBoxData {
    fn default() -> Self {
        Self {
            facing: ShulkerBoxFacing::Up,
        }
    }
}
impl Value for ShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 6usize {
            return None;
        }
        let facing = ShulkerBoxFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct WhiteShulkerBoxData {
    pub facing: WhiteShulkerBoxFacing,
}
impl WhiteShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: WhiteShulkerBoxFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for WhiteShulkerBoxData {
    fn default() -> Self {
        Self {
            facing: WhiteShulkerBoxFacing::Up,
        }
    }
}
impl Value for WhiteShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 6usize {
            return None;
        }
        let facing = WhiteShulkerBoxFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OrangeShulkerBoxData {
    pub facing: OrangeShulkerBoxFacing,
}
impl OrangeShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: OrangeShulkerBoxFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for OrangeShulkerBoxData {
    fn default() -> Self {
        Self {
            facing: OrangeShulkerBoxFacing::Up,
        }
    }
}
impl Value for OrangeShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 6usize {
            return None;
        }
        let facing = OrangeShulkerBoxFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct MagentaShulkerBoxData {
    pub facing: MagentaShulkerBoxFacing,
}
impl MagentaShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: MagentaShulkerBoxFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for MagentaShulkerBoxData {
    fn default() -> Self {
        Self {
            facing: MagentaShulkerBoxFacing::Up,
        }
    }
}
impl Value for MagentaShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 6usize {
            return None;
        }
        let facing = MagentaShulkerBoxFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LightBlueShulkerBoxData {
    pub facing: LightBlueShulkerBoxFacing,
}
impl LightBlueShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: LightBlueShulkerBoxFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for LightBlueShulkerBoxData {
    fn default() -> Self {
        Self {
            facing: LightBlueShulkerBoxFacing::Up,
        }
    }
}
impl Value for LightBlueShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 6usize {
            return None;
        }
        let facing = LightBlueShulkerBoxFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct YellowShulkerBoxData {
    pub facing: YellowShulkerBoxFacing,
}
impl YellowShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: YellowShulkerBoxFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for YellowShulkerBoxData {
    fn default() -> Self {
        Self {
            facing: YellowShulkerBoxFacing::Up,
        }
    }
}
impl Value for YellowShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 6usize {
            return None;
        }
        let facing = YellowShulkerBoxFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LimeShulkerBoxData {
    pub facing: LimeShulkerBoxFacing,
}
impl LimeShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: LimeShulkerBoxFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for LimeShulkerBoxData {
    fn default() -> Self {
        Self {
            facing: LimeShulkerBoxFacing::Up,
        }
    }
}
impl Value for LimeShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 6usize {
            return None;
        }
        let facing = LimeShulkerBoxFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PinkShulkerBoxData {
    pub facing: PinkShulkerBoxFacing,
}
impl PinkShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: PinkShulkerBoxFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for PinkShulkerBoxData {
    fn default() -> Self {
        Self {
            facing: PinkShulkerBoxFacing::Up,
        }
    }
}
impl Value for PinkShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 6usize {
            return None;
        }
        let facing = PinkShulkerBoxFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct GrayShulkerBoxData {
    pub facing: GrayShulkerBoxFacing,
}
impl GrayShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: GrayShulkerBoxFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for GrayShulkerBoxData {
    fn default() -> Self {
        Self {
            facing: GrayShulkerBoxFacing::Up,
        }
    }
}
impl Value for GrayShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 6usize {
            return None;
        }
        let facing = GrayShulkerBoxFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LightGrayShulkerBoxData {
    pub facing: LightGrayShulkerBoxFacing,
}
impl LightGrayShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: LightGrayShulkerBoxFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for LightGrayShulkerBoxData {
    fn default() -> Self {
        Self {
            facing: LightGrayShulkerBoxFacing::Up,
        }
    }
}
impl Value for LightGrayShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 6usize {
            return None;
        }
        let facing = LightGrayShulkerBoxFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CyanShulkerBoxData {
    pub facing: CyanShulkerBoxFacing,
}
impl CyanShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: CyanShulkerBoxFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for CyanShulkerBoxData {
    fn default() -> Self {
        Self {
            facing: CyanShulkerBoxFacing::Up,
        }
    }
}
impl Value for CyanShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 6usize {
            return None;
        }
        let facing = CyanShulkerBoxFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PurpleShulkerBoxData {
    pub facing: PurpleShulkerBoxFacing,
}
impl PurpleShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: PurpleShulkerBoxFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for PurpleShulkerBoxData {
    fn default() -> Self {
        Self {
            facing: PurpleShulkerBoxFacing::Up,
        }
    }
}
impl Value for PurpleShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 6usize {
            return None;
        }
        let facing = PurpleShulkerBoxFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BlueShulkerBoxData {
    pub facing: BlueShulkerBoxFacing,
}
impl BlueShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: BlueShulkerBoxFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for BlueShulkerBoxData {
    fn default() -> Self {
        Self {
            facing: BlueShulkerBoxFacing::Up,
        }
    }
}
impl Value for BlueShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 6usize {
            return None;
        }
        let facing = BlueShulkerBoxFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BrownShulkerBoxData {
    pub facing: BrownShulkerBoxFacing,
}
impl BrownShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: BrownShulkerBoxFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for BrownShulkerBoxData {
    fn default() -> Self {
        Self {
            facing: BrownShulkerBoxFacing::Up,
        }
    }
}
impl Value for BrownShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 6usize {
            return None;
        }
        let facing = BrownShulkerBoxFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct GreenShulkerBoxData {
    pub facing: GreenShulkerBoxFacing,
}
impl GreenShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: GreenShulkerBoxFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for GreenShulkerBoxData {
    fn default() -> Self {
        Self {
            facing: GreenShulkerBoxFacing::Up,
        }
    }
}
impl Value for GreenShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 6usize {
            return None;
        }
        let facing = GreenShulkerBoxFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RedShulkerBoxData {
    pub facing: RedShulkerBoxFacing,
}
impl RedShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: RedShulkerBoxFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for RedShulkerBoxData {
    fn default() -> Self {
        Self {
            facing: RedShulkerBoxFacing::Up,
        }
    }
}
impl Value for RedShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 6usize {
            return None;
        }
        let facing = RedShulkerBoxFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BlackShulkerBoxData {
    pub facing: BlackShulkerBoxFacing,
}
impl BlackShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: BlackShulkerBoxFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for BlackShulkerBoxData {
    fn default() -> Self {
        Self {
            facing: BlackShulkerBoxFacing::Up,
        }
    }
}
impl Value for BlackShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 6usize {
            return None;
        }
        let facing = BlackShulkerBoxFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct WhiteGlazedTerracottaData {
    pub facing: WhiteGlazedTerracottaFacing,
}
impl WhiteGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: WhiteGlazedTerracottaFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for WhiteGlazedTerracottaData {
    fn default() -> Self {
        Self {
            facing: WhiteGlazedTerracottaFacing::North,
        }
    }
}
impl Value for WhiteGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = WhiteGlazedTerracottaFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OrangeGlazedTerracottaData {
    pub facing: OrangeGlazedTerracottaFacing,
}
impl OrangeGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: OrangeGlazedTerracottaFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for OrangeGlazedTerracottaData {
    fn default() -> Self {
        Self {
            facing: OrangeGlazedTerracottaFacing::North,
        }
    }
}
impl Value for OrangeGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = OrangeGlazedTerracottaFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct MagentaGlazedTerracottaData {
    pub facing: MagentaGlazedTerracottaFacing,
}
impl MagentaGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: MagentaGlazedTerracottaFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for MagentaGlazedTerracottaData {
    fn default() -> Self {
        Self {
            facing: MagentaGlazedTerracottaFacing::North,
        }
    }
}
impl Value for MagentaGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = MagentaGlazedTerracottaFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LightBlueGlazedTerracottaData {
    pub facing: LightBlueGlazedTerracottaFacing,
}
impl LightBlueGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: LightBlueGlazedTerracottaFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for LightBlueGlazedTerracottaData {
    fn default() -> Self {
        Self {
            facing: LightBlueGlazedTerracottaFacing::North,
        }
    }
}
impl Value for LightBlueGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = LightBlueGlazedTerracottaFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct YellowGlazedTerracottaData {
    pub facing: YellowGlazedTerracottaFacing,
}
impl YellowGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: YellowGlazedTerracottaFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for YellowGlazedTerracottaData {
    fn default() -> Self {
        Self {
            facing: YellowGlazedTerracottaFacing::North,
        }
    }
}
impl Value for YellowGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = YellowGlazedTerracottaFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LimeGlazedTerracottaData {
    pub facing: LimeGlazedTerracottaFacing,
}
impl LimeGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: LimeGlazedTerracottaFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for LimeGlazedTerracottaData {
    fn default() -> Self {
        Self {
            facing: LimeGlazedTerracottaFacing::North,
        }
    }
}
impl Value for LimeGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = LimeGlazedTerracottaFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PinkGlazedTerracottaData {
    pub facing: PinkGlazedTerracottaFacing,
}
impl PinkGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: PinkGlazedTerracottaFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for PinkGlazedTerracottaData {
    fn default() -> Self {
        Self {
            facing: PinkGlazedTerracottaFacing::North,
        }
    }
}
impl Value for PinkGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = PinkGlazedTerracottaFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct GrayGlazedTerracottaData {
    pub facing: GrayGlazedTerracottaFacing,
}
impl GrayGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: GrayGlazedTerracottaFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for GrayGlazedTerracottaData {
    fn default() -> Self {
        Self {
            facing: GrayGlazedTerracottaFacing::North,
        }
    }
}
impl Value for GrayGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = GrayGlazedTerracottaFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LightGrayGlazedTerracottaData {
    pub facing: LightGrayGlazedTerracottaFacing,
}
impl LightGrayGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: LightGrayGlazedTerracottaFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for LightGrayGlazedTerracottaData {
    fn default() -> Self {
        Self {
            facing: LightGrayGlazedTerracottaFacing::North,
        }
    }
}
impl Value for LightGrayGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = LightGrayGlazedTerracottaFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CyanGlazedTerracottaData {
    pub facing: CyanGlazedTerracottaFacing,
}
impl CyanGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: CyanGlazedTerracottaFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for CyanGlazedTerracottaData {
    fn default() -> Self {
        Self {
            facing: CyanGlazedTerracottaFacing::North,
        }
    }
}
impl Value for CyanGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = CyanGlazedTerracottaFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PurpleGlazedTerracottaData {
    pub facing: PurpleGlazedTerracottaFacing,
}
impl PurpleGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: PurpleGlazedTerracottaFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for PurpleGlazedTerracottaData {
    fn default() -> Self {
        Self {
            facing: PurpleGlazedTerracottaFacing::North,
        }
    }
}
impl Value for PurpleGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = PurpleGlazedTerracottaFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BlueGlazedTerracottaData {
    pub facing: BlueGlazedTerracottaFacing,
}
impl BlueGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: BlueGlazedTerracottaFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for BlueGlazedTerracottaData {
    fn default() -> Self {
        Self {
            facing: BlueGlazedTerracottaFacing::North,
        }
    }
}
impl Value for BlueGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = BlueGlazedTerracottaFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BrownGlazedTerracottaData {
    pub facing: BrownGlazedTerracottaFacing,
}
impl BrownGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: BrownGlazedTerracottaFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for BrownGlazedTerracottaData {
    fn default() -> Self {
        Self {
            facing: BrownGlazedTerracottaFacing::North,
        }
    }
}
impl Value for BrownGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = BrownGlazedTerracottaFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct GreenGlazedTerracottaData {
    pub facing: GreenGlazedTerracottaFacing,
}
impl GreenGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: GreenGlazedTerracottaFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for GreenGlazedTerracottaData {
    fn default() -> Self {
        Self {
            facing: GreenGlazedTerracottaFacing::North,
        }
    }
}
impl Value for GreenGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = GreenGlazedTerracottaFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RedGlazedTerracottaData {
    pub facing: RedGlazedTerracottaFacing,
}
impl RedGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: RedGlazedTerracottaFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for RedGlazedTerracottaData {
    fn default() -> Self {
        Self {
            facing: RedGlazedTerracottaFacing::North,
        }
    }
}
impl Value for RedGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = RedGlazedTerracottaFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BlackGlazedTerracottaData {
    pub facing: BlackGlazedTerracottaFacing,
}
impl BlackGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: BlackGlazedTerracottaFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for BlackGlazedTerracottaData {
    fn default() -> Self {
        Self {
            facing: BlackGlazedTerracottaFacing::North,
        }
    }
}
impl Value for BlackGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let facing = BlackGlazedTerracottaFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self { facing })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct KelpData {
    pub age: i32,
}
impl KelpData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            age: i32::from_snake_case(map.get("age")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("age".to_string(), self.age.to_snake_case());
        m
    }
}
impl Default for KelpData {
    fn default() -> Self {
        Self { age: 0 }
    }
}
impl Value for KelpData {
    fn value(&self) -> usize {
        (self.age.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 26usize {
            return None;
        }
        let age = i32::from_value(val / 1usize).unwrap();
        val -= (age.value() - 0usize) * 1usize;
        Some(Self { age })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct TurtleEggData {
    pub eggs: i32,
    pub hatch: i32,
}
impl TurtleEggData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            eggs: i32::from_snake_case(map.get("eggs")?)?,
            hatch: i32::from_snake_case(map.get("hatch")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("eggs".to_string(), self.eggs.to_snake_case());
        m.insert("hatch".to_string(), self.hatch.to_snake_case());
        m
    }
}
impl Default for TurtleEggData {
    fn default() -> Self {
        Self { eggs: 1, hatch: 0 }
    }
}
impl Value for TurtleEggData {
    fn value(&self) -> usize {
        ((self.eggs.value() - 1) * 3usize) + (self.hatch.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 12usize {
            return None;
        }
        let eggs = i32::from_value(val / 3usize).unwrap() + 1i32;
        val -= (eggs.value() - 1usize) * 3usize;
        let hatch = i32::from_value(val / 1usize).unwrap();
        val -= (hatch.value() - 0usize) * 1usize;
        Some(Self { eggs, hatch })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadTubeCoralData {
    pub waterlogged: bool,
}
impl DeadTubeCoralData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for DeadTubeCoralData {
    fn default() -> Self {
        Self { waterlogged: true }
    }
}
impl Value for DeadTubeCoralData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self { waterlogged })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadBrainCoralData {
    pub waterlogged: bool,
}
impl DeadBrainCoralData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for DeadBrainCoralData {
    fn default() -> Self {
        Self { waterlogged: true }
    }
}
impl Value for DeadBrainCoralData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self { waterlogged })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadBubbleCoralData {
    pub waterlogged: bool,
}
impl DeadBubbleCoralData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for DeadBubbleCoralData {
    fn default() -> Self {
        Self { waterlogged: true }
    }
}
impl Value for DeadBubbleCoralData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self { waterlogged })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadFireCoralData {
    pub waterlogged: bool,
}
impl DeadFireCoralData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for DeadFireCoralData {
    fn default() -> Self {
        Self { waterlogged: true }
    }
}
impl Value for DeadFireCoralData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self { waterlogged })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadHornCoralData {
    pub waterlogged: bool,
}
impl DeadHornCoralData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for DeadHornCoralData {
    fn default() -> Self {
        Self { waterlogged: true }
    }
}
impl Value for DeadHornCoralData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self { waterlogged })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct TubeCoralData {
    pub waterlogged: bool,
}
impl TubeCoralData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for TubeCoralData {
    fn default() -> Self {
        Self { waterlogged: true }
    }
}
impl Value for TubeCoralData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self { waterlogged })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BrainCoralData {
    pub waterlogged: bool,
}
impl BrainCoralData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for BrainCoralData {
    fn default() -> Self {
        Self { waterlogged: true }
    }
}
impl Value for BrainCoralData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self { waterlogged })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BubbleCoralData {
    pub waterlogged: bool,
}
impl BubbleCoralData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for BubbleCoralData {
    fn default() -> Self {
        Self { waterlogged: true }
    }
}
impl Value for BubbleCoralData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self { waterlogged })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct FireCoralData {
    pub waterlogged: bool,
}
impl FireCoralData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for FireCoralData {
    fn default() -> Self {
        Self { waterlogged: true }
    }
}
impl Value for FireCoralData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self { waterlogged })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct HornCoralData {
    pub waterlogged: bool,
}
impl HornCoralData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for HornCoralData {
    fn default() -> Self {
        Self { waterlogged: true }
    }
}
impl Value for HornCoralData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self { waterlogged })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadTubeCoralWallFanData {
    pub facing: DeadTubeCoralWallFanFacing,
    pub waterlogged: bool,
}
impl DeadTubeCoralWallFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: DeadTubeCoralWallFanFacing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for DeadTubeCoralWallFanData {
    fn default() -> Self {
        Self {
            facing: DeadTubeCoralWallFanFacing::North,
            waterlogged: true,
        }
    }
}
impl Value for DeadTubeCoralWallFanData {
    fn value(&self) -> usize {
        (self.facing.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 8usize {
            return None;
        }
        let facing = DeadTubeCoralWallFanFacing::from_value(val / 2usize).unwrap();
        val -= (facing.value() - 0usize) * 2usize;
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self {
            facing,
            waterlogged,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadBrainCoralWallFanData {
    pub facing: DeadBrainCoralWallFanFacing,
    pub waterlogged: bool,
}
impl DeadBrainCoralWallFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: DeadBrainCoralWallFanFacing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for DeadBrainCoralWallFanData {
    fn default() -> Self {
        Self {
            facing: DeadBrainCoralWallFanFacing::North,
            waterlogged: true,
        }
    }
}
impl Value for DeadBrainCoralWallFanData {
    fn value(&self) -> usize {
        (self.facing.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 8usize {
            return None;
        }
        let facing = DeadBrainCoralWallFanFacing::from_value(val / 2usize).unwrap();
        val -= (facing.value() - 0usize) * 2usize;
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self {
            facing,
            waterlogged,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadBubbleCoralWallFanData {
    pub waterlogged: bool,
    pub facing: DeadBubbleCoralWallFanFacing,
}
impl DeadBubbleCoralWallFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            facing: DeadBubbleCoralWallFanFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for DeadBubbleCoralWallFanData {
    fn default() -> Self {
        Self {
            waterlogged: true,
            facing: DeadBubbleCoralWallFanFacing::North,
        }
    }
}
impl Value for DeadBubbleCoralWallFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 4usize) + (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 8usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 4usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 4usize;
        let facing = DeadBubbleCoralWallFanFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self {
            waterlogged,
            facing,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadFireCoralWallFanData {
    pub waterlogged: bool,
    pub facing: DeadFireCoralWallFanFacing,
}
impl DeadFireCoralWallFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            facing: DeadFireCoralWallFanFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for DeadFireCoralWallFanData {
    fn default() -> Self {
        Self {
            waterlogged: true,
            facing: DeadFireCoralWallFanFacing::North,
        }
    }
}
impl Value for DeadFireCoralWallFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 4usize) + (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 8usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 4usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 4usize;
        let facing = DeadFireCoralWallFanFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self {
            waterlogged,
            facing,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadHornCoralWallFanData {
    pub facing: DeadHornCoralWallFanFacing,
    pub waterlogged: bool,
}
impl DeadHornCoralWallFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: DeadHornCoralWallFanFacing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for DeadHornCoralWallFanData {
    fn default() -> Self {
        Self {
            facing: DeadHornCoralWallFanFacing::North,
            waterlogged: true,
        }
    }
}
impl Value for DeadHornCoralWallFanData {
    fn value(&self) -> usize {
        (self.facing.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 8usize {
            return None;
        }
        let facing = DeadHornCoralWallFanFacing::from_value(val / 2usize).unwrap();
        val -= (facing.value() - 0usize) * 2usize;
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self {
            facing,
            waterlogged,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct TubeCoralWallFanData {
    pub facing: TubeCoralWallFanFacing,
    pub waterlogged: bool,
}
impl TubeCoralWallFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: TubeCoralWallFanFacing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for TubeCoralWallFanData {
    fn default() -> Self {
        Self {
            facing: TubeCoralWallFanFacing::North,
            waterlogged: true,
        }
    }
}
impl Value for TubeCoralWallFanData {
    fn value(&self) -> usize {
        (self.facing.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 8usize {
            return None;
        }
        let facing = TubeCoralWallFanFacing::from_value(val / 2usize).unwrap();
        val -= (facing.value() - 0usize) * 2usize;
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self {
            facing,
            waterlogged,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BrainCoralWallFanData {
    pub waterlogged: bool,
    pub facing: BrainCoralWallFanFacing,
}
impl BrainCoralWallFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            facing: BrainCoralWallFanFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for BrainCoralWallFanData {
    fn default() -> Self {
        Self {
            waterlogged: true,
            facing: BrainCoralWallFanFacing::North,
        }
    }
}
impl Value for BrainCoralWallFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 4usize) + (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 8usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 4usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 4usize;
        let facing = BrainCoralWallFanFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self {
            waterlogged,
            facing,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BubbleCoralWallFanData {
    pub facing: BubbleCoralWallFanFacing,
    pub waterlogged: bool,
}
impl BubbleCoralWallFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: BubbleCoralWallFanFacing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for BubbleCoralWallFanData {
    fn default() -> Self {
        Self {
            facing: BubbleCoralWallFanFacing::North,
            waterlogged: true,
        }
    }
}
impl Value for BubbleCoralWallFanData {
    fn value(&self) -> usize {
        (self.facing.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 8usize {
            return None;
        }
        let facing = BubbleCoralWallFanFacing::from_value(val / 2usize).unwrap();
        val -= (facing.value() - 0usize) * 2usize;
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self {
            facing,
            waterlogged,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct FireCoralWallFanData {
    pub waterlogged: bool,
    pub facing: FireCoralWallFanFacing,
}
impl FireCoralWallFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            facing: FireCoralWallFanFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for FireCoralWallFanData {
    fn default() -> Self {
        Self {
            waterlogged: true,
            facing: FireCoralWallFanFacing::North,
        }
    }
}
impl Value for FireCoralWallFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 4usize) + (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 8usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 4usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 4usize;
        let facing = FireCoralWallFanFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self {
            waterlogged,
            facing,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct HornCoralWallFanData {
    pub waterlogged: bool,
    pub facing: HornCoralWallFanFacing,
}
impl HornCoralWallFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            facing: HornCoralWallFanFacing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Default for HornCoralWallFanData {
    fn default() -> Self {
        Self {
            waterlogged: true,
            facing: HornCoralWallFanFacing::North,
        }
    }
}
impl Value for HornCoralWallFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 4usize) + (self.facing.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 8usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 4usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 4usize;
        let facing = HornCoralWallFanFacing::from_value(val / 1usize).unwrap();
        val -= (facing.value() - 0usize) * 1usize;
        Some(Self {
            waterlogged,
            facing,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadTubeCoralFanData {
    pub waterlogged: bool,
}
impl DeadTubeCoralFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for DeadTubeCoralFanData {
    fn default() -> Self {
        Self { waterlogged: true }
    }
}
impl Value for DeadTubeCoralFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self { waterlogged })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadBrainCoralFanData {
    pub waterlogged: bool,
}
impl DeadBrainCoralFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for DeadBrainCoralFanData {
    fn default() -> Self {
        Self { waterlogged: true }
    }
}
impl Value for DeadBrainCoralFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self { waterlogged })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadBubbleCoralFanData {
    pub waterlogged: bool,
}
impl DeadBubbleCoralFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for DeadBubbleCoralFanData {
    fn default() -> Self {
        Self { waterlogged: true }
    }
}
impl Value for DeadBubbleCoralFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self { waterlogged })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadFireCoralFanData {
    pub waterlogged: bool,
}
impl DeadFireCoralFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for DeadFireCoralFanData {
    fn default() -> Self {
        Self { waterlogged: true }
    }
}
impl Value for DeadFireCoralFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self { waterlogged })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadHornCoralFanData {
    pub waterlogged: bool,
}
impl DeadHornCoralFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for DeadHornCoralFanData {
    fn default() -> Self {
        Self { waterlogged: true }
    }
}
impl Value for DeadHornCoralFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self { waterlogged })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct TubeCoralFanData {
    pub waterlogged: bool,
}
impl TubeCoralFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for TubeCoralFanData {
    fn default() -> Self {
        Self { waterlogged: true }
    }
}
impl Value for TubeCoralFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self { waterlogged })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BrainCoralFanData {
    pub waterlogged: bool,
}
impl BrainCoralFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for BrainCoralFanData {
    fn default() -> Self {
        Self { waterlogged: true }
    }
}
impl Value for BrainCoralFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self { waterlogged })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BubbleCoralFanData {
    pub waterlogged: bool,
}
impl BubbleCoralFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for BubbleCoralFanData {
    fn default() -> Self {
        Self { waterlogged: true }
    }
}
impl Value for BubbleCoralFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self { waterlogged })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct FireCoralFanData {
    pub waterlogged: bool,
}
impl FireCoralFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for FireCoralFanData {
    fn default() -> Self {
        Self { waterlogged: true }
    }
}
impl Value for FireCoralFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self { waterlogged })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct HornCoralFanData {
    pub waterlogged: bool,
}
impl HornCoralFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for HornCoralFanData {
    fn default() -> Self {
        Self { waterlogged: true }
    }
}
impl Value for HornCoralFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self { waterlogged })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SeaPickleData {
    pub pickles: i32,
    pub waterlogged: bool,
}
impl SeaPickleData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            pickles: i32::from_snake_case(map.get("pickles")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("pickles".to_string(), self.pickles.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for SeaPickleData {
    fn default() -> Self {
        Self {
            pickles: 1,
            waterlogged: true,
        }
    }
}
impl Value for SeaPickleData {
    fn value(&self) -> usize {
        ((self.pickles.value() - 1) * 2usize) + (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 8usize {
            return None;
        }
        let pickles = i32::from_value(val / 2usize).unwrap() + 1i32;
        val -= (pickles.value() - 1usize) * 2usize;
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self {
            pickles,
            waterlogged,
        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ConduitData {
    pub waterlogged: bool,
}
impl ConduitData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Default for ConduitData {
    fn default() -> Self {
        Self { waterlogged: true }
    }
}
impl Value for ConduitData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let waterlogged = bool::from_value(val / 1usize).unwrap();
        val -= (waterlogged.value() - 0usize) * 1usize;
        Some(Self { waterlogged })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BubbleColumnData {
    pub drag: bool,
}
impl BubbleColumnData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            drag: bool::from_snake_case(map.get("drag")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("drag".to_string(), self.drag.to_snake_case());
        m
    }
}
impl Default for BubbleColumnData {
    fn default() -> Self {
        Self { drag: true }
    }
}
impl Value for BubbleColumnData {
    fn value(&self) -> usize {
        (self.drag.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 2usize {
            return None;
        }
        let drag = bool::from_value(val / 1usize).unwrap();
        val -= (drag.value() - 0usize) * 1usize;
        Some(Self { drag })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StructureBlockData {
    pub mode: StructureBlockMode,
}
impl StructureBlockData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            mode: StructureBlockMode::from_snake_case(map.get("mode")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("mode".to_string(), self.mode.to_snake_case());
        m
    }
}
impl Default for StructureBlockData {
    fn default() -> Self {
        Self {
            mode: StructureBlockMode::Save,
        }
    }
}
impl Value for StructureBlockData {
    fn value(&self) -> usize {
        (self.mode.value() * 1usize)
    }
    #[allow(warnings)]
    fn from_value(mut val: usize) -> Option<Self> {
        if val >= 4usize {
            return None;
        }
        let mode = StructureBlockMode::from_value(val / 1usize).unwrap();
        val -= (mode.value() - 0usize) * 1usize;
        Some(Self { mode })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum OakLogAxis {
    X,
    Y,
    Z,
}
impl Value for OakLogAxis {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum SpruceLogAxis {
    X,
    Y,
    Z,
}
impl Value for SpruceLogAxis {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum BirchLogAxis {
    X,
    Y,
    Z,
}
impl Value for BirchLogAxis {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum JungleLogAxis {
    X,
    Y,
    Z,
}
impl Value for JungleLogAxis {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum AcaciaLogAxis {
    X,
    Y,
    Z,
}
impl Value for AcaciaLogAxis {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum DarkOakLogAxis {
    X,
    Y,
    Z,
}
impl Value for DarkOakLogAxis {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum StrippedSpruceLogAxis {
    X,
    Y,
    Z,
}
impl Value for StrippedSpruceLogAxis {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum StrippedBirchLogAxis {
    X,
    Y,
    Z,
}
impl Value for StrippedBirchLogAxis {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum StrippedJungleLogAxis {
    X,
    Y,
    Z,
}
impl Value for StrippedJungleLogAxis {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum StrippedAcaciaLogAxis {
    X,
    Y,
    Z,
}
impl Value for StrippedAcaciaLogAxis {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum StrippedDarkOakLogAxis {
    X,
    Y,
    Z,
}
impl Value for StrippedDarkOakLogAxis {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum StrippedOakLogAxis {
    X,
    Y,
    Z,
}
impl Value for StrippedOakLogAxis {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum OakWoodAxis {
    X,
    Y,
    Z,
}
impl Value for OakWoodAxis {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum SpruceWoodAxis {
    X,
    Y,
    Z,
}
impl Value for SpruceWoodAxis {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum BirchWoodAxis {
    X,
    Y,
    Z,
}
impl Value for BirchWoodAxis {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum JungleWoodAxis {
    X,
    Y,
    Z,
}
impl Value for JungleWoodAxis {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum AcaciaWoodAxis {
    X,
    Y,
    Z,
}
impl Value for AcaciaWoodAxis {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum DarkOakWoodAxis {
    X,
    Y,
    Z,
}
impl Value for DarkOakWoodAxis {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum StrippedOakWoodAxis {
    X,
    Y,
    Z,
}
impl Value for StrippedOakWoodAxis {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum StrippedSpruceWoodAxis {
    X,
    Y,
    Z,
}
impl Value for StrippedSpruceWoodAxis {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum StrippedBirchWoodAxis {
    X,
    Y,
    Z,
}
impl Value for StrippedBirchWoodAxis {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum StrippedJungleWoodAxis {
    X,
    Y,
    Z,
}
impl Value for StrippedJungleWoodAxis {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum StrippedAcaciaWoodAxis {
    X,
    Y,
    Z,
}
impl Value for StrippedAcaciaWoodAxis {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum StrippedDarkOakWoodAxis {
    X,
    Y,
    Z,
}
impl Value for StrippedDarkOakWoodAxis {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum DispenserFacing {
    North,
    East,
    South,
    West,
    Up,
    Down,
}
impl Value for DispenserFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum NoteBlockInstrument {
    Harp,
    Basedrum,
    Snare,
    Hat,
    Bass,
    Flute,
    Bell,
    Guitar,
    Chime,
    Xylophone,
}
impl Value for NoteBlockInstrument {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum WhiteBedPart {
    Head,
    Foot,
}
impl Value for WhiteBedPart {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum WhiteBedFacing {
    North,
    South,
    West,
    East,
}
impl Value for WhiteBedFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum OrangeBedFacing {
    North,
    South,
    West,
    East,
}
impl Value for OrangeBedFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum OrangeBedPart {
    Head,
    Foot,
}
impl Value for OrangeBedPart {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum MagentaBedFacing {
    North,
    South,
    West,
    East,
}
impl Value for MagentaBedFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum MagentaBedPart {
    Head,
    Foot,
}
impl Value for MagentaBedPart {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum LightBlueBedPart {
    Head,
    Foot,
}
impl Value for LightBlueBedPart {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum LightBlueBedFacing {
    North,
    South,
    West,
    East,
}
impl Value for LightBlueBedFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum YellowBedPart {
    Head,
    Foot,
}
impl Value for YellowBedPart {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum YellowBedFacing {
    North,
    South,
    West,
    East,
}
impl Value for YellowBedFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum LimeBedPart {
    Head,
    Foot,
}
impl Value for LimeBedPart {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum LimeBedFacing {
    North,
    South,
    West,
    East,
}
impl Value for LimeBedFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum PinkBedPart {
    Head,
    Foot,
}
impl Value for PinkBedPart {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum PinkBedFacing {
    North,
    South,
    West,
    East,
}
impl Value for PinkBedFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum GrayBedFacing {
    North,
    South,
    West,
    East,
}
impl Value for GrayBedFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum GrayBedPart {
    Head,
    Foot,
}
impl Value for GrayBedPart {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum LightGrayBedFacing {
    North,
    South,
    West,
    East,
}
impl Value for LightGrayBedFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum LightGrayBedPart {
    Head,
    Foot,
}
impl Value for LightGrayBedPart {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum CyanBedPart {
    Head,
    Foot,
}
impl Value for CyanBedPart {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum CyanBedFacing {
    North,
    South,
    West,
    East,
}
impl Value for CyanBedFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum PurpleBedPart {
    Head,
    Foot,
}
impl Value for PurpleBedPart {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum PurpleBedFacing {
    North,
    South,
    West,
    East,
}
impl Value for PurpleBedFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum BlueBedFacing {
    North,
    South,
    West,
    East,
}
impl Value for BlueBedFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum BlueBedPart {
    Head,
    Foot,
}
impl Value for BlueBedPart {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum BrownBedFacing {
    North,
    South,
    West,
    East,
}
impl Value for BrownBedFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum BrownBedPart {
    Head,
    Foot,
}
impl Value for BrownBedPart {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum GreenBedFacing {
    North,
    South,
    West,
    East,
}
impl Value for GreenBedFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum GreenBedPart {
    Head,
    Foot,
}
impl Value for GreenBedPart {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum RedBedPart {
    Head,
    Foot,
}
impl Value for RedBedPart {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum RedBedFacing {
    North,
    South,
    West,
    East,
}
impl Value for RedBedFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum BlackBedPart {
    Head,
    Foot,
}
impl Value for BlackBedPart {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum BlackBedFacing {
    North,
    South,
    West,
    East,
}
impl Value for BlackBedFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum PoweredRailShape {
    NorthSouth,
    EastWest,
    AscendingEast,
    AscendingWest,
    AscendingNorth,
    AscendingSouth,
}
impl Value for PoweredRailShape {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum DetectorRailShape {
    NorthSouth,
    EastWest,
    AscendingEast,
    AscendingWest,
    AscendingNorth,
    AscendingSouth,
}
impl Value for DetectorRailShape {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum StickyPistonFacing {
    North,
    East,
    South,
    West,
    Up,
    Down,
}
impl Value for StickyPistonFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum TallSeagrassHalf {
    Upper,
    Lower,
}
impl Value for TallSeagrassHalf {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum PistonFacing {
    North,
    East,
    South,
    West,
    Up,
    Down,
}
impl Value for PistonFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum PistonHeadType {
    Normal,
    Sticky,
}
impl Value for PistonHeadType {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum PistonHeadFacing {
    North,
    East,
    South,
    West,
    Up,
    Down,
}
impl Value for PistonHeadFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum MovingPistonFacing {
    North,
    East,
    South,
    West,
    Up,
    Down,
}
impl Value for MovingPistonFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum MovingPistonType {
    Normal,
    Sticky,
}
impl Value for MovingPistonType {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum WallTorchFacing {
    North,
    South,
    West,
    East,
}
impl Value for WallTorchFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum OakStairsHalf {
    Top,
    Bottom,
}
impl Value for OakStairsHalf {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum OakStairsShape {
    Straight,
    InnerLeft,
    InnerRight,
    OuterLeft,
    OuterRight,
}
impl Value for OakStairsShape {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum OakStairsFacing {
    North,
    South,
    West,
    East,
}
impl Value for OakStairsFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum ChestType {
    Single,
    Left,
    Right,
}
impl Value for ChestType {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum ChestFacing {
    North,
    South,
    West,
    East,
}
impl Value for ChestFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum RedstoneWireWest {
    Up,
    Side,
    None,
}
impl Value for RedstoneWireWest {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum RedstoneWireNorth {
    Up,
    Side,
    None,
}
impl Value for RedstoneWireNorth {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum RedstoneWireEast {
    Up,
    Side,
    None,
}
impl Value for RedstoneWireEast {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum RedstoneWireSouth {
    Up,
    Side,
    None,
}
impl Value for RedstoneWireSouth {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum FurnaceFacing {
    North,
    South,
    West,
    East,
}
impl Value for FurnaceFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum OakDoorHalf {
    Upper,
    Lower,
}
impl Value for OakDoorHalf {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum OakDoorFacing {
    North,
    South,
    West,
    East,
}
impl Value for OakDoorFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum OakDoorHinge {
    Left,
    Right,
}
impl Value for OakDoorHinge {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum LadderFacing {
    North,
    South,
    West,
    East,
}
impl Value for LadderFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum RailShape {
    NorthSouth,
    EastWest,
    AscendingEast,
    AscendingWest,
    AscendingNorth,
    AscendingSouth,
    SouthEast,
    SouthWest,
    NorthWest,
    NorthEast,
}
impl Value for RailShape {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum CobblestoneStairsFacing {
    North,
    South,
    West,
    East,
}
impl Value for CobblestoneStairsFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum CobblestoneStairsHalf {
    Top,
    Bottom,
}
impl Value for CobblestoneStairsHalf {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum CobblestoneStairsShape {
    Straight,
    InnerLeft,
    InnerRight,
    OuterLeft,
    OuterRight,
}
impl Value for CobblestoneStairsShape {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum WallSignFacing {
    North,
    South,
    West,
    East,
}
impl Value for WallSignFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum LeverFacing {
    North,
    South,
    West,
    East,
}
impl Value for LeverFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum LeverFace {
    Floor,
    Wall,
    Ceiling,
}
impl Value for LeverFace {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum IronDoorHalf {
    Upper,
    Lower,
}
impl Value for IronDoorHalf {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum IronDoorFacing {
    North,
    South,
    West,
    East,
}
impl Value for IronDoorFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum IronDoorHinge {
    Left,
    Right,
}
impl Value for IronDoorHinge {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum RedstoneWallTorchFacing {
    North,
    South,
    West,
    East,
}
impl Value for RedstoneWallTorchFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum StoneButtonFace {
    Floor,
    Wall,
    Ceiling,
}
impl Value for StoneButtonFace {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum StoneButtonFacing {
    North,
    South,
    West,
    East,
}
impl Value for StoneButtonFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum NetherPortalAxis {
    X,
    Z,
}
impl Value for NetherPortalAxis {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum CarvedPumpkinFacing {
    North,
    South,
    West,
    East,
}
impl Value for CarvedPumpkinFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum JackOLanternFacing {
    North,
    South,
    West,
    East,
}
impl Value for JackOLanternFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum RepeaterFacing {
    North,
    South,
    West,
    East,
}
impl Value for RepeaterFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum OakTrapdoorHalf {
    Top,
    Bottom,
}
impl Value for OakTrapdoorHalf {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum OakTrapdoorFacing {
    North,
    South,
    West,
    East,
}
impl Value for OakTrapdoorFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum SpruceTrapdoorFacing {
    North,
    South,
    West,
    East,
}
impl Value for SpruceTrapdoorFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum SpruceTrapdoorHalf {
    Top,
    Bottom,
}
impl Value for SpruceTrapdoorHalf {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum BirchTrapdoorHalf {
    Top,
    Bottom,
}
impl Value for BirchTrapdoorHalf {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum BirchTrapdoorFacing {
    North,
    South,
    West,
    East,
}
impl Value for BirchTrapdoorFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum JungleTrapdoorFacing {
    North,
    South,
    West,
    East,
}
impl Value for JungleTrapdoorFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum JungleTrapdoorHalf {
    Top,
    Bottom,
}
impl Value for JungleTrapdoorHalf {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum AcaciaTrapdoorHalf {
    Top,
    Bottom,
}
impl Value for AcaciaTrapdoorHalf {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum AcaciaTrapdoorFacing {
    North,
    South,
    West,
    East,
}
impl Value for AcaciaTrapdoorFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum DarkOakTrapdoorFacing {
    North,
    South,
    West,
    East,
}
impl Value for DarkOakTrapdoorFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum DarkOakTrapdoorHalf {
    Top,
    Bottom,
}
impl Value for DarkOakTrapdoorHalf {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum AttachedPumpkinStemFacing {
    North,
    South,
    West,
    East,
}
impl Value for AttachedPumpkinStemFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum AttachedMelonStemFacing {
    North,
    South,
    West,
    East,
}
impl Value for AttachedMelonStemFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum OakFenceGateFacing {
    North,
    South,
    West,
    East,
}
impl Value for OakFenceGateFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum BrickStairsShape {
    Straight,
    InnerLeft,
    InnerRight,
    OuterLeft,
    OuterRight,
}
impl Value for BrickStairsShape {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum BrickStairsHalf {
    Top,
    Bottom,
}
impl Value for BrickStairsHalf {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum BrickStairsFacing {
    North,
    South,
    West,
    East,
}
impl Value for BrickStairsFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum StoneBrickStairsFacing {
    North,
    South,
    West,
    East,
}
impl Value for StoneBrickStairsFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum StoneBrickStairsHalf {
    Top,
    Bottom,
}
impl Value for StoneBrickStairsHalf {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum StoneBrickStairsShape {
    Straight,
    InnerLeft,
    InnerRight,
    OuterLeft,
    OuterRight,
}
impl Value for StoneBrickStairsShape {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum NetherBrickStairsShape {
    Straight,
    InnerLeft,
    InnerRight,
    OuterLeft,
    OuterRight,
}
impl Value for NetherBrickStairsShape {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum NetherBrickStairsHalf {
    Top,
    Bottom,
}
impl Value for NetherBrickStairsHalf {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum NetherBrickStairsFacing {
    North,
    South,
    West,
    East,
}
impl Value for NetherBrickStairsFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum EndPortalFrameFacing {
    North,
    South,
    West,
    East,
}
impl Value for EndPortalFrameFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum CocoaFacing {
    North,
    South,
    West,
    East,
}
impl Value for CocoaFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum SandstoneStairsHalf {
    Top,
    Bottom,
}
impl Value for SandstoneStairsHalf {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum SandstoneStairsFacing {
    North,
    South,
    West,
    East,
}
impl Value for SandstoneStairsFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum SandstoneStairsShape {
    Straight,
    InnerLeft,
    InnerRight,
    OuterLeft,
    OuterRight,
}
impl Value for SandstoneStairsShape {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum EnderChestFacing {
    North,
    South,
    West,
    East,
}
impl Value for EnderChestFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum TripwireHookFacing {
    North,
    South,
    West,
    East,
}
impl Value for TripwireHookFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum SpruceStairsFacing {
    North,
    South,
    West,
    East,
}
impl Value for SpruceStairsFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum SpruceStairsHalf {
    Top,
    Bottom,
}
impl Value for SpruceStairsHalf {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum SpruceStairsShape {
    Straight,
    InnerLeft,
    InnerRight,
    OuterLeft,
    OuterRight,
}
impl Value for SpruceStairsShape {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum BirchStairsShape {
    Straight,
    InnerLeft,
    InnerRight,
    OuterLeft,
    OuterRight,
}
impl Value for BirchStairsShape {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum BirchStairsHalf {
    Top,
    Bottom,
}
impl Value for BirchStairsHalf {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum BirchStairsFacing {
    North,
    South,
    West,
    East,
}
impl Value for BirchStairsFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum JungleStairsFacing {
    North,
    South,
    West,
    East,
}
impl Value for JungleStairsFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum JungleStairsShape {
    Straight,
    InnerLeft,
    InnerRight,
    OuterLeft,
    OuterRight,
}
impl Value for JungleStairsShape {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum JungleStairsHalf {
    Top,
    Bottom,
}
impl Value for JungleStairsHalf {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum CommandBlockFacing {
    North,
    East,
    South,
    West,
    Up,
    Down,
}
impl Value for CommandBlockFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum OakButtonFacing {
    North,
    South,
    West,
    East,
}
impl Value for OakButtonFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum OakButtonFace {
    Floor,
    Wall,
    Ceiling,
}
impl Value for OakButtonFace {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum SpruceButtonFacing {
    North,
    South,
    West,
    East,
}
impl Value for SpruceButtonFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum SpruceButtonFace {
    Floor,
    Wall,
    Ceiling,
}
impl Value for SpruceButtonFace {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum BirchButtonFace {
    Floor,
    Wall,
    Ceiling,
}
impl Value for BirchButtonFace {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum BirchButtonFacing {
    North,
    South,
    West,
    East,
}
impl Value for BirchButtonFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum JungleButtonFace {
    Floor,
    Wall,
    Ceiling,
}
impl Value for JungleButtonFace {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum JungleButtonFacing {
    North,
    South,
    West,
    East,
}
impl Value for JungleButtonFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum AcaciaButtonFacing {
    North,
    South,
    West,
    East,
}
impl Value for AcaciaButtonFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum AcaciaButtonFace {
    Floor,
    Wall,
    Ceiling,
}
impl Value for AcaciaButtonFace {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum DarkOakButtonFace {
    Floor,
    Wall,
    Ceiling,
}
impl Value for DarkOakButtonFace {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum DarkOakButtonFacing {
    North,
    South,
    West,
    East,
}
impl Value for DarkOakButtonFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum SkeletonWallSkullFacing {
    North,
    South,
    West,
    East,
}
impl Value for SkeletonWallSkullFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum WitherSkeletonWallSkullFacing {
    North,
    South,
    West,
    East,
}
impl Value for WitherSkeletonWallSkullFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum ZombieWallHeadFacing {
    North,
    South,
    West,
    East,
}
impl Value for ZombieWallHeadFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum PlayerWallHeadFacing {
    North,
    South,
    West,
    East,
}
impl Value for PlayerWallHeadFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum CreeperWallHeadFacing {
    North,
    South,
    West,
    East,
}
impl Value for CreeperWallHeadFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum DragonWallHeadFacing {
    North,
    South,
    West,
    East,
}
impl Value for DragonWallHeadFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum AnvilFacing {
    North,
    South,
    West,
    East,
}
impl Value for AnvilFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum ChippedAnvilFacing {
    North,
    South,
    West,
    East,
}
impl Value for ChippedAnvilFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum DamagedAnvilFacing {
    North,
    South,
    West,
    East,
}
impl Value for DamagedAnvilFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum TrappedChestType {
    Single,
    Left,
    Right,
}
impl Value for TrappedChestType {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum TrappedChestFacing {
    North,
    South,
    West,
    East,
}
impl Value for TrappedChestFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum ComparatorMode {
    Compare,
    Subtract,
}
impl Value for ComparatorMode {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum ComparatorFacing {
    North,
    South,
    West,
    East,
}
impl Value for ComparatorFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum HopperFacing {
    Down,
    North,
    South,
    West,
    East,
}
impl Value for HopperFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum QuartzPillarAxis {
    X,
    Y,
    Z,
}
impl Value for QuartzPillarAxis {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum QuartzStairsShape {
    Straight,
    InnerLeft,
    InnerRight,
    OuterLeft,
    OuterRight,
}
impl Value for QuartzStairsShape {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum QuartzStairsHalf {
    Top,
    Bottom,
}
impl Value for QuartzStairsHalf {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum QuartzStairsFacing {
    North,
    South,
    West,
    East,
}
impl Value for QuartzStairsFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum ActivatorRailShape {
    NorthSouth,
    EastWest,
    AscendingEast,
    AscendingWest,
    AscendingNorth,
    AscendingSouth,
}
impl Value for ActivatorRailShape {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum DropperFacing {
    North,
    East,
    South,
    West,
    Up,
    Down,
}
impl Value for DropperFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum AcaciaStairsFacing {
    North,
    South,
    West,
    East,
}
impl Value for AcaciaStairsFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum AcaciaStairsHalf {
    Top,
    Bottom,
}
impl Value for AcaciaStairsHalf {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum AcaciaStairsShape {
    Straight,
    InnerLeft,
    InnerRight,
    OuterLeft,
    OuterRight,
}
impl Value for AcaciaStairsShape {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum DarkOakStairsHalf {
    Top,
    Bottom,
}
impl Value for DarkOakStairsHalf {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum DarkOakStairsFacing {
    North,
    South,
    West,
    East,
}
impl Value for DarkOakStairsFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum DarkOakStairsShape {
    Straight,
    InnerLeft,
    InnerRight,
    OuterLeft,
    OuterRight,
}
impl Value for DarkOakStairsShape {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum IronTrapdoorFacing {
    North,
    South,
    West,
    East,
}
impl Value for IronTrapdoorFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum IronTrapdoorHalf {
    Top,
    Bottom,
}
impl Value for IronTrapdoorHalf {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum PrismarineStairsHalf {
    Top,
    Bottom,
}
impl Value for PrismarineStairsHalf {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum PrismarineStairsFacing {
    North,
    South,
    West,
    East,
}
impl Value for PrismarineStairsFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum PrismarineStairsShape {
    Straight,
    InnerLeft,
    InnerRight,
    OuterLeft,
    OuterRight,
}
impl Value for PrismarineStairsShape {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum PrismarineBrickStairsFacing {
    North,
    South,
    West,
    East,
}
impl Value for PrismarineBrickStairsFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum PrismarineBrickStairsHalf {
    Top,
    Bottom,
}
impl Value for PrismarineBrickStairsHalf {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum PrismarineBrickStairsShape {
    Straight,
    InnerLeft,
    InnerRight,
    OuterLeft,
    OuterRight,
}
impl Value for PrismarineBrickStairsShape {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum DarkPrismarineStairsHalf {
    Top,
    Bottom,
}
impl Value for DarkPrismarineStairsHalf {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum DarkPrismarineStairsShape {
    Straight,
    InnerLeft,
    InnerRight,
    OuterLeft,
    OuterRight,
}
impl Value for DarkPrismarineStairsShape {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum DarkPrismarineStairsFacing {
    North,
    South,
    West,
    East,
}
impl Value for DarkPrismarineStairsFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum PrismarineSlabType {
    Top,
    Bottom,
    Double,
}
impl Value for PrismarineSlabType {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum PrismarineBrickSlabType {
    Top,
    Bottom,
    Double,
}
impl Value for PrismarineBrickSlabType {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum DarkPrismarineSlabType {
    Top,
    Bottom,
    Double,
}
impl Value for DarkPrismarineSlabType {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum HayBlockAxis {
    X,
    Y,
    Z,
}
impl Value for HayBlockAxis {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum SunflowerHalf {
    Upper,
    Lower,
}
impl Value for SunflowerHalf {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum LilacHalf {
    Upper,
    Lower,
}
impl Value for LilacHalf {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum RoseBushHalf {
    Upper,
    Lower,
}
impl Value for RoseBushHalf {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum PeonyHalf {
    Upper,
    Lower,
}
impl Value for PeonyHalf {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum TallGrassHalf {
    Upper,
    Lower,
}
impl Value for TallGrassHalf {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum LargeFernHalf {
    Upper,
    Lower,
}
impl Value for LargeFernHalf {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum WhiteWallBannerFacing {
    North,
    South,
    West,
    East,
}
impl Value for WhiteWallBannerFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum OrangeWallBannerFacing {
    North,
    South,
    West,
    East,
}
impl Value for OrangeWallBannerFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum MagentaWallBannerFacing {
    North,
    South,
    West,
    East,
}
impl Value for MagentaWallBannerFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum LightBlueWallBannerFacing {
    North,
    South,
    West,
    East,
}
impl Value for LightBlueWallBannerFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum YellowWallBannerFacing {
    North,
    South,
    West,
    East,
}
impl Value for YellowWallBannerFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum LimeWallBannerFacing {
    North,
    South,
    West,
    East,
}
impl Value for LimeWallBannerFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum PinkWallBannerFacing {
    North,
    South,
    West,
    East,
}
impl Value for PinkWallBannerFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum GrayWallBannerFacing {
    North,
    South,
    West,
    East,
}
impl Value for GrayWallBannerFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum LightGrayWallBannerFacing {
    North,
    South,
    West,
    East,
}
impl Value for LightGrayWallBannerFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum CyanWallBannerFacing {
    North,
    South,
    West,
    East,
}
impl Value for CyanWallBannerFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum PurpleWallBannerFacing {
    North,
    South,
    West,
    East,
}
impl Value for PurpleWallBannerFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum BlueWallBannerFacing {
    North,
    South,
    West,
    East,
}
impl Value for BlueWallBannerFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum BrownWallBannerFacing {
    North,
    South,
    West,
    East,
}
impl Value for BrownWallBannerFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum GreenWallBannerFacing {
    North,
    South,
    West,
    East,
}
impl Value for GreenWallBannerFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum RedWallBannerFacing {
    North,
    South,
    West,
    East,
}
impl Value for RedWallBannerFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum BlackWallBannerFacing {
    North,
    South,
    West,
    East,
}
impl Value for BlackWallBannerFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum RedSandstoneStairsShape {
    Straight,
    InnerLeft,
    InnerRight,
    OuterLeft,
    OuterRight,
}
impl Value for RedSandstoneStairsShape {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum RedSandstoneStairsHalf {
    Top,
    Bottom,
}
impl Value for RedSandstoneStairsHalf {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum RedSandstoneStairsFacing {
    North,
    South,
    West,
    East,
}
impl Value for RedSandstoneStairsFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum OakSlabType {
    Top,
    Bottom,
    Double,
}
impl Value for OakSlabType {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum SpruceSlabType {
    Top,
    Bottom,
    Double,
}
impl Value for SpruceSlabType {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum BirchSlabType {
    Top,
    Bottom,
    Double,
}
impl Value for BirchSlabType {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum JungleSlabType {
    Top,
    Bottom,
    Double,
}
impl Value for JungleSlabType {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum AcaciaSlabType {
    Top,
    Bottom,
    Double,
}
impl Value for AcaciaSlabType {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum DarkOakSlabType {
    Top,
    Bottom,
    Double,
}
impl Value for DarkOakSlabType {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum StoneSlabType {
    Top,
    Bottom,
    Double,
}
impl Value for StoneSlabType {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum SandstoneSlabType {
    Top,
    Bottom,
    Double,
}
impl Value for SandstoneSlabType {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum PetrifiedOakSlabType {
    Top,
    Bottom,
    Double,
}
impl Value for PetrifiedOakSlabType {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum CobblestoneSlabType {
    Top,
    Bottom,
    Double,
}
impl Value for CobblestoneSlabType {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum BrickSlabType {
    Top,
    Bottom,
    Double,
}
impl Value for BrickSlabType {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum StoneBrickSlabType {
    Top,
    Bottom,
    Double,
}
impl Value for StoneBrickSlabType {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum NetherBrickSlabType {
    Top,
    Bottom,
    Double,
}
impl Value for NetherBrickSlabType {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum QuartzSlabType {
    Top,
    Bottom,
    Double,
}
impl Value for QuartzSlabType {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum RedSandstoneSlabType {
    Top,
    Bottom,
    Double,
}
impl Value for RedSandstoneSlabType {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum PurpurSlabType {
    Top,
    Bottom,
    Double,
}
impl Value for PurpurSlabType {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum SpruceFenceGateFacing {
    North,
    South,
    West,
    East,
}
impl Value for SpruceFenceGateFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum BirchFenceGateFacing {
    North,
    South,
    West,
    East,
}
impl Value for BirchFenceGateFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum JungleFenceGateFacing {
    North,
    South,
    West,
    East,
}
impl Value for JungleFenceGateFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum AcaciaFenceGateFacing {
    North,
    South,
    West,
    East,
}
impl Value for AcaciaFenceGateFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum DarkOakFenceGateFacing {
    North,
    South,
    West,
    East,
}
impl Value for DarkOakFenceGateFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum SpruceDoorHinge {
    Left,
    Right,
}
impl Value for SpruceDoorHinge {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum SpruceDoorFacing {
    North,
    South,
    West,
    East,
}
impl Value for SpruceDoorFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum SpruceDoorHalf {
    Upper,
    Lower,
}
impl Value for SpruceDoorHalf {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum BirchDoorHalf {
    Upper,
    Lower,
}
impl Value for BirchDoorHalf {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum BirchDoorHinge {
    Left,
    Right,
}
impl Value for BirchDoorHinge {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum BirchDoorFacing {
    North,
    South,
    West,
    East,
}
impl Value for BirchDoorFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum JungleDoorFacing {
    North,
    South,
    West,
    East,
}
impl Value for JungleDoorFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum JungleDoorHinge {
    Left,
    Right,
}
impl Value for JungleDoorHinge {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum JungleDoorHalf {
    Upper,
    Lower,
}
impl Value for JungleDoorHalf {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum AcaciaDoorFacing {
    North,
    South,
    West,
    East,
}
impl Value for AcaciaDoorFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum AcaciaDoorHalf {
    Upper,
    Lower,
}
impl Value for AcaciaDoorHalf {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum AcaciaDoorHinge {
    Left,
    Right,
}
impl Value for AcaciaDoorHinge {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum DarkOakDoorFacing {
    North,
    South,
    West,
    East,
}
impl Value for DarkOakDoorFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum DarkOakDoorHalf {
    Upper,
    Lower,
}
impl Value for DarkOakDoorHalf {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum DarkOakDoorHinge {
    Left,
    Right,
}
impl Value for DarkOakDoorHinge {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum EndRodFacing {
    North,
    East,
    South,
    West,
    Up,
    Down,
}
impl Value for EndRodFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum PurpurPillarAxis {
    X,
    Y,
    Z,
}
impl Value for PurpurPillarAxis {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum PurpurStairsHalf {
    Top,
    Bottom,
}
impl Value for PurpurStairsHalf {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum PurpurStairsFacing {
    North,
    South,
    West,
    East,
}
impl Value for PurpurStairsFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum PurpurStairsShape {
    Straight,
    InnerLeft,
    InnerRight,
    OuterLeft,
    OuterRight,
}
impl Value for PurpurStairsShape {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum RepeatingCommandBlockFacing {
    North,
    East,
    South,
    West,
    Up,
    Down,
}
impl Value for RepeatingCommandBlockFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum ChainCommandBlockFacing {
    North,
    East,
    South,
    West,
    Up,
    Down,
}
impl Value for ChainCommandBlockFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum BoneBlockAxis {
    X,
    Y,
    Z,
}
impl Value for BoneBlockAxis {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum ObserverFacing {
    North,
    East,
    South,
    West,
    Up,
    Down,
}
impl Value for ObserverFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum ShulkerBoxFacing {
    North,
    East,
    South,
    West,
    Up,
    Down,
}
impl Value for ShulkerBoxFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum WhiteShulkerBoxFacing {
    North,
    East,
    South,
    West,
    Up,
    Down,
}
impl Value for WhiteShulkerBoxFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum OrangeShulkerBoxFacing {
    North,
    East,
    South,
    West,
    Up,
    Down,
}
impl Value for OrangeShulkerBoxFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum MagentaShulkerBoxFacing {
    North,
    East,
    South,
    West,
    Up,
    Down,
}
impl Value for MagentaShulkerBoxFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum LightBlueShulkerBoxFacing {
    North,
    East,
    South,
    West,
    Up,
    Down,
}
impl Value for LightBlueShulkerBoxFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum YellowShulkerBoxFacing {
    North,
    East,
    South,
    West,
    Up,
    Down,
}
impl Value for YellowShulkerBoxFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum LimeShulkerBoxFacing {
    North,
    East,
    South,
    West,
    Up,
    Down,
}
impl Value for LimeShulkerBoxFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum PinkShulkerBoxFacing {
    North,
    East,
    South,
    West,
    Up,
    Down,
}
impl Value for PinkShulkerBoxFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum GrayShulkerBoxFacing {
    North,
    East,
    South,
    West,
    Up,
    Down,
}
impl Value for GrayShulkerBoxFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum LightGrayShulkerBoxFacing {
    North,
    East,
    South,
    West,
    Up,
    Down,
}
impl Value for LightGrayShulkerBoxFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum CyanShulkerBoxFacing {
    North,
    East,
    South,
    West,
    Up,
    Down,
}
impl Value for CyanShulkerBoxFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum PurpleShulkerBoxFacing {
    North,
    East,
    South,
    West,
    Up,
    Down,
}
impl Value for PurpleShulkerBoxFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum BlueShulkerBoxFacing {
    North,
    East,
    South,
    West,
    Up,
    Down,
}
impl Value for BlueShulkerBoxFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum BrownShulkerBoxFacing {
    North,
    East,
    South,
    West,
    Up,
    Down,
}
impl Value for BrownShulkerBoxFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum GreenShulkerBoxFacing {
    North,
    East,
    South,
    West,
    Up,
    Down,
}
impl Value for GreenShulkerBoxFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum RedShulkerBoxFacing {
    North,
    East,
    South,
    West,
    Up,
    Down,
}
impl Value for RedShulkerBoxFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum BlackShulkerBoxFacing {
    North,
    East,
    South,
    West,
    Up,
    Down,
}
impl Value for BlackShulkerBoxFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum WhiteGlazedTerracottaFacing {
    North,
    South,
    West,
    East,
}
impl Value for WhiteGlazedTerracottaFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum OrangeGlazedTerracottaFacing {
    North,
    South,
    West,
    East,
}
impl Value for OrangeGlazedTerracottaFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum MagentaGlazedTerracottaFacing {
    North,
    South,
    West,
    East,
}
impl Value for MagentaGlazedTerracottaFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum LightBlueGlazedTerracottaFacing {
    North,
    South,
    West,
    East,
}
impl Value for LightBlueGlazedTerracottaFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum YellowGlazedTerracottaFacing {
    North,
    South,
    West,
    East,
}
impl Value for YellowGlazedTerracottaFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum LimeGlazedTerracottaFacing {
    North,
    South,
    West,
    East,
}
impl Value for LimeGlazedTerracottaFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum PinkGlazedTerracottaFacing {
    North,
    South,
    West,
    East,
}
impl Value for PinkGlazedTerracottaFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum GrayGlazedTerracottaFacing {
    North,
    South,
    West,
    East,
}
impl Value for GrayGlazedTerracottaFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum LightGrayGlazedTerracottaFacing {
    North,
    South,
    West,
    East,
}
impl Value for LightGrayGlazedTerracottaFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum CyanGlazedTerracottaFacing {
    North,
    South,
    West,
    East,
}
impl Value for CyanGlazedTerracottaFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum PurpleGlazedTerracottaFacing {
    North,
    South,
    West,
    East,
}
impl Value for PurpleGlazedTerracottaFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum BlueGlazedTerracottaFacing {
    North,
    South,
    West,
    East,
}
impl Value for BlueGlazedTerracottaFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum BrownGlazedTerracottaFacing {
    North,
    South,
    West,
    East,
}
impl Value for BrownGlazedTerracottaFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum GreenGlazedTerracottaFacing {
    North,
    South,
    West,
    East,
}
impl Value for GreenGlazedTerracottaFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum RedGlazedTerracottaFacing {
    North,
    South,
    West,
    East,
}
impl Value for RedGlazedTerracottaFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum BlackGlazedTerracottaFacing {
    North,
    South,
    West,
    East,
}
impl Value for BlackGlazedTerracottaFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum DeadTubeCoralWallFanFacing {
    North,
    South,
    West,
    East,
}
impl Value for DeadTubeCoralWallFanFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum DeadBrainCoralWallFanFacing {
    North,
    South,
    West,
    East,
}
impl Value for DeadBrainCoralWallFanFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum DeadBubbleCoralWallFanFacing {
    North,
    South,
    West,
    East,
}
impl Value for DeadBubbleCoralWallFanFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum DeadFireCoralWallFanFacing {
    North,
    South,
    West,
    East,
}
impl Value for DeadFireCoralWallFanFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum DeadHornCoralWallFanFacing {
    North,
    South,
    West,
    East,
}
impl Value for DeadHornCoralWallFanFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum TubeCoralWallFanFacing {
    North,
    South,
    West,
    East,
}
impl Value for TubeCoralWallFanFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum BrainCoralWallFanFacing {
    North,
    South,
    West,
    East,
}
impl Value for BrainCoralWallFanFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum BubbleCoralWallFanFacing {
    North,
    South,
    West,
    East,
}
impl Value for BubbleCoralWallFanFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum FireCoralWallFanFacing {
    North,
    South,
    West,
    East,
}
impl Value for FireCoralWallFanFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum HornCoralWallFanFacing {
    North,
    South,
    West,
    East,
}
impl Value for HornCoralWallFanFacing {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
pub enum StructureBlockMode {
    Save,
    Load,
    Corner,
    Data,
}
impl Value for StructureBlockMode {
    fn value(&self) -> usize {
        *self as usize
    }
    fn from_value(val: usize) -> Option<Self> {
        Self::from_usize(val)
    }
}
