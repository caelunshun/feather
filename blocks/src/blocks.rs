//! This file was generated by /generators/blocks
use feather_codegen::{FromSnakeCase, ToSnakeCase};
use std::collections::HashMap;
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum Block {
    Air,
    Stone,
    Granite,
    PolishedGranite,
    Diorite,
    PolishedDiorite,
    Andesite,
    PolishedAndesite,
    GrassBlock(GrassBlockData),
    Dirt,
    CoarseDirt,
    Podzol(PodzolData),
    Cobblestone,
    OakPlanks,
    SprucePlanks,
    BirchPlanks,
    JunglePlanks,
    AcaciaPlanks,
    DarkOakPlanks,
    OakSapling(OakSaplingData),
    SpruceSapling(SpruceSaplingData),
    BirchSapling(BirchSaplingData),
    JungleSapling(JungleSaplingData),
    AcaciaSapling(AcaciaSaplingData),
    DarkOakSapling(DarkOakSaplingData),
    Bedrock,
    Water(WaterData),
    Lava(LavaData),
    Sand,
    RedSand,
    Gravel,
    GoldOre,
    IronOre,
    CoalOre,
    OakLog(OakLogData),
    SpruceLog(SpruceLogData),
    BirchLog(BirchLogData),
    JungleLog(JungleLogData),
    AcaciaLog(AcaciaLogData),
    DarkOakLog(DarkOakLogData),
    StrippedSpruceLog(StrippedSpruceLogData),
    StrippedBirchLog(StrippedBirchLogData),
    StrippedJungleLog(StrippedJungleLogData),
    StrippedAcaciaLog(StrippedAcaciaLogData),
    StrippedDarkOakLog(StrippedDarkOakLogData),
    StrippedOakLog(StrippedOakLogData),
    OakWood(OakWoodData),
    SpruceWood(SpruceWoodData),
    BirchWood(BirchWoodData),
    JungleWood(JungleWoodData),
    AcaciaWood(AcaciaWoodData),
    DarkOakWood(DarkOakWoodData),
    StrippedOakWood(StrippedOakWoodData),
    StrippedSpruceWood(StrippedSpruceWoodData),
    StrippedBirchWood(StrippedBirchWoodData),
    StrippedJungleWood(StrippedJungleWoodData),
    StrippedAcaciaWood(StrippedAcaciaWoodData),
    StrippedDarkOakWood(StrippedDarkOakWoodData),
    OakLeaves(OakLeavesData),
    SpruceLeaves(SpruceLeavesData),
    BirchLeaves(BirchLeavesData),
    JungleLeaves(JungleLeavesData),
    AcaciaLeaves(AcaciaLeavesData),
    DarkOakLeaves(DarkOakLeavesData),
    Sponge,
    WetSponge,
    Glass,
    LapisOre,
    LapisBlock,
    Dispenser(DispenserData),
    Sandstone,
    ChiseledSandstone,
    CutSandstone,
    NoteBlock(NoteBlockData),
    WhiteBed(WhiteBedData),
    OrangeBed(OrangeBedData),
    MagentaBed(MagentaBedData),
    LightBlueBed(LightBlueBedData),
    YellowBed(YellowBedData),
    LimeBed(LimeBedData),
    PinkBed(PinkBedData),
    GrayBed(GrayBedData),
    LightGrayBed(LightGrayBedData),
    CyanBed(CyanBedData),
    PurpleBed(PurpleBedData),
    BlueBed(BlueBedData),
    BrownBed(BrownBedData),
    GreenBed(GreenBedData),
    RedBed(RedBedData),
    BlackBed(BlackBedData),
    PoweredRail(PoweredRailData),
    DetectorRail(DetectorRailData),
    StickyPiston(StickyPistonData),
    Cobweb,
    Grass,
    Fern,
    DeadBush,
    Seagrass,
    TallSeagrass(TallSeagrassData),
    Piston(PistonData),
    PistonHead(PistonHeadData),
    WhiteWool,
    OrangeWool,
    MagentaWool,
    LightBlueWool,
    YellowWool,
    LimeWool,
    PinkWool,
    GrayWool,
    LightGrayWool,
    CyanWool,
    PurpleWool,
    BlueWool,
    BrownWool,
    GreenWool,
    RedWool,
    BlackWool,
    MovingPiston(MovingPistonData),
    Dandelion,
    Poppy,
    BlueOrchid,
    Allium,
    AzureBluet,
    RedTulip,
    OrangeTulip,
    WhiteTulip,
    PinkTulip,
    OxeyeDaisy,
    BrownMushroom,
    RedMushroom,
    GoldBlock,
    IronBlock,
    Bricks,
    Tnt(TntData),
    Bookshelf,
    MossyCobblestone,
    Obsidian,
    Torch,
    WallTorch(WallTorchData),
    Fire(FireData),
    Spawner,
    OakStairs(OakStairsData),
    Chest(ChestData),
    RedstoneWire(RedstoneWireData),
    DiamondOre,
    DiamondBlock,
    CraftingTable,
    Wheat(WheatData),
    Farmland(FarmlandData),
    Furnace(FurnaceData),
    Sign(SignData),
    OakDoor(OakDoorData),
    Ladder(LadderData),
    Rail(RailData),
    CobblestoneStairs(CobblestoneStairsData),
    WallSign(WallSignData),
    Lever(LeverData),
    StonePressurePlate(StonePressurePlateData),
    IronDoor(IronDoorData),
    OakPressurePlate(OakPressurePlateData),
    SprucePressurePlate(SprucePressurePlateData),
    BirchPressurePlate(BirchPressurePlateData),
    JunglePressurePlate(JunglePressurePlateData),
    AcaciaPressurePlate(AcaciaPressurePlateData),
    DarkOakPressurePlate(DarkOakPressurePlateData),
    RedstoneOre(RedstoneOreData),
    RedstoneTorch(RedstoneTorchData),
    RedstoneWallTorch(RedstoneWallTorchData),
    StoneButton(StoneButtonData),
    Snow(SnowData),
    Ice,
    SnowBlock,
    Cactus(CactusData),
    Clay,
    SugarCane(SugarCaneData),
    Jukebox(JukeboxData),
    OakFence(OakFenceData),
    Pumpkin,
    Netherrack,
    SoulSand,
    Glowstone,
    NetherPortal(NetherPortalData),
    CarvedPumpkin(CarvedPumpkinData),
    JackOLantern(JackOLanternData),
    Cake(CakeData),
    Repeater(RepeaterData),
    WhiteStainedGlass,
    OrangeStainedGlass,
    MagentaStainedGlass,
    LightBlueStainedGlass,
    YellowStainedGlass,
    LimeStainedGlass,
    PinkStainedGlass,
    GrayStainedGlass,
    LightGrayStainedGlass,
    CyanStainedGlass,
    PurpleStainedGlass,
    BlueStainedGlass,
    BrownStainedGlass,
    GreenStainedGlass,
    RedStainedGlass,
    BlackStainedGlass,
    OakTrapdoor(OakTrapdoorData),
    SpruceTrapdoor(SpruceTrapdoorData),
    BirchTrapdoor(BirchTrapdoorData),
    JungleTrapdoor(JungleTrapdoorData),
    AcaciaTrapdoor(AcaciaTrapdoorData),
    DarkOakTrapdoor(DarkOakTrapdoorData),
    InfestedStone,
    InfestedCobblestone,
    InfestedStoneBricks,
    InfestedMossyStoneBricks,
    InfestedCrackedStoneBricks,
    InfestedChiseledStoneBricks,
    StoneBricks,
    MossyStoneBricks,
    CrackedStoneBricks,
    ChiseledStoneBricks,
    BrownMushroomBlock(BrownMushroomBlockData),
    RedMushroomBlock(RedMushroomBlockData),
    MushroomStem(MushroomStemData),
    IronBars(IronBarsData),
    GlassPane(GlassPaneData),
    Melon,
    AttachedPumpkinStem(AttachedPumpkinStemData),
    AttachedMelonStem(AttachedMelonStemData),
    PumpkinStem(PumpkinStemData),
    MelonStem(MelonStemData),
    Vine(VineData),
    OakFenceGate(OakFenceGateData),
    BrickStairs(BrickStairsData),
    StoneBrickStairs(StoneBrickStairsData),
    Mycelium(MyceliumData),
    LilyPad,
    NetherBricks,
    NetherBrickFence(NetherBrickFenceData),
    NetherBrickStairs(NetherBrickStairsData),
    NetherWart(NetherWartData),
    EnchantingTable,
    BrewingStand(BrewingStandData),
    Cauldron(CauldronData),
    EndPortal,
    EndPortalFrame(EndPortalFrameData),
    EndStone,
    DragonEgg,
    RedstoneLamp(RedstoneLampData),
    Cocoa(CocoaData),
    SandstoneStairs(SandstoneStairsData),
    EmeraldOre,
    EnderChest(EnderChestData),
    TripwireHook(TripwireHookData),
    Tripwire(TripwireData),
    EmeraldBlock,
    SpruceStairs(SpruceStairsData),
    BirchStairs(BirchStairsData),
    JungleStairs(JungleStairsData),
    CommandBlock(CommandBlockData),
    Beacon,
    CobblestoneWall(CobblestoneWallData),
    MossyCobblestoneWall(MossyCobblestoneWallData),
    FlowerPot,
    PottedOakSapling,
    PottedSpruceSapling,
    PottedBirchSapling,
    PottedJungleSapling,
    PottedAcaciaSapling,
    PottedDarkOakSapling,
    PottedFern,
    PottedDandelion,
    PottedPoppy,
    PottedBlueOrchid,
    PottedAllium,
    PottedAzureBluet,
    PottedRedTulip,
    PottedOrangeTulip,
    PottedWhiteTulip,
    PottedPinkTulip,
    PottedOxeyeDaisy,
    PottedRedMushroom,
    PottedBrownMushroom,
    PottedDeadBush,
    PottedCactus,
    Carrots(CarrotsData),
    Potatoes(PotatoesData),
    OakButton(OakButtonData),
    SpruceButton(SpruceButtonData),
    BirchButton(BirchButtonData),
    JungleButton(JungleButtonData),
    AcaciaButton(AcaciaButtonData),
    DarkOakButton(DarkOakButtonData),
    SkeletonWallSkull(SkeletonWallSkullData),
    SkeletonSkull(SkeletonSkullData),
    WitherSkeletonWallSkull(WitherSkeletonWallSkullData),
    WitherSkeletonSkull(WitherSkeletonSkullData),
    ZombieWallHead(ZombieWallHeadData),
    ZombieHead(ZombieHeadData),
    PlayerWallHead(PlayerWallHeadData),
    PlayerHead(PlayerHeadData),
    CreeperWallHead(CreeperWallHeadData),
    CreeperHead(CreeperHeadData),
    DragonWallHead(DragonWallHeadData),
    DragonHead(DragonHeadData),
    Anvil(AnvilData),
    ChippedAnvil(ChippedAnvilData),
    DamagedAnvil(DamagedAnvilData),
    TrappedChest(TrappedChestData),
    LightWeightedPressurePlate(LightWeightedPressurePlateData),
    HeavyWeightedPressurePlate(HeavyWeightedPressurePlateData),
    Comparator(ComparatorData),
    DaylightDetector(DaylightDetectorData),
    RedstoneBlock,
    NetherQuartzOre,
    Hopper(HopperData),
    QuartzBlock,
    ChiseledQuartzBlock,
    QuartzPillar(QuartzPillarData),
    QuartzStairs(QuartzStairsData),
    ActivatorRail(ActivatorRailData),
    Dropper(DropperData),
    WhiteTerracotta,
    OrangeTerracotta,
    MagentaTerracotta,
    LightBlueTerracotta,
    YellowTerracotta,
    LimeTerracotta,
    PinkTerracotta,
    GrayTerracotta,
    LightGrayTerracotta,
    CyanTerracotta,
    PurpleTerracotta,
    BlueTerracotta,
    BrownTerracotta,
    GreenTerracotta,
    RedTerracotta,
    BlackTerracotta,
    WhiteStainedGlassPane(WhiteStainedGlassPaneData),
    OrangeStainedGlassPane(OrangeStainedGlassPaneData),
    MagentaStainedGlassPane(MagentaStainedGlassPaneData),
    LightBlueStainedGlassPane(LightBlueStainedGlassPaneData),
    YellowStainedGlassPane(YellowStainedGlassPaneData),
    LimeStainedGlassPane(LimeStainedGlassPaneData),
    PinkStainedGlassPane(PinkStainedGlassPaneData),
    GrayStainedGlassPane(GrayStainedGlassPaneData),
    LightGrayStainedGlassPane(LightGrayStainedGlassPaneData),
    CyanStainedGlassPane(CyanStainedGlassPaneData),
    PurpleStainedGlassPane(PurpleStainedGlassPaneData),
    BlueStainedGlassPane(BlueStainedGlassPaneData),
    BrownStainedGlassPane(BrownStainedGlassPaneData),
    GreenStainedGlassPane(GreenStainedGlassPaneData),
    RedStainedGlassPane(RedStainedGlassPaneData),
    BlackStainedGlassPane(BlackStainedGlassPaneData),
    AcaciaStairs(AcaciaStairsData),
    DarkOakStairs(DarkOakStairsData),
    SlimeBlock,
    Barrier,
    IronTrapdoor(IronTrapdoorData),
    Prismarine,
    PrismarineBricks,
    DarkPrismarine,
    PrismarineStairs(PrismarineStairsData),
    PrismarineBrickStairs(PrismarineBrickStairsData),
    DarkPrismarineStairs(DarkPrismarineStairsData),
    PrismarineSlab(PrismarineSlabData),
    PrismarineBrickSlab(PrismarineBrickSlabData),
    DarkPrismarineSlab(DarkPrismarineSlabData),
    SeaLantern,
    HayBlock(HayBlockData),
    WhiteCarpet,
    OrangeCarpet,
    MagentaCarpet,
    LightBlueCarpet,
    YellowCarpet,
    LimeCarpet,
    PinkCarpet,
    GrayCarpet,
    LightGrayCarpet,
    CyanCarpet,
    PurpleCarpet,
    BlueCarpet,
    BrownCarpet,
    GreenCarpet,
    RedCarpet,
    BlackCarpet,
    Terracotta,
    CoalBlock,
    PackedIce,
    Sunflower(SunflowerData),
    Lilac(LilacData),
    RoseBush(RoseBushData),
    Peony(PeonyData),
    TallGrass(TallGrassData),
    LargeFern(LargeFernData),
    WhiteBanner(WhiteBannerData),
    OrangeBanner(OrangeBannerData),
    MagentaBanner(MagentaBannerData),
    LightBlueBanner(LightBlueBannerData),
    YellowBanner(YellowBannerData),
    LimeBanner(LimeBannerData),
    PinkBanner(PinkBannerData),
    GrayBanner(GrayBannerData),
    LightGrayBanner(LightGrayBannerData),
    CyanBanner(CyanBannerData),
    PurpleBanner(PurpleBannerData),
    BlueBanner(BlueBannerData),
    BrownBanner(BrownBannerData),
    GreenBanner(GreenBannerData),
    RedBanner(RedBannerData),
    BlackBanner(BlackBannerData),
    WhiteWallBanner(WhiteWallBannerData),
    OrangeWallBanner(OrangeWallBannerData),
    MagentaWallBanner(MagentaWallBannerData),
    LightBlueWallBanner(LightBlueWallBannerData),
    YellowWallBanner(YellowWallBannerData),
    LimeWallBanner(LimeWallBannerData),
    PinkWallBanner(PinkWallBannerData),
    GrayWallBanner(GrayWallBannerData),
    LightGrayWallBanner(LightGrayWallBannerData),
    CyanWallBanner(CyanWallBannerData),
    PurpleWallBanner(PurpleWallBannerData),
    BlueWallBanner(BlueWallBannerData),
    BrownWallBanner(BrownWallBannerData),
    GreenWallBanner(GreenWallBannerData),
    RedWallBanner(RedWallBannerData),
    BlackWallBanner(BlackWallBannerData),
    RedSandstone,
    ChiseledRedSandstone,
    CutRedSandstone,
    RedSandstoneStairs(RedSandstoneStairsData),
    OakSlab(OakSlabData),
    SpruceSlab(SpruceSlabData),
    BirchSlab(BirchSlabData),
    JungleSlab(JungleSlabData),
    AcaciaSlab(AcaciaSlabData),
    DarkOakSlab(DarkOakSlabData),
    StoneSlab(StoneSlabData),
    SandstoneSlab(SandstoneSlabData),
    PetrifiedOakSlab(PetrifiedOakSlabData),
    CobblestoneSlab(CobblestoneSlabData),
    BrickSlab(BrickSlabData),
    StoneBrickSlab(StoneBrickSlabData),
    NetherBrickSlab(NetherBrickSlabData),
    QuartzSlab(QuartzSlabData),
    RedSandstoneSlab(RedSandstoneSlabData),
    PurpurSlab(PurpurSlabData),
    SmoothStone,
    SmoothSandstone,
    SmoothQuartz,
    SmoothRedSandstone,
    SpruceFenceGate(SpruceFenceGateData),
    BirchFenceGate(BirchFenceGateData),
    JungleFenceGate(JungleFenceGateData),
    AcaciaFenceGate(AcaciaFenceGateData),
    DarkOakFenceGate(DarkOakFenceGateData),
    SpruceFence(SpruceFenceData),
    BirchFence(BirchFenceData),
    JungleFence(JungleFenceData),
    AcaciaFence(AcaciaFenceData),
    DarkOakFence(DarkOakFenceData),
    SpruceDoor(SpruceDoorData),
    BirchDoor(BirchDoorData),
    JungleDoor(JungleDoorData),
    AcaciaDoor(AcaciaDoorData),
    DarkOakDoor(DarkOakDoorData),
    EndRod(EndRodData),
    ChorusPlant(ChorusPlantData),
    ChorusFlower(ChorusFlowerData),
    PurpurBlock,
    PurpurPillar(PurpurPillarData),
    PurpurStairs(PurpurStairsData),
    EndStoneBricks,
    Beetroots(BeetrootsData),
    GrassPath,
    EndGateway,
    RepeatingCommandBlock(RepeatingCommandBlockData),
    ChainCommandBlock(ChainCommandBlockData),
    FrostedIce(FrostedIceData),
    MagmaBlock,
    NetherWartBlock,
    RedNetherBricks,
    BoneBlock(BoneBlockData),
    StructureVoid,
    Observer(ObserverData),
    ShulkerBox(ShulkerBoxData),
    WhiteShulkerBox(WhiteShulkerBoxData),
    OrangeShulkerBox(OrangeShulkerBoxData),
    MagentaShulkerBox(MagentaShulkerBoxData),
    LightBlueShulkerBox(LightBlueShulkerBoxData),
    YellowShulkerBox(YellowShulkerBoxData),
    LimeShulkerBox(LimeShulkerBoxData),
    PinkShulkerBox(PinkShulkerBoxData),
    GrayShulkerBox(GrayShulkerBoxData),
    LightGrayShulkerBox(LightGrayShulkerBoxData),
    CyanShulkerBox(CyanShulkerBoxData),
    PurpleShulkerBox(PurpleShulkerBoxData),
    BlueShulkerBox(BlueShulkerBoxData),
    BrownShulkerBox(BrownShulkerBoxData),
    GreenShulkerBox(GreenShulkerBoxData),
    RedShulkerBox(RedShulkerBoxData),
    BlackShulkerBox(BlackShulkerBoxData),
    WhiteGlazedTerracotta(WhiteGlazedTerracottaData),
    OrangeGlazedTerracotta(OrangeGlazedTerracottaData),
    MagentaGlazedTerracotta(MagentaGlazedTerracottaData),
    LightBlueGlazedTerracotta(LightBlueGlazedTerracottaData),
    YellowGlazedTerracotta(YellowGlazedTerracottaData),
    LimeGlazedTerracotta(LimeGlazedTerracottaData),
    PinkGlazedTerracotta(PinkGlazedTerracottaData),
    GrayGlazedTerracotta(GrayGlazedTerracottaData),
    LightGrayGlazedTerracotta(LightGrayGlazedTerracottaData),
    CyanGlazedTerracotta(CyanGlazedTerracottaData),
    PurpleGlazedTerracotta(PurpleGlazedTerracottaData),
    BlueGlazedTerracotta(BlueGlazedTerracottaData),
    BrownGlazedTerracotta(BrownGlazedTerracottaData),
    GreenGlazedTerracotta(GreenGlazedTerracottaData),
    RedGlazedTerracotta(RedGlazedTerracottaData),
    BlackGlazedTerracotta(BlackGlazedTerracottaData),
    WhiteConcrete,
    OrangeConcrete,
    MagentaConcrete,
    LightBlueConcrete,
    YellowConcrete,
    LimeConcrete,
    PinkConcrete,
    GrayConcrete,
    LightGrayConcrete,
    CyanConcrete,
    PurpleConcrete,
    BlueConcrete,
    BrownConcrete,
    GreenConcrete,
    RedConcrete,
    BlackConcrete,
    WhiteConcretePowder,
    OrangeConcretePowder,
    MagentaConcretePowder,
    LightBlueConcretePowder,
    YellowConcretePowder,
    LimeConcretePowder,
    PinkConcretePowder,
    GrayConcretePowder,
    LightGrayConcretePowder,
    CyanConcretePowder,
    PurpleConcretePowder,
    BlueConcretePowder,
    BrownConcretePowder,
    GreenConcretePowder,
    RedConcretePowder,
    BlackConcretePowder,
    Kelp(KelpData),
    KelpPlant,
    DriedKelpBlock,
    TurtleEgg(TurtleEggData),
    DeadTubeCoralBlock,
    DeadBrainCoralBlock,
    DeadBubbleCoralBlock,
    DeadFireCoralBlock,
    DeadHornCoralBlock,
    TubeCoralBlock,
    BrainCoralBlock,
    BubbleCoralBlock,
    FireCoralBlock,
    HornCoralBlock,
    DeadTubeCoral(DeadTubeCoralData),
    DeadBrainCoral(DeadBrainCoralData),
    DeadBubbleCoral(DeadBubbleCoralData),
    DeadFireCoral(DeadFireCoralData),
    DeadHornCoral(DeadHornCoralData),
    TubeCoral(TubeCoralData),
    BrainCoral(BrainCoralData),
    BubbleCoral(BubbleCoralData),
    FireCoral(FireCoralData),
    HornCoral(HornCoralData),
    DeadTubeCoralWallFan(DeadTubeCoralWallFanData),
    DeadBrainCoralWallFan(DeadBrainCoralWallFanData),
    DeadBubbleCoralWallFan(DeadBubbleCoralWallFanData),
    DeadFireCoralWallFan(DeadFireCoralWallFanData),
    DeadHornCoralWallFan(DeadHornCoralWallFanData),
    TubeCoralWallFan(TubeCoralWallFanData),
    BrainCoralWallFan(BrainCoralWallFanData),
    BubbleCoralWallFan(BubbleCoralWallFanData),
    FireCoralWallFan(FireCoralWallFanData),
    HornCoralWallFan(HornCoralWallFanData),
    DeadTubeCoralFan(DeadTubeCoralFanData),
    DeadBrainCoralFan(DeadBrainCoralFanData),
    DeadBubbleCoralFan(DeadBubbleCoralFanData),
    DeadFireCoralFan(DeadFireCoralFanData),
    DeadHornCoralFan(DeadHornCoralFanData),
    TubeCoralFan(TubeCoralFanData),
    BrainCoralFan(BrainCoralFanData),
    BubbleCoralFan(BubbleCoralFanData),
    FireCoralFan(FireCoralFanData),
    HornCoralFan(HornCoralFanData),
    SeaPickle(SeaPickleData),
    BlueIce,
    Conduit(ConduitData),
    VoidAir,
    CaveAir,
    BubbleColumn(BubbleColumnData),
    StructureBlock(StructureBlockData),
}
impl Block {
    pub fn native_type_id(&self) -> usize {
        match self {
            Block::Air => 0usize,
            Block::Stone => 1usize,
            Block::Granite => 2usize,
            Block::PolishedGranite => 3usize,
            Block::Diorite => 4usize,
            Block::PolishedDiorite => 5usize,
            Block::Andesite => 6usize,
            Block::PolishedAndesite => 7usize,
            Block::GrassBlock(_) => 8usize,
            Block::Dirt => 9usize,
            Block::CoarseDirt => 10usize,
            Block::Podzol(_) => 11usize,
            Block::Cobblestone => 12usize,
            Block::OakPlanks => 13usize,
            Block::SprucePlanks => 14usize,
            Block::BirchPlanks => 15usize,
            Block::JunglePlanks => 16usize,
            Block::AcaciaPlanks => 17usize,
            Block::DarkOakPlanks => 18usize,
            Block::OakSapling(_) => 19usize,
            Block::SpruceSapling(_) => 20usize,
            Block::BirchSapling(_) => 21usize,
            Block::JungleSapling(_) => 22usize,
            Block::AcaciaSapling(_) => 23usize,
            Block::DarkOakSapling(_) => 24usize,
            Block::Bedrock => 25usize,
            Block::Water(_) => 26usize,
            Block::Lava(_) => 27usize,
            Block::Sand => 28usize,
            Block::RedSand => 29usize,
            Block::Gravel => 30usize,
            Block::GoldOre => 31usize,
            Block::IronOre => 32usize,
            Block::CoalOre => 33usize,
            Block::OakLog(_) => 34usize,
            Block::SpruceLog(_) => 35usize,
            Block::BirchLog(_) => 36usize,
            Block::JungleLog(_) => 37usize,
            Block::AcaciaLog(_) => 38usize,
            Block::DarkOakLog(_) => 39usize,
            Block::StrippedSpruceLog(_) => 40usize,
            Block::StrippedBirchLog(_) => 41usize,
            Block::StrippedJungleLog(_) => 42usize,
            Block::StrippedAcaciaLog(_) => 43usize,
            Block::StrippedDarkOakLog(_) => 44usize,
            Block::StrippedOakLog(_) => 45usize,
            Block::OakWood(_) => 46usize,
            Block::SpruceWood(_) => 47usize,
            Block::BirchWood(_) => 48usize,
            Block::JungleWood(_) => 49usize,
            Block::AcaciaWood(_) => 50usize,
            Block::DarkOakWood(_) => 51usize,
            Block::StrippedOakWood(_) => 52usize,
            Block::StrippedSpruceWood(_) => 53usize,
            Block::StrippedBirchWood(_) => 54usize,
            Block::StrippedJungleWood(_) => 55usize,
            Block::StrippedAcaciaWood(_) => 56usize,
            Block::StrippedDarkOakWood(_) => 57usize,
            Block::OakLeaves(_) => 58usize,
            Block::SpruceLeaves(_) => 59usize,
            Block::BirchLeaves(_) => 60usize,
            Block::JungleLeaves(_) => 61usize,
            Block::AcaciaLeaves(_) => 62usize,
            Block::DarkOakLeaves(_) => 63usize,
            Block::Sponge => 64usize,
            Block::WetSponge => 65usize,
            Block::Glass => 66usize,
            Block::LapisOre => 67usize,
            Block::LapisBlock => 68usize,
            Block::Dispenser(_) => 69usize,
            Block::Sandstone => 70usize,
            Block::ChiseledSandstone => 71usize,
            Block::CutSandstone => 72usize,
            Block::NoteBlock(_) => 73usize,
            Block::WhiteBed(_) => 74usize,
            Block::OrangeBed(_) => 75usize,
            Block::MagentaBed(_) => 76usize,
            Block::LightBlueBed(_) => 77usize,
            Block::YellowBed(_) => 78usize,
            Block::LimeBed(_) => 79usize,
            Block::PinkBed(_) => 80usize,
            Block::GrayBed(_) => 81usize,
            Block::LightGrayBed(_) => 82usize,
            Block::CyanBed(_) => 83usize,
            Block::PurpleBed(_) => 84usize,
            Block::BlueBed(_) => 85usize,
            Block::BrownBed(_) => 86usize,
            Block::GreenBed(_) => 87usize,
            Block::RedBed(_) => 88usize,
            Block::BlackBed(_) => 89usize,
            Block::PoweredRail(_) => 90usize,
            Block::DetectorRail(_) => 91usize,
            Block::StickyPiston(_) => 92usize,
            Block::Cobweb => 93usize,
            Block::Grass => 94usize,
            Block::Fern => 95usize,
            Block::DeadBush => 96usize,
            Block::Seagrass => 97usize,
            Block::TallSeagrass(_) => 98usize,
            Block::Piston(_) => 99usize,
            Block::PistonHead(_) => 100usize,
            Block::WhiteWool => 101usize,
            Block::OrangeWool => 102usize,
            Block::MagentaWool => 103usize,
            Block::LightBlueWool => 104usize,
            Block::YellowWool => 105usize,
            Block::LimeWool => 106usize,
            Block::PinkWool => 107usize,
            Block::GrayWool => 108usize,
            Block::LightGrayWool => 109usize,
            Block::CyanWool => 110usize,
            Block::PurpleWool => 111usize,
            Block::BlueWool => 112usize,
            Block::BrownWool => 113usize,
            Block::GreenWool => 114usize,
            Block::RedWool => 115usize,
            Block::BlackWool => 116usize,
            Block::MovingPiston(_) => 117usize,
            Block::Dandelion => 118usize,
            Block::Poppy => 119usize,
            Block::BlueOrchid => 120usize,
            Block::Allium => 121usize,
            Block::AzureBluet => 122usize,
            Block::RedTulip => 123usize,
            Block::OrangeTulip => 124usize,
            Block::WhiteTulip => 125usize,
            Block::PinkTulip => 126usize,
            Block::OxeyeDaisy => 127usize,
            Block::BrownMushroom => 128usize,
            Block::RedMushroom => 129usize,
            Block::GoldBlock => 130usize,
            Block::IronBlock => 131usize,
            Block::Bricks => 132usize,
            Block::Tnt(_) => 133usize,
            Block::Bookshelf => 134usize,
            Block::MossyCobblestone => 135usize,
            Block::Obsidian => 136usize,
            Block::Torch => 137usize,
            Block::WallTorch(_) => 138usize,
            Block::Fire(_) => 139usize,
            Block::Spawner => 140usize,
            Block::OakStairs(_) => 141usize,
            Block::Chest(_) => 142usize,
            Block::RedstoneWire(_) => 143usize,
            Block::DiamondOre => 144usize,
            Block::DiamondBlock => 145usize,
            Block::CraftingTable => 146usize,
            Block::Wheat(_) => 147usize,
            Block::Farmland(_) => 148usize,
            Block::Furnace(_) => 149usize,
            Block::Sign(_) => 150usize,
            Block::OakDoor(_) => 151usize,
            Block::Ladder(_) => 152usize,
            Block::Rail(_) => 153usize,
            Block::CobblestoneStairs(_) => 154usize,
            Block::WallSign(_) => 155usize,
            Block::Lever(_) => 156usize,
            Block::StonePressurePlate(_) => 157usize,
            Block::IronDoor(_) => 158usize,
            Block::OakPressurePlate(_) => 159usize,
            Block::SprucePressurePlate(_) => 160usize,
            Block::BirchPressurePlate(_) => 161usize,
            Block::JunglePressurePlate(_) => 162usize,
            Block::AcaciaPressurePlate(_) => 163usize,
            Block::DarkOakPressurePlate(_) => 164usize,
            Block::RedstoneOre(_) => 165usize,
            Block::RedstoneTorch(_) => 166usize,
            Block::RedstoneWallTorch(_) => 167usize,
            Block::StoneButton(_) => 168usize,
            Block::Snow(_) => 169usize,
            Block::Ice => 170usize,
            Block::SnowBlock => 171usize,
            Block::Cactus(_) => 172usize,
            Block::Clay => 173usize,
            Block::SugarCane(_) => 174usize,
            Block::Jukebox(_) => 175usize,
            Block::OakFence(_) => 176usize,
            Block::Pumpkin => 177usize,
            Block::Netherrack => 178usize,
            Block::SoulSand => 179usize,
            Block::Glowstone => 180usize,
            Block::NetherPortal(_) => 181usize,
            Block::CarvedPumpkin(_) => 182usize,
            Block::JackOLantern(_) => 183usize,
            Block::Cake(_) => 184usize,
            Block::Repeater(_) => 185usize,
            Block::WhiteStainedGlass => 186usize,
            Block::OrangeStainedGlass => 187usize,
            Block::MagentaStainedGlass => 188usize,
            Block::LightBlueStainedGlass => 189usize,
            Block::YellowStainedGlass => 190usize,
            Block::LimeStainedGlass => 191usize,
            Block::PinkStainedGlass => 192usize,
            Block::GrayStainedGlass => 193usize,
            Block::LightGrayStainedGlass => 194usize,
            Block::CyanStainedGlass => 195usize,
            Block::PurpleStainedGlass => 196usize,
            Block::BlueStainedGlass => 197usize,
            Block::BrownStainedGlass => 198usize,
            Block::GreenStainedGlass => 199usize,
            Block::RedStainedGlass => 200usize,
            Block::BlackStainedGlass => 201usize,
            Block::OakTrapdoor(_) => 202usize,
            Block::SpruceTrapdoor(_) => 203usize,
            Block::BirchTrapdoor(_) => 204usize,
            Block::JungleTrapdoor(_) => 205usize,
            Block::AcaciaTrapdoor(_) => 206usize,
            Block::DarkOakTrapdoor(_) => 207usize,
            Block::InfestedStone => 208usize,
            Block::InfestedCobblestone => 209usize,
            Block::InfestedStoneBricks => 210usize,
            Block::InfestedMossyStoneBricks => 211usize,
            Block::InfestedCrackedStoneBricks => 212usize,
            Block::InfestedChiseledStoneBricks => 213usize,
            Block::StoneBricks => 214usize,
            Block::MossyStoneBricks => 215usize,
            Block::CrackedStoneBricks => 216usize,
            Block::ChiseledStoneBricks => 217usize,
            Block::BrownMushroomBlock(_) => 218usize,
            Block::RedMushroomBlock(_) => 219usize,
            Block::MushroomStem(_) => 220usize,
            Block::IronBars(_) => 221usize,
            Block::GlassPane(_) => 222usize,
            Block::Melon => 223usize,
            Block::AttachedPumpkinStem(_) => 224usize,
            Block::AttachedMelonStem(_) => 225usize,
            Block::PumpkinStem(_) => 226usize,
            Block::MelonStem(_) => 227usize,
            Block::Vine(_) => 228usize,
            Block::OakFenceGate(_) => 229usize,
            Block::BrickStairs(_) => 230usize,
            Block::StoneBrickStairs(_) => 231usize,
            Block::Mycelium(_) => 232usize,
            Block::LilyPad => 233usize,
            Block::NetherBricks => 234usize,
            Block::NetherBrickFence(_) => 235usize,
            Block::NetherBrickStairs(_) => 236usize,
            Block::NetherWart(_) => 237usize,
            Block::EnchantingTable => 238usize,
            Block::BrewingStand(_) => 239usize,
            Block::Cauldron(_) => 240usize,
            Block::EndPortal => 241usize,
            Block::EndPortalFrame(_) => 242usize,
            Block::EndStone => 243usize,
            Block::DragonEgg => 244usize,
            Block::RedstoneLamp(_) => 245usize,
            Block::Cocoa(_) => 246usize,
            Block::SandstoneStairs(_) => 247usize,
            Block::EmeraldOre => 248usize,
            Block::EnderChest(_) => 249usize,
            Block::TripwireHook(_) => 250usize,
            Block::Tripwire(_) => 251usize,
            Block::EmeraldBlock => 252usize,
            Block::SpruceStairs(_) => 253usize,
            Block::BirchStairs(_) => 254usize,
            Block::JungleStairs(_) => 255usize,
            Block::CommandBlock(_) => 256usize,
            Block::Beacon => 257usize,
            Block::CobblestoneWall(_) => 258usize,
            Block::MossyCobblestoneWall(_) => 259usize,
            Block::FlowerPot => 260usize,
            Block::PottedOakSapling => 261usize,
            Block::PottedSpruceSapling => 262usize,
            Block::PottedBirchSapling => 263usize,
            Block::PottedJungleSapling => 264usize,
            Block::PottedAcaciaSapling => 265usize,
            Block::PottedDarkOakSapling => 266usize,
            Block::PottedFern => 267usize,
            Block::PottedDandelion => 268usize,
            Block::PottedPoppy => 269usize,
            Block::PottedBlueOrchid => 270usize,
            Block::PottedAllium => 271usize,
            Block::PottedAzureBluet => 272usize,
            Block::PottedRedTulip => 273usize,
            Block::PottedOrangeTulip => 274usize,
            Block::PottedWhiteTulip => 275usize,
            Block::PottedPinkTulip => 276usize,
            Block::PottedOxeyeDaisy => 277usize,
            Block::PottedRedMushroom => 278usize,
            Block::PottedBrownMushroom => 279usize,
            Block::PottedDeadBush => 280usize,
            Block::PottedCactus => 281usize,
            Block::Carrots(_) => 282usize,
            Block::Potatoes(_) => 283usize,
            Block::OakButton(_) => 284usize,
            Block::SpruceButton(_) => 285usize,
            Block::BirchButton(_) => 286usize,
            Block::JungleButton(_) => 287usize,
            Block::AcaciaButton(_) => 288usize,
            Block::DarkOakButton(_) => 289usize,
            Block::SkeletonWallSkull(_) => 290usize,
            Block::SkeletonSkull(_) => 291usize,
            Block::WitherSkeletonWallSkull(_) => 292usize,
            Block::WitherSkeletonSkull(_) => 293usize,
            Block::ZombieWallHead(_) => 294usize,
            Block::ZombieHead(_) => 295usize,
            Block::PlayerWallHead(_) => 296usize,
            Block::PlayerHead(_) => 297usize,
            Block::CreeperWallHead(_) => 298usize,
            Block::CreeperHead(_) => 299usize,
            Block::DragonWallHead(_) => 300usize,
            Block::DragonHead(_) => 301usize,
            Block::Anvil(_) => 302usize,
            Block::ChippedAnvil(_) => 303usize,
            Block::DamagedAnvil(_) => 304usize,
            Block::TrappedChest(_) => 305usize,
            Block::LightWeightedPressurePlate(_) => 306usize,
            Block::HeavyWeightedPressurePlate(_) => 307usize,
            Block::Comparator(_) => 308usize,
            Block::DaylightDetector(_) => 309usize,
            Block::RedstoneBlock => 310usize,
            Block::NetherQuartzOre => 311usize,
            Block::Hopper(_) => 312usize,
            Block::QuartzBlock => 313usize,
            Block::ChiseledQuartzBlock => 314usize,
            Block::QuartzPillar(_) => 315usize,
            Block::QuartzStairs(_) => 316usize,
            Block::ActivatorRail(_) => 317usize,
            Block::Dropper(_) => 318usize,
            Block::WhiteTerracotta => 319usize,
            Block::OrangeTerracotta => 320usize,
            Block::MagentaTerracotta => 321usize,
            Block::LightBlueTerracotta => 322usize,
            Block::YellowTerracotta => 323usize,
            Block::LimeTerracotta => 324usize,
            Block::PinkTerracotta => 325usize,
            Block::GrayTerracotta => 326usize,
            Block::LightGrayTerracotta => 327usize,
            Block::CyanTerracotta => 328usize,
            Block::PurpleTerracotta => 329usize,
            Block::BlueTerracotta => 330usize,
            Block::BrownTerracotta => 331usize,
            Block::GreenTerracotta => 332usize,
            Block::RedTerracotta => 333usize,
            Block::BlackTerracotta => 334usize,
            Block::WhiteStainedGlassPane(_) => 335usize,
            Block::OrangeStainedGlassPane(_) => 336usize,
            Block::MagentaStainedGlassPane(_) => 337usize,
            Block::LightBlueStainedGlassPane(_) => 338usize,
            Block::YellowStainedGlassPane(_) => 339usize,
            Block::LimeStainedGlassPane(_) => 340usize,
            Block::PinkStainedGlassPane(_) => 341usize,
            Block::GrayStainedGlassPane(_) => 342usize,
            Block::LightGrayStainedGlassPane(_) => 343usize,
            Block::CyanStainedGlassPane(_) => 344usize,
            Block::PurpleStainedGlassPane(_) => 345usize,
            Block::BlueStainedGlassPane(_) => 346usize,
            Block::BrownStainedGlassPane(_) => 347usize,
            Block::GreenStainedGlassPane(_) => 348usize,
            Block::RedStainedGlassPane(_) => 349usize,
            Block::BlackStainedGlassPane(_) => 350usize,
            Block::AcaciaStairs(_) => 351usize,
            Block::DarkOakStairs(_) => 352usize,
            Block::SlimeBlock => 353usize,
            Block::Barrier => 354usize,
            Block::IronTrapdoor(_) => 355usize,
            Block::Prismarine => 356usize,
            Block::PrismarineBricks => 357usize,
            Block::DarkPrismarine => 358usize,
            Block::PrismarineStairs(_) => 359usize,
            Block::PrismarineBrickStairs(_) => 360usize,
            Block::DarkPrismarineStairs(_) => 361usize,
            Block::PrismarineSlab(_) => 362usize,
            Block::PrismarineBrickSlab(_) => 363usize,
            Block::DarkPrismarineSlab(_) => 364usize,
            Block::SeaLantern => 365usize,
            Block::HayBlock(_) => 366usize,
            Block::WhiteCarpet => 367usize,
            Block::OrangeCarpet => 368usize,
            Block::MagentaCarpet => 369usize,
            Block::LightBlueCarpet => 370usize,
            Block::YellowCarpet => 371usize,
            Block::LimeCarpet => 372usize,
            Block::PinkCarpet => 373usize,
            Block::GrayCarpet => 374usize,
            Block::LightGrayCarpet => 375usize,
            Block::CyanCarpet => 376usize,
            Block::PurpleCarpet => 377usize,
            Block::BlueCarpet => 378usize,
            Block::BrownCarpet => 379usize,
            Block::GreenCarpet => 380usize,
            Block::RedCarpet => 381usize,
            Block::BlackCarpet => 382usize,
            Block::Terracotta => 383usize,
            Block::CoalBlock => 384usize,
            Block::PackedIce => 385usize,
            Block::Sunflower(_) => 386usize,
            Block::Lilac(_) => 387usize,
            Block::RoseBush(_) => 388usize,
            Block::Peony(_) => 389usize,
            Block::TallGrass(_) => 390usize,
            Block::LargeFern(_) => 391usize,
            Block::WhiteBanner(_) => 392usize,
            Block::OrangeBanner(_) => 393usize,
            Block::MagentaBanner(_) => 394usize,
            Block::LightBlueBanner(_) => 395usize,
            Block::YellowBanner(_) => 396usize,
            Block::LimeBanner(_) => 397usize,
            Block::PinkBanner(_) => 398usize,
            Block::GrayBanner(_) => 399usize,
            Block::LightGrayBanner(_) => 400usize,
            Block::CyanBanner(_) => 401usize,
            Block::PurpleBanner(_) => 402usize,
            Block::BlueBanner(_) => 403usize,
            Block::BrownBanner(_) => 404usize,
            Block::GreenBanner(_) => 405usize,
            Block::RedBanner(_) => 406usize,
            Block::BlackBanner(_) => 407usize,
            Block::WhiteWallBanner(_) => 408usize,
            Block::OrangeWallBanner(_) => 409usize,
            Block::MagentaWallBanner(_) => 410usize,
            Block::LightBlueWallBanner(_) => 411usize,
            Block::YellowWallBanner(_) => 412usize,
            Block::LimeWallBanner(_) => 413usize,
            Block::PinkWallBanner(_) => 414usize,
            Block::GrayWallBanner(_) => 415usize,
            Block::LightGrayWallBanner(_) => 416usize,
            Block::CyanWallBanner(_) => 417usize,
            Block::PurpleWallBanner(_) => 418usize,
            Block::BlueWallBanner(_) => 419usize,
            Block::BrownWallBanner(_) => 420usize,
            Block::GreenWallBanner(_) => 421usize,
            Block::RedWallBanner(_) => 422usize,
            Block::BlackWallBanner(_) => 423usize,
            Block::RedSandstone => 424usize,
            Block::ChiseledRedSandstone => 425usize,
            Block::CutRedSandstone => 426usize,
            Block::RedSandstoneStairs(_) => 427usize,
            Block::OakSlab(_) => 428usize,
            Block::SpruceSlab(_) => 429usize,
            Block::BirchSlab(_) => 430usize,
            Block::JungleSlab(_) => 431usize,
            Block::AcaciaSlab(_) => 432usize,
            Block::DarkOakSlab(_) => 433usize,
            Block::StoneSlab(_) => 434usize,
            Block::SandstoneSlab(_) => 435usize,
            Block::PetrifiedOakSlab(_) => 436usize,
            Block::CobblestoneSlab(_) => 437usize,
            Block::BrickSlab(_) => 438usize,
            Block::StoneBrickSlab(_) => 439usize,
            Block::NetherBrickSlab(_) => 440usize,
            Block::QuartzSlab(_) => 441usize,
            Block::RedSandstoneSlab(_) => 442usize,
            Block::PurpurSlab(_) => 443usize,
            Block::SmoothStone => 444usize,
            Block::SmoothSandstone => 445usize,
            Block::SmoothQuartz => 446usize,
            Block::SmoothRedSandstone => 447usize,
            Block::SpruceFenceGate(_) => 448usize,
            Block::BirchFenceGate(_) => 449usize,
            Block::JungleFenceGate(_) => 450usize,
            Block::AcaciaFenceGate(_) => 451usize,
            Block::DarkOakFenceGate(_) => 452usize,
            Block::SpruceFence(_) => 453usize,
            Block::BirchFence(_) => 454usize,
            Block::JungleFence(_) => 455usize,
            Block::AcaciaFence(_) => 456usize,
            Block::DarkOakFence(_) => 457usize,
            Block::SpruceDoor(_) => 458usize,
            Block::BirchDoor(_) => 459usize,
            Block::JungleDoor(_) => 460usize,
            Block::AcaciaDoor(_) => 461usize,
            Block::DarkOakDoor(_) => 462usize,
            Block::EndRod(_) => 463usize,
            Block::ChorusPlant(_) => 464usize,
            Block::ChorusFlower(_) => 465usize,
            Block::PurpurBlock => 466usize,
            Block::PurpurPillar(_) => 467usize,
            Block::PurpurStairs(_) => 468usize,
            Block::EndStoneBricks => 469usize,
            Block::Beetroots(_) => 470usize,
            Block::GrassPath => 471usize,
            Block::EndGateway => 472usize,
            Block::RepeatingCommandBlock(_) => 473usize,
            Block::ChainCommandBlock(_) => 474usize,
            Block::FrostedIce(_) => 475usize,
            Block::MagmaBlock => 476usize,
            Block::NetherWartBlock => 477usize,
            Block::RedNetherBricks => 478usize,
            Block::BoneBlock(_) => 479usize,
            Block::StructureVoid => 480usize,
            Block::Observer(_) => 481usize,
            Block::ShulkerBox(_) => 482usize,
            Block::WhiteShulkerBox(_) => 483usize,
            Block::OrangeShulkerBox(_) => 484usize,
            Block::MagentaShulkerBox(_) => 485usize,
            Block::LightBlueShulkerBox(_) => 486usize,
            Block::YellowShulkerBox(_) => 487usize,
            Block::LimeShulkerBox(_) => 488usize,
            Block::PinkShulkerBox(_) => 489usize,
            Block::GrayShulkerBox(_) => 490usize,
            Block::LightGrayShulkerBox(_) => 491usize,
            Block::CyanShulkerBox(_) => 492usize,
            Block::PurpleShulkerBox(_) => 493usize,
            Block::BlueShulkerBox(_) => 494usize,
            Block::BrownShulkerBox(_) => 495usize,
            Block::GreenShulkerBox(_) => 496usize,
            Block::RedShulkerBox(_) => 497usize,
            Block::BlackShulkerBox(_) => 498usize,
            Block::WhiteGlazedTerracotta(_) => 499usize,
            Block::OrangeGlazedTerracotta(_) => 500usize,
            Block::MagentaGlazedTerracotta(_) => 501usize,
            Block::LightBlueGlazedTerracotta(_) => 502usize,
            Block::YellowGlazedTerracotta(_) => 503usize,
            Block::LimeGlazedTerracotta(_) => 504usize,
            Block::PinkGlazedTerracotta(_) => 505usize,
            Block::GrayGlazedTerracotta(_) => 506usize,
            Block::LightGrayGlazedTerracotta(_) => 507usize,
            Block::CyanGlazedTerracotta(_) => 508usize,
            Block::PurpleGlazedTerracotta(_) => 509usize,
            Block::BlueGlazedTerracotta(_) => 510usize,
            Block::BrownGlazedTerracotta(_) => 511usize,
            Block::GreenGlazedTerracotta(_) => 512usize,
            Block::RedGlazedTerracotta(_) => 513usize,
            Block::BlackGlazedTerracotta(_) => 514usize,
            Block::WhiteConcrete => 515usize,
            Block::OrangeConcrete => 516usize,
            Block::MagentaConcrete => 517usize,
            Block::LightBlueConcrete => 518usize,
            Block::YellowConcrete => 519usize,
            Block::LimeConcrete => 520usize,
            Block::PinkConcrete => 521usize,
            Block::GrayConcrete => 522usize,
            Block::LightGrayConcrete => 523usize,
            Block::CyanConcrete => 524usize,
            Block::PurpleConcrete => 525usize,
            Block::BlueConcrete => 526usize,
            Block::BrownConcrete => 527usize,
            Block::GreenConcrete => 528usize,
            Block::RedConcrete => 529usize,
            Block::BlackConcrete => 530usize,
            Block::WhiteConcretePowder => 531usize,
            Block::OrangeConcretePowder => 532usize,
            Block::MagentaConcretePowder => 533usize,
            Block::LightBlueConcretePowder => 534usize,
            Block::YellowConcretePowder => 535usize,
            Block::LimeConcretePowder => 536usize,
            Block::PinkConcretePowder => 537usize,
            Block::GrayConcretePowder => 538usize,
            Block::LightGrayConcretePowder => 539usize,
            Block::CyanConcretePowder => 540usize,
            Block::PurpleConcretePowder => 541usize,
            Block::BlueConcretePowder => 542usize,
            Block::BrownConcretePowder => 543usize,
            Block::GreenConcretePowder => 544usize,
            Block::RedConcretePowder => 545usize,
            Block::BlackConcretePowder => 546usize,
            Block::Kelp(_) => 547usize,
            Block::KelpPlant => 548usize,
            Block::DriedKelpBlock => 549usize,
            Block::TurtleEgg(_) => 550usize,
            Block::DeadTubeCoralBlock => 551usize,
            Block::DeadBrainCoralBlock => 552usize,
            Block::DeadBubbleCoralBlock => 553usize,
            Block::DeadFireCoralBlock => 554usize,
            Block::DeadHornCoralBlock => 555usize,
            Block::TubeCoralBlock => 556usize,
            Block::BrainCoralBlock => 557usize,
            Block::BubbleCoralBlock => 558usize,
            Block::FireCoralBlock => 559usize,
            Block::HornCoralBlock => 560usize,
            Block::DeadTubeCoral(_) => 561usize,
            Block::DeadBrainCoral(_) => 562usize,
            Block::DeadBubbleCoral(_) => 563usize,
            Block::DeadFireCoral(_) => 564usize,
            Block::DeadHornCoral(_) => 565usize,
            Block::TubeCoral(_) => 566usize,
            Block::BrainCoral(_) => 567usize,
            Block::BubbleCoral(_) => 568usize,
            Block::FireCoral(_) => 569usize,
            Block::HornCoral(_) => 570usize,
            Block::DeadTubeCoralWallFan(_) => 571usize,
            Block::DeadBrainCoralWallFan(_) => 572usize,
            Block::DeadBubbleCoralWallFan(_) => 573usize,
            Block::DeadFireCoralWallFan(_) => 574usize,
            Block::DeadHornCoralWallFan(_) => 575usize,
            Block::TubeCoralWallFan(_) => 576usize,
            Block::BrainCoralWallFan(_) => 577usize,
            Block::BubbleCoralWallFan(_) => 578usize,
            Block::FireCoralWallFan(_) => 579usize,
            Block::HornCoralWallFan(_) => 580usize,
            Block::DeadTubeCoralFan(_) => 581usize,
            Block::DeadBrainCoralFan(_) => 582usize,
            Block::DeadBubbleCoralFan(_) => 583usize,
            Block::DeadFireCoralFan(_) => 584usize,
            Block::DeadHornCoralFan(_) => 585usize,
            Block::TubeCoralFan(_) => 586usize,
            Block::BrainCoralFan(_) => 587usize,
            Block::BubbleCoralFan(_) => 588usize,
            Block::FireCoralFan(_) => 589usize,
            Block::HornCoralFan(_) => 590usize,
            Block::SeaPickle(_) => 591usize,
            Block::BlueIce => 592usize,
            Block::Conduit(_) => 593usize,
            Block::VoidAir => 594usize,
            Block::CaveAir => 595usize,
            Block::BubbleColumn(_) => 596usize,
            Block::StructureBlock(_) => 597usize,
        }
    }
}
pub trait Value {
    fn value(&self) -> usize;
}
impl Value for i32 {
    fn value(&self) -> usize {
        *self as usize
    }
}
impl Value for bool {
    fn value(&self) -> usize {
        match *self {
            true => 1,
            false => 0,
        }
    }
}
pub trait FromSnakeCase {
    fn from_snake_case(val: &str) -> Option<Self>
    where
        Self: Sized;
}
impl FromSnakeCase for i32 {
    fn from_snake_case(val: &str) -> Option<Self> {
        use std::str::FromStr;
        match i32::from_str(val) {
            Ok(x) => Some(x),
            Err(_) => None,
        }
    }
}
impl FromSnakeCase for bool {
    fn from_snake_case(val: &str) -> Option<Self> {
        use std::str::FromStr;
        match bool::from_str(val) {
            Ok(x) => Some(x),
            Err(_) => None,
        }
    }
}
pub trait ToSnakeCase {
    fn to_snake_case(&self) -> String;
}
impl ToSnakeCase for i32 {
    fn to_snake_case(&self) -> String {
        self.to_string()
    }
}
impl ToSnakeCase for bool {
    fn to_snake_case(&self) -> String {
        self.to_string()
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct GrassBlockData {
    snowy: bool,
}
impl GrassBlockData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            snowy: bool::from_snake_case(map.get("snowy")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("snowy".to_string(), self.snowy.to_snake_case());
        m
    }
}
impl Value for GrassBlockData {
    fn value(&self) -> usize {
        (self.snowy.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PodzolData {
    snowy: bool,
}
impl PodzolData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            snowy: bool::from_snake_case(map.get("snowy")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("snowy".to_string(), self.snowy.to_snake_case());
        m
    }
}
impl Value for PodzolData {
    fn value(&self) -> usize {
        (self.snowy.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OakSaplingData {
    stage: i32,
}
impl OakSaplingData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            stage: i32::from_snake_case(map.get("stage")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("stage".to_string(), self.stage.to_snake_case());
        m
    }
}
impl Value for OakSaplingData {
    fn value(&self) -> usize {
        (self.stage.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SpruceSaplingData {
    stage: i32,
}
impl SpruceSaplingData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            stage: i32::from_snake_case(map.get("stage")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("stage".to_string(), self.stage.to_snake_case());
        m
    }
}
impl Value for SpruceSaplingData {
    fn value(&self) -> usize {
        (self.stage.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BirchSaplingData {
    stage: i32,
}
impl BirchSaplingData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            stage: i32::from_snake_case(map.get("stage")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("stage".to_string(), self.stage.to_snake_case());
        m
    }
}
impl Value for BirchSaplingData {
    fn value(&self) -> usize {
        (self.stage.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct JungleSaplingData {
    stage: i32,
}
impl JungleSaplingData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            stage: i32::from_snake_case(map.get("stage")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("stage".to_string(), self.stage.to_snake_case());
        m
    }
}
impl Value for JungleSaplingData {
    fn value(&self) -> usize {
        (self.stage.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AcaciaSaplingData {
    stage: i32,
}
impl AcaciaSaplingData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            stage: i32::from_snake_case(map.get("stage")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("stage".to_string(), self.stage.to_snake_case());
        m
    }
}
impl Value for AcaciaSaplingData {
    fn value(&self) -> usize {
        (self.stage.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DarkOakSaplingData {
    stage: i32,
}
impl DarkOakSaplingData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            stage: i32::from_snake_case(map.get("stage")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("stage".to_string(), self.stage.to_snake_case());
        m
    }
}
impl Value for DarkOakSaplingData {
    fn value(&self) -> usize {
        (self.stage.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct WaterData {
    level: i32,
}
impl WaterData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            level: i32::from_snake_case(map.get("level")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("level".to_string(), self.level.to_snake_case());
        m
    }
}
impl Value for WaterData {
    fn value(&self) -> usize {
        (self.level.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LavaData {
    level: i32,
}
impl LavaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            level: i32::from_snake_case(map.get("level")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("level".to_string(), self.level.to_snake_case());
        m
    }
}
impl Value for LavaData {
    fn value(&self) -> usize {
        (self.level.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OakLogData {
    axis: Axis,
}
impl OakLogData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for OakLogData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SpruceLogData {
    axis: Axis,
}
impl SpruceLogData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for SpruceLogData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BirchLogData {
    axis: Axis,
}
impl BirchLogData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for BirchLogData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct JungleLogData {
    axis: Axis,
}
impl JungleLogData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for JungleLogData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AcaciaLogData {
    axis: Axis,
}
impl AcaciaLogData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for AcaciaLogData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DarkOakLogData {
    axis: Axis,
}
impl DarkOakLogData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for DarkOakLogData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StrippedSpruceLogData {
    axis: Axis,
}
impl StrippedSpruceLogData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for StrippedSpruceLogData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StrippedBirchLogData {
    axis: Axis,
}
impl StrippedBirchLogData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for StrippedBirchLogData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StrippedJungleLogData {
    axis: Axis,
}
impl StrippedJungleLogData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for StrippedJungleLogData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StrippedAcaciaLogData {
    axis: Axis,
}
impl StrippedAcaciaLogData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for StrippedAcaciaLogData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StrippedDarkOakLogData {
    axis: Axis,
}
impl StrippedDarkOakLogData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for StrippedDarkOakLogData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StrippedOakLogData {
    axis: Axis,
}
impl StrippedOakLogData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for StrippedOakLogData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OakWoodData {
    axis: Axis,
}
impl OakWoodData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for OakWoodData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SpruceWoodData {
    axis: Axis,
}
impl SpruceWoodData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for SpruceWoodData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BirchWoodData {
    axis: Axis,
}
impl BirchWoodData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for BirchWoodData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct JungleWoodData {
    axis: Axis,
}
impl JungleWoodData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for JungleWoodData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AcaciaWoodData {
    axis: Axis,
}
impl AcaciaWoodData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for AcaciaWoodData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DarkOakWoodData {
    axis: Axis,
}
impl DarkOakWoodData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for DarkOakWoodData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StrippedOakWoodData {
    axis: Axis,
}
impl StrippedOakWoodData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for StrippedOakWoodData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StrippedSpruceWoodData {
    axis: Axis,
}
impl StrippedSpruceWoodData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for StrippedSpruceWoodData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StrippedBirchWoodData {
    axis: Axis,
}
impl StrippedBirchWoodData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for StrippedBirchWoodData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StrippedJungleWoodData {
    axis: Axis,
}
impl StrippedJungleWoodData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for StrippedJungleWoodData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StrippedAcaciaWoodData {
    axis: Axis,
}
impl StrippedAcaciaWoodData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for StrippedAcaciaWoodData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StrippedDarkOakWoodData {
    axis: Axis,
}
impl StrippedDarkOakWoodData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for StrippedDarkOakWoodData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OakLeavesData {
    persistent: bool,
    distance: i32,
}
impl OakLeavesData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            persistent: bool::from_snake_case(map.get("persistent")?)?,
            distance: i32::from_snake_case(map.get("distance")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("persistent".to_string(), self.persistent.to_snake_case());
        m.insert("distance".to_string(), self.distance.to_snake_case());
        m
    }
}
impl Value for OakLeavesData {
    fn value(&self) -> usize {
        (self.persistent.value() * 7usize) + (self.distance.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SpruceLeavesData {
    distance: i32,
    persistent: bool,
}
impl SpruceLeavesData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            distance: i32::from_snake_case(map.get("distance")?)?,
            persistent: bool::from_snake_case(map.get("persistent")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("distance".to_string(), self.distance.to_snake_case());
        m.insert("persistent".to_string(), self.persistent.to_snake_case());
        m
    }
}
impl Value for SpruceLeavesData {
    fn value(&self) -> usize {
        (self.distance.value() * 2usize) + (self.persistent.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BirchLeavesData {
    distance: i32,
    persistent: bool,
}
impl BirchLeavesData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            distance: i32::from_snake_case(map.get("distance")?)?,
            persistent: bool::from_snake_case(map.get("persistent")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("distance".to_string(), self.distance.to_snake_case());
        m.insert("persistent".to_string(), self.persistent.to_snake_case());
        m
    }
}
impl Value for BirchLeavesData {
    fn value(&self) -> usize {
        (self.distance.value() * 2usize) + (self.persistent.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct JungleLeavesData {
    distance: i32,
    persistent: bool,
}
impl JungleLeavesData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            distance: i32::from_snake_case(map.get("distance")?)?,
            persistent: bool::from_snake_case(map.get("persistent")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("distance".to_string(), self.distance.to_snake_case());
        m.insert("persistent".to_string(), self.persistent.to_snake_case());
        m
    }
}
impl Value for JungleLeavesData {
    fn value(&self) -> usize {
        (self.distance.value() * 2usize) + (self.persistent.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AcaciaLeavesData {
    persistent: bool,
    distance: i32,
}
impl AcaciaLeavesData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            persistent: bool::from_snake_case(map.get("persistent")?)?,
            distance: i32::from_snake_case(map.get("distance")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("persistent".to_string(), self.persistent.to_snake_case());
        m.insert("distance".to_string(), self.distance.to_snake_case());
        m
    }
}
impl Value for AcaciaLeavesData {
    fn value(&self) -> usize {
        (self.persistent.value() * 7usize) + (self.distance.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DarkOakLeavesData {
    persistent: bool,
    distance: i32,
}
impl DarkOakLeavesData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            persistent: bool::from_snake_case(map.get("persistent")?)?,
            distance: i32::from_snake_case(map.get("distance")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("persistent".to_string(), self.persistent.to_snake_case());
        m.insert("distance".to_string(), self.distance.to_snake_case());
        m
    }
}
impl Value for DarkOakLeavesData {
    fn value(&self) -> usize {
        (self.persistent.value() * 7usize) + (self.distance.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DispenserData {
    triggered: bool,
    facing: Facing,
}
impl DispenserData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            triggered: bool::from_snake_case(map.get("triggered")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("triggered".to_string(), self.triggered.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for DispenserData {
    fn value(&self) -> usize {
        (self.triggered.value() * 6usize) + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct NoteBlockData {
    instrument: NoteBlockInstrument,
    powered: bool,
    note: i32,
}
impl NoteBlockData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            instrument: NoteBlockInstrument::from_snake_case(map.get("instrument")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            note: i32::from_snake_case(map.get("note")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("instrument".to_string(), self.instrument.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("note".to_string(), self.note.to_snake_case());
        m
    }
}
impl Value for NoteBlockData {
    fn value(&self) -> usize {
        (self.instrument.value() * 50usize)
            + (self.powered.value() * 25usize)
            + (self.note.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct WhiteBedData {
    occupied: bool,
    part: Part,
    facing: Facing,
}
impl WhiteBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            occupied: bool::from_snake_case(map.get("occupied")?)?,
            part: Part::from_snake_case(map.get("part")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m.insert("part".to_string(), self.part.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for WhiteBedData {
    fn value(&self) -> usize {
        (self.occupied.value() * 8usize)
            + (self.part.value() * 4usize)
            + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OrangeBedData {
    facing: Facing,
    occupied: bool,
    part: Part,
}
impl OrangeBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            occupied: bool::from_snake_case(map.get("occupied")?)?,
            part: Part::from_snake_case(map.get("part")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m.insert("part".to_string(), self.part.to_snake_case());
        m
    }
}
impl Value for OrangeBedData {
    fn value(&self) -> usize {
        (self.facing.value() * 4usize)
            + (self.occupied.value() * 2usize)
            + (self.part.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct MagentaBedData {
    facing: Facing,
    occupied: bool,
    part: Part,
}
impl MagentaBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            occupied: bool::from_snake_case(map.get("occupied")?)?,
            part: Part::from_snake_case(map.get("part")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m.insert("part".to_string(), self.part.to_snake_case());
        m
    }
}
impl Value for MagentaBedData {
    fn value(&self) -> usize {
        (self.facing.value() * 4usize)
            + (self.occupied.value() * 2usize)
            + (self.part.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LightBlueBedData {
    facing: Facing,
    part: Part,
    occupied: bool,
}
impl LightBlueBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            part: Part::from_snake_case(map.get("part")?)?,
            occupied: bool::from_snake_case(map.get("occupied")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("part".to_string(), self.part.to_snake_case());
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m
    }
}
impl Value for LightBlueBedData {
    fn value(&self) -> usize {
        (self.facing.value() * 4usize)
            + (self.part.value() * 2usize)
            + (self.occupied.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct YellowBedData {
    part: Part,
    facing: Facing,
    occupied: bool,
}
impl YellowBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            part: Part::from_snake_case(map.get("part")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            occupied: bool::from_snake_case(map.get("occupied")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("part".to_string(), self.part.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m
    }
}
impl Value for YellowBedData {
    fn value(&self) -> usize {
        (self.part.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.occupied.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LimeBedData {
    part: Part,
    facing: Facing,
    occupied: bool,
}
impl LimeBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            part: Part::from_snake_case(map.get("part")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            occupied: bool::from_snake_case(map.get("occupied")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("part".to_string(), self.part.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m
    }
}
impl Value for LimeBedData {
    fn value(&self) -> usize {
        (self.part.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.occupied.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PinkBedData {
    occupied: bool,
    facing: Facing,
    part: Part,
}
impl PinkBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            occupied: bool::from_snake_case(map.get("occupied")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            part: Part::from_snake_case(map.get("part")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("part".to_string(), self.part.to_snake_case());
        m
    }
}
impl Value for PinkBedData {
    fn value(&self) -> usize {
        (self.occupied.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.part.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct GrayBedData {
    occupied: bool,
    facing: Facing,
    part: Part,
}
impl GrayBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            occupied: bool::from_snake_case(map.get("occupied")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            part: Part::from_snake_case(map.get("part")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("part".to_string(), self.part.to_snake_case());
        m
    }
}
impl Value for GrayBedData {
    fn value(&self) -> usize {
        (self.occupied.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.part.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LightGrayBedData {
    part: Part,
    facing: Facing,
    occupied: bool,
}
impl LightGrayBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            part: Part::from_snake_case(map.get("part")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            occupied: bool::from_snake_case(map.get("occupied")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("part".to_string(), self.part.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m
    }
}
impl Value for LightGrayBedData {
    fn value(&self) -> usize {
        (self.part.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.occupied.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CyanBedData {
    facing: Facing,
    occupied: bool,
    part: Part,
}
impl CyanBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            occupied: bool::from_snake_case(map.get("occupied")?)?,
            part: Part::from_snake_case(map.get("part")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m.insert("part".to_string(), self.part.to_snake_case());
        m
    }
}
impl Value for CyanBedData {
    fn value(&self) -> usize {
        (self.facing.value() * 4usize)
            + (self.occupied.value() * 2usize)
            + (self.part.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PurpleBedData {
    occupied: bool,
    part: Part,
    facing: Facing,
}
impl PurpleBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            occupied: bool::from_snake_case(map.get("occupied")?)?,
            part: Part::from_snake_case(map.get("part")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m.insert("part".to_string(), self.part.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for PurpleBedData {
    fn value(&self) -> usize {
        (self.occupied.value() * 8usize)
            + (self.part.value() * 4usize)
            + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BlueBedData {
    facing: Facing,
    occupied: bool,
    part: Part,
}
impl BlueBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            occupied: bool::from_snake_case(map.get("occupied")?)?,
            part: Part::from_snake_case(map.get("part")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m.insert("part".to_string(), self.part.to_snake_case());
        m
    }
}
impl Value for BlueBedData {
    fn value(&self) -> usize {
        (self.facing.value() * 4usize)
            + (self.occupied.value() * 2usize)
            + (self.part.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BrownBedData {
    occupied: bool,
    facing: Facing,
    part: Part,
}
impl BrownBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            occupied: bool::from_snake_case(map.get("occupied")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            part: Part::from_snake_case(map.get("part")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("part".to_string(), self.part.to_snake_case());
        m
    }
}
impl Value for BrownBedData {
    fn value(&self) -> usize {
        (self.occupied.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.part.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct GreenBedData {
    occupied: bool,
    part: Part,
    facing: Facing,
}
impl GreenBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            occupied: bool::from_snake_case(map.get("occupied")?)?,
            part: Part::from_snake_case(map.get("part")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m.insert("part".to_string(), self.part.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for GreenBedData {
    fn value(&self) -> usize {
        (self.occupied.value() * 8usize)
            + (self.part.value() * 4usize)
            + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RedBedData {
    occupied: bool,
    facing: Facing,
    part: Part,
}
impl RedBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            occupied: bool::from_snake_case(map.get("occupied")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            part: Part::from_snake_case(map.get("part")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("part".to_string(), self.part.to_snake_case());
        m
    }
}
impl Value for RedBedData {
    fn value(&self) -> usize {
        (self.occupied.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.part.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BlackBedData {
    occupied: bool,
    facing: Facing,
    part: Part,
}
impl BlackBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            occupied: bool::from_snake_case(map.get("occupied")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            part: Part::from_snake_case(map.get("part")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("part".to_string(), self.part.to_snake_case());
        m
    }
}
impl Value for BlackBedData {
    fn value(&self) -> usize {
        (self.occupied.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.part.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PoweredRailData {
    shape: Shape,
    powered: bool,
}
impl PoweredRailData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            shape: Shape::from_snake_case(map.get("shape")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for PoweredRailData {
    fn value(&self) -> usize {
        (self.shape.value() * 2usize) + (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DetectorRailData {
    powered: bool,
    shape: Shape,
}
impl DetectorRailData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
            shape: Shape::from_snake_case(map.get("shape")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m
    }
}
impl Value for DetectorRailData {
    fn value(&self) -> usize {
        (self.powered.value() * 6usize) + (self.shape.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StickyPistonData {
    facing: Facing,
    extended: bool,
}
impl StickyPistonData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            extended: bool::from_snake_case(map.get("extended")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("extended".to_string(), self.extended.to_snake_case());
        m
    }
}
impl Value for StickyPistonData {
    fn value(&self) -> usize {
        (self.facing.value() * 2usize) + (self.extended.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct TallSeagrassData {
    half: Half,
}
impl TallSeagrassData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            half: Half::from_snake_case(map.get("half")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("half".to_string(), self.half.to_snake_case());
        m
    }
}
impl Value for TallSeagrassData {
    fn value(&self) -> usize {
        (self.half.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PistonData {
    facing: Facing,
    extended: bool,
}
impl PistonData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            extended: bool::from_snake_case(map.get("extended")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("extended".to_string(), self.extended.to_snake_case());
        m
    }
}
impl Value for PistonData {
    fn value(&self) -> usize {
        (self.facing.value() * 2usize) + (self.extended.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PistonHeadData {
    facing: Facing,
    ty: PistonHeadType,
    short: bool,
}
impl PistonHeadData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            ty: PistonHeadType::from_snake_case(map.get("type")?)?,
            short: bool::from_snake_case(map.get("short")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("type".to_string(), self.ty.to_snake_case());
        m.insert("short".to_string(), self.short.to_snake_case());
        m
    }
}
impl Value for PistonHeadData {
    fn value(&self) -> usize {
        (self.facing.value() * 4usize) + (self.ty.value() * 2usize) + (self.short.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct MovingPistonData {
    ty: MovingPistonType,
    facing: Facing,
}
impl MovingPistonData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            ty: MovingPistonType::from_snake_case(map.get("type")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("type".to_string(), self.ty.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for MovingPistonData {
    fn value(&self) -> usize {
        (self.ty.value() * 6usize) + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct TntData {
    unstable: bool,
}
impl TntData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            unstable: bool::from_snake_case(map.get("unstable")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("unstable".to_string(), self.unstable.to_snake_case());
        m
    }
}
impl Value for TntData {
    fn value(&self) -> usize {
        (self.unstable.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct WallTorchData {
    facing: Facing,
}
impl WallTorchData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for WallTorchData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct FireData {
    west: bool,
    east: bool,
    age: i32,
    north: bool,
    south: bool,
    up: bool,
}
impl FireData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            west: bool::from_snake_case(map.get("west")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            age: i32::from_snake_case(map.get("age")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            up: bool::from_snake_case(map.get("up")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("age".to_string(), self.age.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("up".to_string(), self.up.to_snake_case());
        m
    }
}
impl Value for FireData {
    fn value(&self) -> usize {
        (self.west.value() * 256usize)
            + (self.east.value() * 128usize)
            + (self.age.value() * 8usize)
            + (self.north.value() * 4usize)
            + (self.south.value() * 2usize)
            + (self.up.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OakStairsData {
    shape: Shape,
    facing: Facing,
    half: Half,
    waterlogged: bool,
}
impl OakStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            shape: Shape::from_snake_case(map.get("shape")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for OakStairsData {
    fn value(&self) -> usize {
        (self.shape.value() * 16usize)
            + (self.facing.value() * 4usize)
            + (self.half.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ChestData {
    waterlogged: bool,
    facing: Facing,
    ty: ChestType,
}
impl ChestData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            ty: ChestType::from_snake_case(map.get("type")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("type".to_string(), self.ty.to_snake_case());
        m
    }
}
impl Value for ChestData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 12usize)
            + (self.facing.value() * 3usize)
            + (self.ty.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RedstoneWireData {
    north: Facing,
    east: Facing,
    west: Facing,
    power: i32,
    south: Facing,
}
impl RedstoneWireData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            north: Facing::from_snake_case(map.get("north")?)?,
            east: Facing::from_snake_case(map.get("east")?)?,
            west: Facing::from_snake_case(map.get("west")?)?,
            power: i32::from_snake_case(map.get("power")?)?,
            south: Facing::from_snake_case(map.get("south")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("power".to_string(), self.power.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m
    }
}
impl Value for RedstoneWireData {
    fn value(&self) -> usize {
        (self.north.value() * 432usize)
            + (self.east.value() * 144usize)
            + (self.west.value() * 48usize)
            + (self.power.value() * 3usize)
            + (self.south.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct WheatData {
    age: i32,
}
impl WheatData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            age: i32::from_snake_case(map.get("age")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("age".to_string(), self.age.to_snake_case());
        m
    }
}
impl Value for WheatData {
    fn value(&self) -> usize {
        (self.age.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct FarmlandData {
    moisture: i32,
}
impl FarmlandData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            moisture: i32::from_snake_case(map.get("moisture")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("moisture".to_string(), self.moisture.to_snake_case());
        m
    }
}
impl Value for FarmlandData {
    fn value(&self) -> usize {
        (self.moisture.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct FurnaceData {
    lit: bool,
    facing: Facing,
}
impl FurnaceData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            lit: bool::from_snake_case(map.get("lit")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("lit".to_string(), self.lit.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for FurnaceData {
    fn value(&self) -> usize {
        (self.lit.value() * 4usize) + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SignData {
    rotation: i32,
    waterlogged: bool,
}
impl SignData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for SignData {
    fn value(&self) -> usize {
        (self.rotation.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OakDoorData {
    powered: bool,
    hinge: Hinge,
    half: Half,
    facing: Facing,
    open: bool,
}
impl OakDoorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
            hinge: Hinge::from_snake_case(map.get("hinge")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("hinge".to_string(), self.hinge.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m
    }
}
impl Value for OakDoorData {
    fn value(&self) -> usize {
        (self.powered.value() * 32usize)
            + (self.hinge.value() * 16usize)
            + (self.half.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.open.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LadderData {
    facing: Facing,
    waterlogged: bool,
}
impl LadderData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for LadderData {
    fn value(&self) -> usize {
        (self.facing.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RailData {
    shape: Shape,
}
impl RailData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            shape: Shape::from_snake_case(map.get("shape")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m
    }
}
impl Value for RailData {
    fn value(&self) -> usize {
        (self.shape.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CobblestoneStairsData {
    facing: Facing,
    half: Half,
    shape: Shape,
    waterlogged: bool,
}
impl CobblestoneStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
            shape: Shape::from_snake_case(map.get("shape")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for CobblestoneStairsData {
    fn value(&self) -> usize {
        (self.facing.value() * 20usize)
            + (self.half.value() * 10usize)
            + (self.shape.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct WallSignData {
    facing: Facing,
    waterlogged: bool,
}
impl WallSignData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for WallSignData {
    fn value(&self) -> usize {
        (self.facing.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LeverData {
    facing: Facing,
    powered: bool,
    face: Face,
}
impl LeverData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            face: Face::from_snake_case(map.get("face")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("face".to_string(), self.face.to_snake_case());
        m
    }
}
impl Value for LeverData {
    fn value(&self) -> usize {
        (self.facing.value() * 6usize)
            + (self.powered.value() * 3usize)
            + (self.face.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StonePressurePlateData {
    powered: bool,
}
impl StonePressurePlateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for StonePressurePlateData {
    fn value(&self) -> usize {
        (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct IronDoorData {
    hinge: Hinge,
    powered: bool,
    open: bool,
    facing: Facing,
    half: Half,
}
impl IronDoorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            hinge: Hinge::from_snake_case(map.get("hinge")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("hinge".to_string(), self.hinge.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m
    }
}
impl Value for IronDoorData {
    fn value(&self) -> usize {
        (self.hinge.value() * 32usize)
            + (self.powered.value() * 16usize)
            + (self.open.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.half.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OakPressurePlateData {
    powered: bool,
}
impl OakPressurePlateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for OakPressurePlateData {
    fn value(&self) -> usize {
        (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SprucePressurePlateData {
    powered: bool,
}
impl SprucePressurePlateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for SprucePressurePlateData {
    fn value(&self) -> usize {
        (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BirchPressurePlateData {
    powered: bool,
}
impl BirchPressurePlateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for BirchPressurePlateData {
    fn value(&self) -> usize {
        (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct JunglePressurePlateData {
    powered: bool,
}
impl JunglePressurePlateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for JunglePressurePlateData {
    fn value(&self) -> usize {
        (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AcaciaPressurePlateData {
    powered: bool,
}
impl AcaciaPressurePlateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for AcaciaPressurePlateData {
    fn value(&self) -> usize {
        (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DarkOakPressurePlateData {
    powered: bool,
}
impl DarkOakPressurePlateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for DarkOakPressurePlateData {
    fn value(&self) -> usize {
        (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RedstoneOreData {
    lit: bool,
}
impl RedstoneOreData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            lit: bool::from_snake_case(map.get("lit")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("lit".to_string(), self.lit.to_snake_case());
        m
    }
}
impl Value for RedstoneOreData {
    fn value(&self) -> usize {
        (self.lit.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RedstoneTorchData {
    lit: bool,
}
impl RedstoneTorchData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            lit: bool::from_snake_case(map.get("lit")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("lit".to_string(), self.lit.to_snake_case());
        m
    }
}
impl Value for RedstoneTorchData {
    fn value(&self) -> usize {
        (self.lit.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RedstoneWallTorchData {
    facing: Facing,
    lit: bool,
}
impl RedstoneWallTorchData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            lit: bool::from_snake_case(map.get("lit")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("lit".to_string(), self.lit.to_snake_case());
        m
    }
}
impl Value for RedstoneWallTorchData {
    fn value(&self) -> usize {
        (self.facing.value() * 2usize) + (self.lit.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StoneButtonData {
    face: Face,
    facing: Facing,
    powered: bool,
}
impl StoneButtonData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            face: Face::from_snake_case(map.get("face")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("face".to_string(), self.face.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for StoneButtonData {
    fn value(&self) -> usize {
        (self.face.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SnowData {
    layers: i32,
}
impl SnowData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            layers: i32::from_snake_case(map.get("layers")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("layers".to_string(), self.layers.to_snake_case());
        m
    }
}
impl Value for SnowData {
    fn value(&self) -> usize {
        (self.layers.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CactusData {
    age: i32,
}
impl CactusData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            age: i32::from_snake_case(map.get("age")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("age".to_string(), self.age.to_snake_case());
        m
    }
}
impl Value for CactusData {
    fn value(&self) -> usize {
        (self.age.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SugarCaneData {
    age: i32,
}
impl SugarCaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            age: i32::from_snake_case(map.get("age")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("age".to_string(), self.age.to_snake_case());
        m
    }
}
impl Value for SugarCaneData {
    fn value(&self) -> usize {
        (self.age.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct JukeboxData {
    has_record: bool,
}
impl JukeboxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            has_record: bool::from_snake_case(map.get("has_record")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("has_record".to_string(), self.has_record.to_snake_case());
        m
    }
}
impl Value for JukeboxData {
    fn value(&self) -> usize {
        (self.has_record.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OakFenceData {
    south: bool,
    waterlogged: bool,
    north: bool,
    west: bool,
    east: bool,
}
impl OakFenceData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            south: bool::from_snake_case(map.get("south")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m
    }
}
impl Value for OakFenceData {
    fn value(&self) -> usize {
        (self.south.value() * 16usize)
            + (self.waterlogged.value() * 8usize)
            + (self.north.value() * 4usize)
            + (self.west.value() * 2usize)
            + (self.east.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct NetherPortalData {
    axis: Axis,
}
impl NetherPortalData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for NetherPortalData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CarvedPumpkinData {
    facing: Facing,
}
impl CarvedPumpkinData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for CarvedPumpkinData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct JackOLanternData {
    facing: Facing,
}
impl JackOLanternData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for JackOLanternData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CakeData {
    bites: i32,
}
impl CakeData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            bites: i32::from_snake_case(map.get("bites")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("bites".to_string(), self.bites.to_snake_case());
        m
    }
}
impl Value for CakeData {
    fn value(&self) -> usize {
        (self.bites.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RepeaterData {
    powered: bool,
    delay: i32,
    facing: Facing,
    locked: bool,
}
impl RepeaterData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
            delay: i32::from_snake_case(map.get("delay")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            locked: bool::from_snake_case(map.get("locked")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("delay".to_string(), self.delay.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("locked".to_string(), self.locked.to_snake_case());
        m
    }
}
impl Value for RepeaterData {
    fn value(&self) -> usize {
        (self.powered.value() * 32usize)
            + (self.delay.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.locked.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OakTrapdoorData {
    waterlogged: bool,
    open: bool,
    facing: Facing,
    half: Half,
    powered: bool,
}
impl OakTrapdoorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for OakTrapdoorData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 32usize)
            + (self.open.value() * 16usize)
            + (self.facing.value() * 4usize)
            + (self.half.value() * 2usize)
            + (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SpruceTrapdoorData {
    half: Half,
    facing: Facing,
    open: bool,
    powered: bool,
    waterlogged: bool,
}
impl SpruceTrapdoorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            half: Half::from_snake_case(map.get("half")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for SpruceTrapdoorData {
    fn value(&self) -> usize {
        (self.half.value() * 32usize)
            + (self.facing.value() * 8usize)
            + (self.open.value() * 4usize)
            + (self.powered.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BirchTrapdoorData {
    open: bool,
    half: Half,
    facing: Facing,
    waterlogged: bool,
    powered: bool,
}
impl BirchTrapdoorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            open: bool::from_snake_case(map.get("open")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for BirchTrapdoorData {
    fn value(&self) -> usize {
        (self.open.value() * 32usize)
            + (self.half.value() * 16usize)
            + (self.facing.value() * 4usize)
            + (self.waterlogged.value() * 2usize)
            + (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct JungleTrapdoorData {
    open: bool,
    half: Half,
    powered: bool,
    facing: Facing,
    waterlogged: bool,
}
impl JungleTrapdoorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            open: bool::from_snake_case(map.get("open")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for JungleTrapdoorData {
    fn value(&self) -> usize {
        (self.open.value() * 32usize)
            + (self.half.value() * 16usize)
            + (self.powered.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AcaciaTrapdoorData {
    waterlogged: bool,
    facing: Facing,
    powered: bool,
    half: Half,
    open: bool,
}
impl AcaciaTrapdoorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m
    }
}
impl Value for AcaciaTrapdoorData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 32usize)
            + (self.facing.value() * 8usize)
            + (self.powered.value() * 4usize)
            + (self.half.value() * 2usize)
            + (self.open.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DarkOakTrapdoorData {
    open: bool,
    waterlogged: bool,
    powered: bool,
    facing: Facing,
    half: Half,
}
impl DarkOakTrapdoorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            open: bool::from_snake_case(map.get("open")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m
    }
}
impl Value for DarkOakTrapdoorData {
    fn value(&self) -> usize {
        (self.open.value() * 32usize)
            + (self.waterlogged.value() * 16usize)
            + (self.powered.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.half.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BrownMushroomBlockData {
    east: bool,
    south: bool,
    north: bool,
    up: bool,
    west: bool,
    down: bool,
}
impl BrownMushroomBlockData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            east: bool::from_snake_case(map.get("east")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            up: bool::from_snake_case(map.get("up")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            down: bool::from_snake_case(map.get("down")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("up".to_string(), self.up.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("down".to_string(), self.down.to_snake_case());
        m
    }
}
impl Value for BrownMushroomBlockData {
    fn value(&self) -> usize {
        (self.east.value() * 32usize)
            + (self.south.value() * 16usize)
            + (self.north.value() * 8usize)
            + (self.up.value() * 4usize)
            + (self.west.value() * 2usize)
            + (self.down.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RedMushroomBlockData {
    down: bool,
    up: bool,
    south: bool,
    east: bool,
    west: bool,
    north: bool,
}
impl RedMushroomBlockData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            down: bool::from_snake_case(map.get("down")?)?,
            up: bool::from_snake_case(map.get("up")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("down".to_string(), self.down.to_snake_case());
        m.insert("up".to_string(), self.up.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m
    }
}
impl Value for RedMushroomBlockData {
    fn value(&self) -> usize {
        (self.down.value() * 32usize)
            + (self.up.value() * 16usize)
            + (self.south.value() * 8usize)
            + (self.east.value() * 4usize)
            + (self.west.value() * 2usize)
            + (self.north.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct MushroomStemData {
    south: bool,
    up: bool,
    down: bool,
    west: bool,
    east: bool,
    north: bool,
}
impl MushroomStemData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            south: bool::from_snake_case(map.get("south")?)?,
            up: bool::from_snake_case(map.get("up")?)?,
            down: bool::from_snake_case(map.get("down")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("up".to_string(), self.up.to_snake_case());
        m.insert("down".to_string(), self.down.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m
    }
}
impl Value for MushroomStemData {
    fn value(&self) -> usize {
        (self.south.value() * 32usize)
            + (self.up.value() * 16usize)
            + (self.down.value() * 8usize)
            + (self.west.value() * 4usize)
            + (self.east.value() * 2usize)
            + (self.north.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct IronBarsData {
    east: bool,
    west: bool,
    north: bool,
    south: bool,
    waterlogged: bool,
}
impl IronBarsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            east: bool::from_snake_case(map.get("east")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for IronBarsData {
    fn value(&self) -> usize {
        (self.east.value() * 16usize)
            + (self.west.value() * 8usize)
            + (self.north.value() * 4usize)
            + (self.south.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct GlassPaneData {
    west: bool,
    north: bool,
    south: bool,
    waterlogged: bool,
    east: bool,
}
impl GlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            west: bool::from_snake_case(map.get("west")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m
    }
}
impl Value for GlassPaneData {
    fn value(&self) -> usize {
        (self.west.value() * 16usize)
            + (self.north.value() * 8usize)
            + (self.south.value() * 4usize)
            + (self.waterlogged.value() * 2usize)
            + (self.east.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AttachedPumpkinStemData {
    facing: Facing,
}
impl AttachedPumpkinStemData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for AttachedPumpkinStemData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AttachedMelonStemData {
    facing: Facing,
}
impl AttachedMelonStemData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for AttachedMelonStemData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PumpkinStemData {
    age: i32,
}
impl PumpkinStemData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            age: i32::from_snake_case(map.get("age")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("age".to_string(), self.age.to_snake_case());
        m
    }
}
impl Value for PumpkinStemData {
    fn value(&self) -> usize {
        (self.age.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct MelonStemData {
    age: i32,
}
impl MelonStemData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            age: i32::from_snake_case(map.get("age")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("age".to_string(), self.age.to_snake_case());
        m
    }
}
impl Value for MelonStemData {
    fn value(&self) -> usize {
        (self.age.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct VineData {
    east: bool,
    south: bool,
    north: bool,
    up: bool,
    west: bool,
}
impl VineData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            east: bool::from_snake_case(map.get("east")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            up: bool::from_snake_case(map.get("up")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("up".to_string(), self.up.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m
    }
}
impl Value for VineData {
    fn value(&self) -> usize {
        (self.east.value() * 16usize)
            + (self.south.value() * 8usize)
            + (self.north.value() * 4usize)
            + (self.up.value() * 2usize)
            + (self.west.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OakFenceGateData {
    facing: Facing,
    in_wall: bool,
    open: bool,
    powered: bool,
}
impl OakFenceGateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            in_wall: bool::from_snake_case(map.get("in_wall")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("in_wall".to_string(), self.in_wall.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for OakFenceGateData {
    fn value(&self) -> usize {
        (self.facing.value() * 8usize)
            + (self.in_wall.value() * 4usize)
            + (self.open.value() * 2usize)
            + (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BrickStairsData {
    half: Half,
    facing: Facing,
    shape: Shape,
    waterlogged: bool,
}
impl BrickStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            half: Half::from_snake_case(map.get("half")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            shape: Shape::from_snake_case(map.get("shape")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for BrickStairsData {
    fn value(&self) -> usize {
        (self.half.value() * 40usize)
            + (self.facing.value() * 10usize)
            + (self.shape.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StoneBrickStairsData {
    facing: Facing,
    half: Half,
    shape: Shape,
    waterlogged: bool,
}
impl StoneBrickStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
            shape: Shape::from_snake_case(map.get("shape")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for StoneBrickStairsData {
    fn value(&self) -> usize {
        (self.facing.value() * 20usize)
            + (self.half.value() * 10usize)
            + (self.shape.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct MyceliumData {
    snowy: bool,
}
impl MyceliumData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            snowy: bool::from_snake_case(map.get("snowy")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("snowy".to_string(), self.snowy.to_snake_case());
        m
    }
}
impl Value for MyceliumData {
    fn value(&self) -> usize {
        (self.snowy.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct NetherBrickFenceData {
    north: bool,
    waterlogged: bool,
    west: bool,
    east: bool,
    south: bool,
}
impl NetherBrickFenceData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            north: bool::from_snake_case(map.get("north")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m
    }
}
impl Value for NetherBrickFenceData {
    fn value(&self) -> usize {
        (self.north.value() * 16usize)
            + (self.waterlogged.value() * 8usize)
            + (self.west.value() * 4usize)
            + (self.east.value() * 2usize)
            + (self.south.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct NetherBrickStairsData {
    half: Half,
    shape: Shape,
    facing: Facing,
    waterlogged: bool,
}
impl NetherBrickStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            half: Half::from_snake_case(map.get("half")?)?,
            shape: Shape::from_snake_case(map.get("shape")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for NetherBrickStairsData {
    fn value(&self) -> usize {
        (self.half.value() * 40usize)
            + (self.shape.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct NetherWartData {
    age: i32,
}
impl NetherWartData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            age: i32::from_snake_case(map.get("age")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("age".to_string(), self.age.to_snake_case());
        m
    }
}
impl Value for NetherWartData {
    fn value(&self) -> usize {
        (self.age.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BrewingStandData {
    has_bottle_2: bool,
    has_bottle_0: bool,
    has_bottle_1: bool,
}
impl BrewingStandData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            has_bottle_2: bool::from_snake_case(map.get("has_bottle_2")?)?,
            has_bottle_0: bool::from_snake_case(map.get("has_bottle_0")?)?,
            has_bottle_1: bool::from_snake_case(map.get("has_bottle_1")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert(
            "has_bottle_2".to_string(),
            self.has_bottle_2.to_snake_case(),
        );
        m.insert(
            "has_bottle_0".to_string(),
            self.has_bottle_0.to_snake_case(),
        );
        m.insert(
            "has_bottle_1".to_string(),
            self.has_bottle_1.to_snake_case(),
        );
        m
    }
}
impl Value for BrewingStandData {
    fn value(&self) -> usize {
        (self.has_bottle_2.value() * 4usize)
            + (self.has_bottle_0.value() * 2usize)
            + (self.has_bottle_1.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CauldronData {
    level: i32,
}
impl CauldronData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            level: i32::from_snake_case(map.get("level")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("level".to_string(), self.level.to_snake_case());
        m
    }
}
impl Value for CauldronData {
    fn value(&self) -> usize {
        (self.level.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct EndPortalFrameData {
    facing: Facing,
    eye: bool,
}
impl EndPortalFrameData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            eye: bool::from_snake_case(map.get("eye")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("eye".to_string(), self.eye.to_snake_case());
        m
    }
}
impl Value for EndPortalFrameData {
    fn value(&self) -> usize {
        (self.facing.value() * 2usize) + (self.eye.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RedstoneLampData {
    lit: bool,
}
impl RedstoneLampData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            lit: bool::from_snake_case(map.get("lit")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("lit".to_string(), self.lit.to_snake_case());
        m
    }
}
impl Value for RedstoneLampData {
    fn value(&self) -> usize {
        (self.lit.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CocoaData {
    facing: Facing,
    age: i32,
}
impl CocoaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            age: i32::from_snake_case(map.get("age")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("age".to_string(), self.age.to_snake_case());
        m
    }
}
impl Value for CocoaData {
    fn value(&self) -> usize {
        (self.facing.value() * 3usize) + (self.age.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SandstoneStairsData {
    facing: Facing,
    waterlogged: bool,
    shape: Shape,
    half: Half,
}
impl SandstoneStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            shape: Shape::from_snake_case(map.get("shape")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m
    }
}
impl Value for SandstoneStairsData {
    fn value(&self) -> usize {
        (self.facing.value() * 20usize)
            + (self.waterlogged.value() * 10usize)
            + (self.shape.value() * 2usize)
            + (self.half.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct EnderChestData {
    facing: Facing,
    waterlogged: bool,
}
impl EnderChestData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for EnderChestData {
    fn value(&self) -> usize {
        (self.facing.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct TripwireHookData {
    powered: bool,
    attached: bool,
    facing: Facing,
}
impl TripwireHookData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
            attached: bool::from_snake_case(map.get("attached")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("attached".to_string(), self.attached.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for TripwireHookData {
    fn value(&self) -> usize {
        (self.powered.value() * 8usize)
            + (self.attached.value() * 4usize)
            + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct TripwireData {
    disarmed: bool,
    powered: bool,
    attached: bool,
    east: bool,
    south: bool,
    west: bool,
    north: bool,
}
impl TripwireData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            disarmed: bool::from_snake_case(map.get("disarmed")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            attached: bool::from_snake_case(map.get("attached")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("disarmed".to_string(), self.disarmed.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("attached".to_string(), self.attached.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m
    }
}
impl Value for TripwireData {
    fn value(&self) -> usize {
        (self.disarmed.value() * 64usize)
            + (self.powered.value() * 32usize)
            + (self.attached.value() * 16usize)
            + (self.east.value() * 8usize)
            + (self.south.value() * 4usize)
            + (self.west.value() * 2usize)
            + (self.north.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SpruceStairsData {
    shape: Shape,
    waterlogged: bool,
    facing: Facing,
    half: Half,
}
impl SpruceStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            shape: Shape::from_snake_case(map.get("shape")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m
    }
}
impl Value for SpruceStairsData {
    fn value(&self) -> usize {
        (self.shape.value() * 16usize)
            + (self.waterlogged.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.half.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BirchStairsData {
    facing: Facing,
    waterlogged: bool,
    shape: Shape,
    half: Half,
}
impl BirchStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            shape: Shape::from_snake_case(map.get("shape")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m
    }
}
impl Value for BirchStairsData {
    fn value(&self) -> usize {
        (self.facing.value() * 20usize)
            + (self.waterlogged.value() * 10usize)
            + (self.shape.value() * 2usize)
            + (self.half.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct JungleStairsData {
    half: Half,
    shape: Shape,
    facing: Facing,
    waterlogged: bool,
}
impl JungleStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            half: Half::from_snake_case(map.get("half")?)?,
            shape: Shape::from_snake_case(map.get("shape")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for JungleStairsData {
    fn value(&self) -> usize {
        (self.half.value() * 40usize)
            + (self.shape.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CommandBlockData {
    facing: Facing,
    conditional: bool,
}
impl CommandBlockData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            conditional: bool::from_snake_case(map.get("conditional")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("conditional".to_string(), self.conditional.to_snake_case());
        m
    }
}
impl Value for CommandBlockData {
    fn value(&self) -> usize {
        (self.facing.value() * 2usize) + (self.conditional.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CobblestoneWallData {
    north: bool,
    waterlogged: bool,
    east: bool,
    up: bool,
    south: bool,
    west: bool,
}
impl CobblestoneWallData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            north: bool::from_snake_case(map.get("north")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            up: bool::from_snake_case(map.get("up")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("up".to_string(), self.up.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m
    }
}
impl Value for CobblestoneWallData {
    fn value(&self) -> usize {
        (self.north.value() * 32usize)
            + (self.waterlogged.value() * 16usize)
            + (self.east.value() * 8usize)
            + (self.up.value() * 4usize)
            + (self.south.value() * 2usize)
            + (self.west.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct MossyCobblestoneWallData {
    west: bool,
    up: bool,
    waterlogged: bool,
    east: bool,
    north: bool,
    south: bool,
}
impl MossyCobblestoneWallData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            west: bool::from_snake_case(map.get("west")?)?,
            up: bool::from_snake_case(map.get("up")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("up".to_string(), self.up.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m
    }
}
impl Value for MossyCobblestoneWallData {
    fn value(&self) -> usize {
        (self.west.value() * 32usize)
            + (self.up.value() * 16usize)
            + (self.waterlogged.value() * 8usize)
            + (self.east.value() * 4usize)
            + (self.north.value() * 2usize)
            + (self.south.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CarrotsData {
    age: i32,
}
impl CarrotsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            age: i32::from_snake_case(map.get("age")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("age".to_string(), self.age.to_snake_case());
        m
    }
}
impl Value for CarrotsData {
    fn value(&self) -> usize {
        (self.age.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PotatoesData {
    age: i32,
}
impl PotatoesData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            age: i32::from_snake_case(map.get("age")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("age".to_string(), self.age.to_snake_case());
        m
    }
}
impl Value for PotatoesData {
    fn value(&self) -> usize {
        (self.age.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OakButtonData {
    face: Face,
    facing: Facing,
    powered: bool,
}
impl OakButtonData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            face: Face::from_snake_case(map.get("face")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("face".to_string(), self.face.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for OakButtonData {
    fn value(&self) -> usize {
        (self.face.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SpruceButtonData {
    facing: Facing,
    powered: bool,
    face: Face,
}
impl SpruceButtonData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            face: Face::from_snake_case(map.get("face")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("face".to_string(), self.face.to_snake_case());
        m
    }
}
impl Value for SpruceButtonData {
    fn value(&self) -> usize {
        (self.facing.value() * 6usize)
            + (self.powered.value() * 3usize)
            + (self.face.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BirchButtonData {
    face: Face,
    facing: Facing,
    powered: bool,
}
impl BirchButtonData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            face: Face::from_snake_case(map.get("face")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("face".to_string(), self.face.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for BirchButtonData {
    fn value(&self) -> usize {
        (self.face.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct JungleButtonData {
    face: Face,
    facing: Facing,
    powered: bool,
}
impl JungleButtonData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            face: Face::from_snake_case(map.get("face")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("face".to_string(), self.face.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for JungleButtonData {
    fn value(&self) -> usize {
        (self.face.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AcaciaButtonData {
    powered: bool,
    facing: Facing,
    face: Face,
}
impl AcaciaButtonData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            face: Face::from_snake_case(map.get("face")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("face".to_string(), self.face.to_snake_case());
        m
    }
}
impl Value for AcaciaButtonData {
    fn value(&self) -> usize {
        (self.powered.value() * 12usize)
            + (self.facing.value() * 3usize)
            + (self.face.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DarkOakButtonData {
    face: Face,
    facing: Facing,
    powered: bool,
}
impl DarkOakButtonData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            face: Face::from_snake_case(map.get("face")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("face".to_string(), self.face.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for DarkOakButtonData {
    fn value(&self) -> usize {
        (self.face.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SkeletonWallSkullData {
    facing: Facing,
}
impl SkeletonWallSkullData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for SkeletonWallSkullData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SkeletonSkullData {
    rotation: i32,
}
impl SkeletonSkullData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for SkeletonSkullData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct WitherSkeletonWallSkullData {
    facing: Facing,
}
impl WitherSkeletonWallSkullData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for WitherSkeletonWallSkullData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct WitherSkeletonSkullData {
    rotation: i32,
}
impl WitherSkeletonSkullData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for WitherSkeletonSkullData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ZombieWallHeadData {
    facing: Facing,
}
impl ZombieWallHeadData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for ZombieWallHeadData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ZombieHeadData {
    rotation: i32,
}
impl ZombieHeadData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for ZombieHeadData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PlayerWallHeadData {
    facing: Facing,
}
impl PlayerWallHeadData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for PlayerWallHeadData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PlayerHeadData {
    rotation: i32,
}
impl PlayerHeadData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for PlayerHeadData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CreeperWallHeadData {
    facing: Facing,
}
impl CreeperWallHeadData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for CreeperWallHeadData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CreeperHeadData {
    rotation: i32,
}
impl CreeperHeadData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for CreeperHeadData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DragonWallHeadData {
    facing: Facing,
}
impl DragonWallHeadData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for DragonWallHeadData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DragonHeadData {
    rotation: i32,
}
impl DragonHeadData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for DragonHeadData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AnvilData {
    facing: Facing,
}
impl AnvilData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for AnvilData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ChippedAnvilData {
    facing: Facing,
}
impl ChippedAnvilData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for ChippedAnvilData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DamagedAnvilData {
    facing: Facing,
}
impl DamagedAnvilData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for DamagedAnvilData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct TrappedChestData {
    facing: Facing,
    waterlogged: bool,
    ty: TrappedChestType,
}
impl TrappedChestData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            ty: TrappedChestType::from_snake_case(map.get("type")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("type".to_string(), self.ty.to_snake_case());
        m
    }
}
impl Value for TrappedChestData {
    fn value(&self) -> usize {
        (self.facing.value() * 6usize)
            + (self.waterlogged.value() * 3usize)
            + (self.ty.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LightWeightedPressurePlateData {
    power: i32,
}
impl LightWeightedPressurePlateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            power: i32::from_snake_case(map.get("power")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("power".to_string(), self.power.to_snake_case());
        m
    }
}
impl Value for LightWeightedPressurePlateData {
    fn value(&self) -> usize {
        (self.power.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct HeavyWeightedPressurePlateData {
    power: i32,
}
impl HeavyWeightedPressurePlateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            power: i32::from_snake_case(map.get("power")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("power".to_string(), self.power.to_snake_case());
        m
    }
}
impl Value for HeavyWeightedPressurePlateData {
    fn value(&self) -> usize {
        (self.power.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ComparatorData {
    facing: Facing,
    powered: bool,
    mode: ComparatorMode,
}
impl ComparatorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            mode: ComparatorMode::from_snake_case(map.get("mode")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("mode".to_string(), self.mode.to_snake_case());
        m
    }
}
impl Value for ComparatorData {
    fn value(&self) -> usize {
        (self.facing.value() * 4usize)
            + (self.powered.value() * 2usize)
            + (self.mode.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DaylightDetectorData {
    inverted: bool,
    power: i32,
}
impl DaylightDetectorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            inverted: bool::from_snake_case(map.get("inverted")?)?,
            power: i32::from_snake_case(map.get("power")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("inverted".to_string(), self.inverted.to_snake_case());
        m.insert("power".to_string(), self.power.to_snake_case());
        m
    }
}
impl Value for DaylightDetectorData {
    fn value(&self) -> usize {
        (self.inverted.value() * 16usize) + (self.power.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct HopperData {
    facing: Facing,
    enabled: bool,
}
impl HopperData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            enabled: bool::from_snake_case(map.get("enabled")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("enabled".to_string(), self.enabled.to_snake_case());
        m
    }
}
impl Value for HopperData {
    fn value(&self) -> usize {
        (self.facing.value() * 2usize) + (self.enabled.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct QuartzPillarData {
    axis: Axis,
}
impl QuartzPillarData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for QuartzPillarData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct QuartzStairsData {
    facing: Facing,
    half: Half,
    waterlogged: bool,
    shape: Shape,
}
impl QuartzStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            shape: Shape::from_snake_case(map.get("shape")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m
    }
}
impl Value for QuartzStairsData {
    fn value(&self) -> usize {
        (self.facing.value() * 20usize)
            + (self.half.value() * 10usize)
            + (self.waterlogged.value() * 5usize)
            + (self.shape.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ActivatorRailData {
    shape: Shape,
    powered: bool,
}
impl ActivatorRailData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            shape: Shape::from_snake_case(map.get("shape")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for ActivatorRailData {
    fn value(&self) -> usize {
        (self.shape.value() * 2usize) + (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DropperData {
    triggered: bool,
    facing: Facing,
}
impl DropperData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            triggered: bool::from_snake_case(map.get("triggered")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("triggered".to_string(), self.triggered.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for DropperData {
    fn value(&self) -> usize {
        (self.triggered.value() * 6usize) + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct WhiteStainedGlassPaneData {
    south: bool,
    east: bool,
    waterlogged: bool,
    west: bool,
    north: bool,
}
impl WhiteStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            south: bool::from_snake_case(map.get("south")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m
    }
}
impl Value for WhiteStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.south.value() * 16usize)
            + (self.east.value() * 8usize)
            + (self.waterlogged.value() * 4usize)
            + (self.west.value() * 2usize)
            + (self.north.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OrangeStainedGlassPaneData {
    waterlogged: bool,
    north: bool,
    east: bool,
    west: bool,
    south: bool,
}
impl OrangeStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m
    }
}
impl Value for OrangeStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 16usize)
            + (self.north.value() * 8usize)
            + (self.east.value() * 4usize)
            + (self.west.value() * 2usize)
            + (self.south.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct MagentaStainedGlassPaneData {
    east: bool,
    west: bool,
    waterlogged: bool,
    south: bool,
    north: bool,
}
impl MagentaStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            east: bool::from_snake_case(map.get("east")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m
    }
}
impl Value for MagentaStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.east.value() * 16usize)
            + (self.west.value() * 8usize)
            + (self.waterlogged.value() * 4usize)
            + (self.south.value() * 2usize)
            + (self.north.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LightBlueStainedGlassPaneData {
    south: bool,
    north: bool,
    east: bool,
    waterlogged: bool,
    west: bool,
}
impl LightBlueStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            south: bool::from_snake_case(map.get("south")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m
    }
}
impl Value for LightBlueStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.south.value() * 16usize)
            + (self.north.value() * 8usize)
            + (self.east.value() * 4usize)
            + (self.waterlogged.value() * 2usize)
            + (self.west.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct YellowStainedGlassPaneData {
    waterlogged: bool,
    south: bool,
    east: bool,
    north: bool,
    west: bool,
}
impl YellowStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m
    }
}
impl Value for YellowStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 16usize)
            + (self.south.value() * 8usize)
            + (self.east.value() * 4usize)
            + (self.north.value() * 2usize)
            + (self.west.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LimeStainedGlassPaneData {
    west: bool,
    waterlogged: bool,
    south: bool,
    east: bool,
    north: bool,
}
impl LimeStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            west: bool::from_snake_case(map.get("west")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m
    }
}
impl Value for LimeStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.west.value() * 16usize)
            + (self.waterlogged.value() * 8usize)
            + (self.south.value() * 4usize)
            + (self.east.value() * 2usize)
            + (self.north.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PinkStainedGlassPaneData {
    north: bool,
    east: bool,
    waterlogged: bool,
    west: bool,
    south: bool,
}
impl PinkStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            north: bool::from_snake_case(map.get("north")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m
    }
}
impl Value for PinkStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.north.value() * 16usize)
            + (self.east.value() * 8usize)
            + (self.waterlogged.value() * 4usize)
            + (self.west.value() * 2usize)
            + (self.south.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct GrayStainedGlassPaneData {
    north: bool,
    south: bool,
    west: bool,
    east: bool,
    waterlogged: bool,
}
impl GrayStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            north: bool::from_snake_case(map.get("north")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for GrayStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.north.value() * 16usize)
            + (self.south.value() * 8usize)
            + (self.west.value() * 4usize)
            + (self.east.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LightGrayStainedGlassPaneData {
    waterlogged: bool,
    south: bool,
    east: bool,
    north: bool,
    west: bool,
}
impl LightGrayStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m
    }
}
impl Value for LightGrayStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 16usize)
            + (self.south.value() * 8usize)
            + (self.east.value() * 4usize)
            + (self.north.value() * 2usize)
            + (self.west.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CyanStainedGlassPaneData {
    east: bool,
    waterlogged: bool,
    south: bool,
    north: bool,
    west: bool,
}
impl CyanStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            east: bool::from_snake_case(map.get("east")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m
    }
}
impl Value for CyanStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.east.value() * 16usize)
            + (self.waterlogged.value() * 8usize)
            + (self.south.value() * 4usize)
            + (self.north.value() * 2usize)
            + (self.west.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PurpleStainedGlassPaneData {
    east: bool,
    south: bool,
    west: bool,
    north: bool,
    waterlogged: bool,
}
impl PurpleStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            east: bool::from_snake_case(map.get("east")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for PurpleStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.east.value() * 16usize)
            + (self.south.value() * 8usize)
            + (self.west.value() * 4usize)
            + (self.north.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BlueStainedGlassPaneData {
    waterlogged: bool,
    north: bool,
    west: bool,
    south: bool,
    east: bool,
}
impl BlueStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m
    }
}
impl Value for BlueStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 16usize)
            + (self.north.value() * 8usize)
            + (self.west.value() * 4usize)
            + (self.south.value() * 2usize)
            + (self.east.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BrownStainedGlassPaneData {
    waterlogged: bool,
    west: bool,
    north: bool,
    east: bool,
    south: bool,
}
impl BrownStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m
    }
}
impl Value for BrownStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 16usize)
            + (self.west.value() * 8usize)
            + (self.north.value() * 4usize)
            + (self.east.value() * 2usize)
            + (self.south.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct GreenStainedGlassPaneData {
    waterlogged: bool,
    west: bool,
    east: bool,
    north: bool,
    south: bool,
}
impl GreenStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m
    }
}
impl Value for GreenStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 16usize)
            + (self.west.value() * 8usize)
            + (self.east.value() * 4usize)
            + (self.north.value() * 2usize)
            + (self.south.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RedStainedGlassPaneData {
    east: bool,
    waterlogged: bool,
    west: bool,
    south: bool,
    north: bool,
}
impl RedStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            east: bool::from_snake_case(map.get("east")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m
    }
}
impl Value for RedStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.east.value() * 16usize)
            + (self.waterlogged.value() * 8usize)
            + (self.west.value() * 4usize)
            + (self.south.value() * 2usize)
            + (self.north.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BlackStainedGlassPaneData {
    north: bool,
    west: bool,
    east: bool,
    waterlogged: bool,
    south: bool,
}
impl BlackStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            north: bool::from_snake_case(map.get("north")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m
    }
}
impl Value for BlackStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.north.value() * 16usize)
            + (self.west.value() * 8usize)
            + (self.east.value() * 4usize)
            + (self.waterlogged.value() * 2usize)
            + (self.south.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AcaciaStairsData {
    half: Half,
    shape: Shape,
    waterlogged: bool,
    facing: Facing,
}
impl AcaciaStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            half: Half::from_snake_case(map.get("half")?)?,
            shape: Shape::from_snake_case(map.get("shape")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for AcaciaStairsData {
    fn value(&self) -> usize {
        (self.half.value() * 40usize)
            + (self.shape.value() * 8usize)
            + (self.waterlogged.value() * 4usize)
            + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DarkOakStairsData {
    waterlogged: bool,
    half: Half,
    facing: Facing,
    shape: Shape,
}
impl DarkOakStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            shape: Shape::from_snake_case(map.get("shape")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m
    }
}
impl Value for DarkOakStairsData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 40usize)
            + (self.half.value() * 20usize)
            + (self.facing.value() * 5usize)
            + (self.shape.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct IronTrapdoorData {
    waterlogged: bool,
    open: bool,
    half: Half,
    facing: Facing,
    powered: bool,
}
impl IronTrapdoorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for IronTrapdoorData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 32usize)
            + (self.open.value() * 16usize)
            + (self.half.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PrismarineStairsData {
    half: Half,
    shape: Shape,
    facing: Facing,
    waterlogged: bool,
}
impl PrismarineStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            half: Half::from_snake_case(map.get("half")?)?,
            shape: Shape::from_snake_case(map.get("shape")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for PrismarineStairsData {
    fn value(&self) -> usize {
        (self.half.value() * 40usize)
            + (self.shape.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PrismarineBrickStairsData {
    half: Half,
    facing: Facing,
    shape: Shape,
    waterlogged: bool,
}
impl PrismarineBrickStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            half: Half::from_snake_case(map.get("half")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            shape: Shape::from_snake_case(map.get("shape")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for PrismarineBrickStairsData {
    fn value(&self) -> usize {
        (self.half.value() * 40usize)
            + (self.facing.value() * 10usize)
            + (self.shape.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DarkPrismarineStairsData {
    facing: Facing,
    half: Half,
    shape: Shape,
    waterlogged: bool,
}
impl DarkPrismarineStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
            shape: Shape::from_snake_case(map.get("shape")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for DarkPrismarineStairsData {
    fn value(&self) -> usize {
        (self.facing.value() * 20usize)
            + (self.half.value() * 10usize)
            + (self.shape.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PrismarineSlabData {
    waterlogged: bool,
    ty: Half,
}
impl PrismarineSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            ty: Half::from_snake_case(map.get("type")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("type".to_string(), self.ty.to_snake_case());
        m
    }
}
impl Value for PrismarineSlabData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 3usize) + (self.ty.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PrismarineBrickSlabData {
    waterlogged: bool,
    ty: Half,
}
impl PrismarineBrickSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            ty: Half::from_snake_case(map.get("type")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("type".to_string(), self.ty.to_snake_case());
        m
    }
}
impl Value for PrismarineBrickSlabData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 3usize) + (self.ty.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DarkPrismarineSlabData {
    waterlogged: bool,
    ty: Half,
}
impl DarkPrismarineSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            ty: Half::from_snake_case(map.get("type")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("type".to_string(), self.ty.to_snake_case());
        m
    }
}
impl Value for DarkPrismarineSlabData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 3usize) + (self.ty.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct HayBlockData {
    axis: Axis,
}
impl HayBlockData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for HayBlockData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SunflowerData {
    half: Half,
}
impl SunflowerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            half: Half::from_snake_case(map.get("half")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("half".to_string(), self.half.to_snake_case());
        m
    }
}
impl Value for SunflowerData {
    fn value(&self) -> usize {
        (self.half.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LilacData {
    half: Half,
}
impl LilacData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            half: Half::from_snake_case(map.get("half")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("half".to_string(), self.half.to_snake_case());
        m
    }
}
impl Value for LilacData {
    fn value(&self) -> usize {
        (self.half.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RoseBushData {
    half: Half,
}
impl RoseBushData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            half: Half::from_snake_case(map.get("half")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("half".to_string(), self.half.to_snake_case());
        m
    }
}
impl Value for RoseBushData {
    fn value(&self) -> usize {
        (self.half.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PeonyData {
    half: Half,
}
impl PeonyData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            half: Half::from_snake_case(map.get("half")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("half".to_string(), self.half.to_snake_case());
        m
    }
}
impl Value for PeonyData {
    fn value(&self) -> usize {
        (self.half.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct TallGrassData {
    half: Half,
}
impl TallGrassData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            half: Half::from_snake_case(map.get("half")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("half".to_string(), self.half.to_snake_case());
        m
    }
}
impl Value for TallGrassData {
    fn value(&self) -> usize {
        (self.half.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LargeFernData {
    half: Half,
}
impl LargeFernData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            half: Half::from_snake_case(map.get("half")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("half".to_string(), self.half.to_snake_case());
        m
    }
}
impl Value for LargeFernData {
    fn value(&self) -> usize {
        (self.half.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct WhiteBannerData {
    rotation: i32,
}
impl WhiteBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for WhiteBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OrangeBannerData {
    rotation: i32,
}
impl OrangeBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for OrangeBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct MagentaBannerData {
    rotation: i32,
}
impl MagentaBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for MagentaBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LightBlueBannerData {
    rotation: i32,
}
impl LightBlueBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for LightBlueBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct YellowBannerData {
    rotation: i32,
}
impl YellowBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for YellowBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LimeBannerData {
    rotation: i32,
}
impl LimeBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for LimeBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PinkBannerData {
    rotation: i32,
}
impl PinkBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for PinkBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct GrayBannerData {
    rotation: i32,
}
impl GrayBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for GrayBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LightGrayBannerData {
    rotation: i32,
}
impl LightGrayBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for LightGrayBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CyanBannerData {
    rotation: i32,
}
impl CyanBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for CyanBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PurpleBannerData {
    rotation: i32,
}
impl PurpleBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for PurpleBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BlueBannerData {
    rotation: i32,
}
impl BlueBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for BlueBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BrownBannerData {
    rotation: i32,
}
impl BrownBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for BrownBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct GreenBannerData {
    rotation: i32,
}
impl GreenBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for GreenBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RedBannerData {
    rotation: i32,
}
impl RedBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for RedBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BlackBannerData {
    rotation: i32,
}
impl BlackBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for BlackBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct WhiteWallBannerData {
    facing: Facing,
}
impl WhiteWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for WhiteWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OrangeWallBannerData {
    facing: Facing,
}
impl OrangeWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for OrangeWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct MagentaWallBannerData {
    facing: Facing,
}
impl MagentaWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for MagentaWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LightBlueWallBannerData {
    facing: Facing,
}
impl LightBlueWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for LightBlueWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct YellowWallBannerData {
    facing: Facing,
}
impl YellowWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for YellowWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LimeWallBannerData {
    facing: Facing,
}
impl LimeWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for LimeWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PinkWallBannerData {
    facing: Facing,
}
impl PinkWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for PinkWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct GrayWallBannerData {
    facing: Facing,
}
impl GrayWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for GrayWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LightGrayWallBannerData {
    facing: Facing,
}
impl LightGrayWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for LightGrayWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CyanWallBannerData {
    facing: Facing,
}
impl CyanWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for CyanWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PurpleWallBannerData {
    facing: Facing,
}
impl PurpleWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for PurpleWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BlueWallBannerData {
    facing: Facing,
}
impl BlueWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for BlueWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BrownWallBannerData {
    facing: Facing,
}
impl BrownWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for BrownWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct GreenWallBannerData {
    facing: Facing,
}
impl GreenWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for GreenWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RedWallBannerData {
    facing: Facing,
}
impl RedWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for RedWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BlackWallBannerData {
    facing: Facing,
}
impl BlackWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for BlackWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RedSandstoneStairsData {
    facing: Facing,
    waterlogged: bool,
    half: Half,
    shape: Shape,
}
impl RedSandstoneStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
            shape: Shape::from_snake_case(map.get("shape")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m
    }
}
impl Value for RedSandstoneStairsData {
    fn value(&self) -> usize {
        (self.facing.value() * 20usize)
            + (self.waterlogged.value() * 10usize)
            + (self.half.value() * 5usize)
            + (self.shape.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OakSlabData {
    ty: Half,
    waterlogged: bool,
}
impl OakSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            ty: Half::from_snake_case(map.get("type")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("type".to_string(), self.ty.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for OakSlabData {
    fn value(&self) -> usize {
        (self.ty.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SpruceSlabData {
    ty: Half,
    waterlogged: bool,
}
impl SpruceSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            ty: Half::from_snake_case(map.get("type")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("type".to_string(), self.ty.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for SpruceSlabData {
    fn value(&self) -> usize {
        (self.ty.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BirchSlabData {
    ty: Half,
    waterlogged: bool,
}
impl BirchSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            ty: Half::from_snake_case(map.get("type")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("type".to_string(), self.ty.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for BirchSlabData {
    fn value(&self) -> usize {
        (self.ty.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct JungleSlabData {
    ty: Half,
    waterlogged: bool,
}
impl JungleSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            ty: Half::from_snake_case(map.get("type")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("type".to_string(), self.ty.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for JungleSlabData {
    fn value(&self) -> usize {
        (self.ty.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AcaciaSlabData {
    ty: Half,
    waterlogged: bool,
}
impl AcaciaSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            ty: Half::from_snake_case(map.get("type")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("type".to_string(), self.ty.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for AcaciaSlabData {
    fn value(&self) -> usize {
        (self.ty.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DarkOakSlabData {
    ty: Half,
    waterlogged: bool,
}
impl DarkOakSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            ty: Half::from_snake_case(map.get("type")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("type".to_string(), self.ty.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for DarkOakSlabData {
    fn value(&self) -> usize {
        (self.ty.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StoneSlabData {
    ty: Half,
    waterlogged: bool,
}
impl StoneSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            ty: Half::from_snake_case(map.get("type")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("type".to_string(), self.ty.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for StoneSlabData {
    fn value(&self) -> usize {
        (self.ty.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SandstoneSlabData {
    ty: Half,
    waterlogged: bool,
}
impl SandstoneSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            ty: Half::from_snake_case(map.get("type")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("type".to_string(), self.ty.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for SandstoneSlabData {
    fn value(&self) -> usize {
        (self.ty.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PetrifiedOakSlabData {
    ty: Half,
    waterlogged: bool,
}
impl PetrifiedOakSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            ty: Half::from_snake_case(map.get("type")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("type".to_string(), self.ty.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for PetrifiedOakSlabData {
    fn value(&self) -> usize {
        (self.ty.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CobblestoneSlabData {
    waterlogged: bool,
    ty: Half,
}
impl CobblestoneSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            ty: Half::from_snake_case(map.get("type")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("type".to_string(), self.ty.to_snake_case());
        m
    }
}
impl Value for CobblestoneSlabData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 3usize) + (self.ty.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BrickSlabData {
    ty: Half,
    waterlogged: bool,
}
impl BrickSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            ty: Half::from_snake_case(map.get("type")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("type".to_string(), self.ty.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for BrickSlabData {
    fn value(&self) -> usize {
        (self.ty.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StoneBrickSlabData {
    waterlogged: bool,
    ty: Half,
}
impl StoneBrickSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            ty: Half::from_snake_case(map.get("type")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("type".to_string(), self.ty.to_snake_case());
        m
    }
}
impl Value for StoneBrickSlabData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 3usize) + (self.ty.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct NetherBrickSlabData {
    waterlogged: bool,
    ty: Half,
}
impl NetherBrickSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            ty: Half::from_snake_case(map.get("type")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("type".to_string(), self.ty.to_snake_case());
        m
    }
}
impl Value for NetherBrickSlabData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 3usize) + (self.ty.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct QuartzSlabData {
    ty: Half,
    waterlogged: bool,
}
impl QuartzSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            ty: Half::from_snake_case(map.get("type")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("type".to_string(), self.ty.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for QuartzSlabData {
    fn value(&self) -> usize {
        (self.ty.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RedSandstoneSlabData {
    waterlogged: bool,
    ty: Half,
}
impl RedSandstoneSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            ty: Half::from_snake_case(map.get("type")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("type".to_string(), self.ty.to_snake_case());
        m
    }
}
impl Value for RedSandstoneSlabData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 3usize) + (self.ty.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PurpurSlabData {
    ty: Half,
    waterlogged: bool,
}
impl PurpurSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            ty: Half::from_snake_case(map.get("type")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("type".to_string(), self.ty.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for PurpurSlabData {
    fn value(&self) -> usize {
        (self.ty.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SpruceFenceGateData {
    in_wall: bool,
    facing: Facing,
    open: bool,
    powered: bool,
}
impl SpruceFenceGateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            in_wall: bool::from_snake_case(map.get("in_wall")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("in_wall".to_string(), self.in_wall.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for SpruceFenceGateData {
    fn value(&self) -> usize {
        (self.in_wall.value() * 16usize)
            + (self.facing.value() * 4usize)
            + (self.open.value() * 2usize)
            + (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BirchFenceGateData {
    powered: bool,
    open: bool,
    facing: Facing,
    in_wall: bool,
}
impl BirchFenceGateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            in_wall: bool::from_snake_case(map.get("in_wall")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("in_wall".to_string(), self.in_wall.to_snake_case());
        m
    }
}
impl Value for BirchFenceGateData {
    fn value(&self) -> usize {
        (self.powered.value() * 16usize)
            + (self.open.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.in_wall.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct JungleFenceGateData {
    powered: bool,
    facing: Facing,
    in_wall: bool,
    open: bool,
}
impl JungleFenceGateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            in_wall: bool::from_snake_case(map.get("in_wall")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("in_wall".to_string(), self.in_wall.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m
    }
}
impl Value for JungleFenceGateData {
    fn value(&self) -> usize {
        (self.powered.value() * 16usize)
            + (self.facing.value() * 4usize)
            + (self.in_wall.value() * 2usize)
            + (self.open.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AcaciaFenceGateData {
    powered: bool,
    open: bool,
    in_wall: bool,
    facing: Facing,
}
impl AcaciaFenceGateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
            in_wall: bool::from_snake_case(map.get("in_wall")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("in_wall".to_string(), self.in_wall.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for AcaciaFenceGateData {
    fn value(&self) -> usize {
        (self.powered.value() * 16usize)
            + (self.open.value() * 8usize)
            + (self.in_wall.value() * 4usize)
            + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DarkOakFenceGateData {
    facing: Facing,
    in_wall: bool,
    open: bool,
    powered: bool,
}
impl DarkOakFenceGateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            in_wall: bool::from_snake_case(map.get("in_wall")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("in_wall".to_string(), self.in_wall.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for DarkOakFenceGateData {
    fn value(&self) -> usize {
        (self.facing.value() * 8usize)
            + (self.in_wall.value() * 4usize)
            + (self.open.value() * 2usize)
            + (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SpruceFenceData {
    north: bool,
    south: bool,
    west: bool,
    waterlogged: bool,
    east: bool,
}
impl SpruceFenceData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            north: bool::from_snake_case(map.get("north")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m
    }
}
impl Value for SpruceFenceData {
    fn value(&self) -> usize {
        (self.north.value() * 16usize)
            + (self.south.value() * 8usize)
            + (self.west.value() * 4usize)
            + (self.waterlogged.value() * 2usize)
            + (self.east.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BirchFenceData {
    north: bool,
    south: bool,
    east: bool,
    waterlogged: bool,
    west: bool,
}
impl BirchFenceData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            north: bool::from_snake_case(map.get("north")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m
    }
}
impl Value for BirchFenceData {
    fn value(&self) -> usize {
        (self.north.value() * 16usize)
            + (self.south.value() * 8usize)
            + (self.east.value() * 4usize)
            + (self.waterlogged.value() * 2usize)
            + (self.west.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct JungleFenceData {
    north: bool,
    waterlogged: bool,
    east: bool,
    west: bool,
    south: bool,
}
impl JungleFenceData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            north: bool::from_snake_case(map.get("north")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m
    }
}
impl Value for JungleFenceData {
    fn value(&self) -> usize {
        (self.north.value() * 16usize)
            + (self.waterlogged.value() * 8usize)
            + (self.east.value() * 4usize)
            + (self.west.value() * 2usize)
            + (self.south.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AcaciaFenceData {
    west: bool,
    waterlogged: bool,
    east: bool,
    south: bool,
    north: bool,
}
impl AcaciaFenceData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            west: bool::from_snake_case(map.get("west")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m
    }
}
impl Value for AcaciaFenceData {
    fn value(&self) -> usize {
        (self.west.value() * 16usize)
            + (self.waterlogged.value() * 8usize)
            + (self.east.value() * 4usize)
            + (self.south.value() * 2usize)
            + (self.north.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DarkOakFenceData {
    waterlogged: bool,
    south: bool,
    west: bool,
    east: bool,
    north: bool,
}
impl DarkOakFenceData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m
    }
}
impl Value for DarkOakFenceData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 16usize)
            + (self.south.value() * 8usize)
            + (self.west.value() * 4usize)
            + (self.east.value() * 2usize)
            + (self.north.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SpruceDoorData {
    facing: Facing,
    open: bool,
    half: Half,
    powered: bool,
    hinge: Hinge,
}
impl SpruceDoorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            hinge: Hinge::from_snake_case(map.get("hinge")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("hinge".to_string(), self.hinge.to_snake_case());
        m
    }
}
impl Value for SpruceDoorData {
    fn value(&self) -> usize {
        (self.facing.value() * 16usize)
            + (self.open.value() * 8usize)
            + (self.half.value() * 4usize)
            + (self.powered.value() * 2usize)
            + (self.hinge.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BirchDoorData {
    open: bool,
    powered: bool,
    half: Half,
    hinge: Hinge,
    facing: Facing,
}
impl BirchDoorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            open: bool::from_snake_case(map.get("open")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
            hinge: Hinge::from_snake_case(map.get("hinge")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("hinge".to_string(), self.hinge.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for BirchDoorData {
    fn value(&self) -> usize {
        (self.open.value() * 32usize)
            + (self.powered.value() * 16usize)
            + (self.half.value() * 8usize)
            + (self.hinge.value() * 4usize)
            + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct JungleDoorData {
    hinge: Hinge,
    half: Half,
    powered: bool,
    facing: Facing,
    open: bool,
}
impl JungleDoorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            hinge: Hinge::from_snake_case(map.get("hinge")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("hinge".to_string(), self.hinge.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m
    }
}
impl Value for JungleDoorData {
    fn value(&self) -> usize {
        (self.hinge.value() * 32usize)
            + (self.half.value() * 16usize)
            + (self.powered.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.open.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AcaciaDoorData {
    open: bool,
    half: Half,
    powered: bool,
    facing: Facing,
    hinge: Hinge,
}
impl AcaciaDoorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            open: bool::from_snake_case(map.get("open")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            hinge: Hinge::from_snake_case(map.get("hinge")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("hinge".to_string(), self.hinge.to_snake_case());
        m
    }
}
impl Value for AcaciaDoorData {
    fn value(&self) -> usize {
        (self.open.value() * 32usize)
            + (self.half.value() * 16usize)
            + (self.powered.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.hinge.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DarkOakDoorData {
    half: Half,
    facing: Facing,
    hinge: Hinge,
    open: bool,
    powered: bool,
}
impl DarkOakDoorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            half: Half::from_snake_case(map.get("half")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            hinge: Hinge::from_snake_case(map.get("hinge")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("hinge".to_string(), self.hinge.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for DarkOakDoorData {
    fn value(&self) -> usize {
        (self.half.value() * 32usize)
            + (self.facing.value() * 8usize)
            + (self.hinge.value() * 4usize)
            + (self.open.value() * 2usize)
            + (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct EndRodData {
    facing: Facing,
}
impl EndRodData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for EndRodData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ChorusPlantData {
    south: bool,
    north: bool,
    down: bool,
    east: bool,
    up: bool,
    west: bool,
}
impl ChorusPlantData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            south: bool::from_snake_case(map.get("south")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            down: bool::from_snake_case(map.get("down")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            up: bool::from_snake_case(map.get("up")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("down".to_string(), self.down.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("up".to_string(), self.up.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m
    }
}
impl Value for ChorusPlantData {
    fn value(&self) -> usize {
        (self.south.value() * 32usize)
            + (self.north.value() * 16usize)
            + (self.down.value() * 8usize)
            + (self.east.value() * 4usize)
            + (self.up.value() * 2usize)
            + (self.west.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ChorusFlowerData {
    age: i32,
}
impl ChorusFlowerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            age: i32::from_snake_case(map.get("age")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("age".to_string(), self.age.to_snake_case());
        m
    }
}
impl Value for ChorusFlowerData {
    fn value(&self) -> usize {
        (self.age.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PurpurPillarData {
    axis: Axis,
}
impl PurpurPillarData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for PurpurPillarData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PurpurStairsData {
    facing: Facing,
    half: Half,
    shape: Shape,
    waterlogged: bool,
}
impl PurpurStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
            shape: Shape::from_snake_case(map.get("shape")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for PurpurStairsData {
    fn value(&self) -> usize {
        (self.facing.value() * 20usize)
            + (self.half.value() * 10usize)
            + (self.shape.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BeetrootsData {
    age: i32,
}
impl BeetrootsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            age: i32::from_snake_case(map.get("age")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("age".to_string(), self.age.to_snake_case());
        m
    }
}
impl Value for BeetrootsData {
    fn value(&self) -> usize {
        (self.age.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RepeatingCommandBlockData {
    conditional: bool,
    facing: Facing,
}
impl RepeatingCommandBlockData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            conditional: bool::from_snake_case(map.get("conditional")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("conditional".to_string(), self.conditional.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for RepeatingCommandBlockData {
    fn value(&self) -> usize {
        (self.conditional.value() * 6usize) + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ChainCommandBlockData {
    facing: Facing,
    conditional: bool,
}
impl ChainCommandBlockData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            conditional: bool::from_snake_case(map.get("conditional")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("conditional".to_string(), self.conditional.to_snake_case());
        m
    }
}
impl Value for ChainCommandBlockData {
    fn value(&self) -> usize {
        (self.facing.value() * 2usize) + (self.conditional.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct FrostedIceData {
    age: i32,
}
impl FrostedIceData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            age: i32::from_snake_case(map.get("age")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("age".to_string(), self.age.to_snake_case());
        m
    }
}
impl Value for FrostedIceData {
    fn value(&self) -> usize {
        (self.age.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BoneBlockData {
    axis: Axis,
}
impl BoneBlockData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for BoneBlockData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ObserverData {
    powered: bool,
    facing: Facing,
}
impl ObserverData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for ObserverData {
    fn value(&self) -> usize {
        (self.powered.value() * 6usize) + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ShulkerBoxData {
    facing: Facing,
}
impl ShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for ShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct WhiteShulkerBoxData {
    facing: Facing,
}
impl WhiteShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for WhiteShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OrangeShulkerBoxData {
    facing: Facing,
}
impl OrangeShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for OrangeShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct MagentaShulkerBoxData {
    facing: Facing,
}
impl MagentaShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for MagentaShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LightBlueShulkerBoxData {
    facing: Facing,
}
impl LightBlueShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for LightBlueShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct YellowShulkerBoxData {
    facing: Facing,
}
impl YellowShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for YellowShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LimeShulkerBoxData {
    facing: Facing,
}
impl LimeShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for LimeShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PinkShulkerBoxData {
    facing: Facing,
}
impl PinkShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for PinkShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct GrayShulkerBoxData {
    facing: Facing,
}
impl GrayShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for GrayShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LightGrayShulkerBoxData {
    facing: Facing,
}
impl LightGrayShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for LightGrayShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CyanShulkerBoxData {
    facing: Facing,
}
impl CyanShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for CyanShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PurpleShulkerBoxData {
    facing: Facing,
}
impl PurpleShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for PurpleShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BlueShulkerBoxData {
    facing: Facing,
}
impl BlueShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for BlueShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BrownShulkerBoxData {
    facing: Facing,
}
impl BrownShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for BrownShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct GreenShulkerBoxData {
    facing: Facing,
}
impl GreenShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for GreenShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RedShulkerBoxData {
    facing: Facing,
}
impl RedShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for RedShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BlackShulkerBoxData {
    facing: Facing,
}
impl BlackShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for BlackShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct WhiteGlazedTerracottaData {
    facing: Facing,
}
impl WhiteGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for WhiteGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OrangeGlazedTerracottaData {
    facing: Facing,
}
impl OrangeGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for OrangeGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct MagentaGlazedTerracottaData {
    facing: Facing,
}
impl MagentaGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for MagentaGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LightBlueGlazedTerracottaData {
    facing: Facing,
}
impl LightBlueGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for LightBlueGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct YellowGlazedTerracottaData {
    facing: Facing,
}
impl YellowGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for YellowGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LimeGlazedTerracottaData {
    facing: Facing,
}
impl LimeGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for LimeGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PinkGlazedTerracottaData {
    facing: Facing,
}
impl PinkGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for PinkGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct GrayGlazedTerracottaData {
    facing: Facing,
}
impl GrayGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for GrayGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LightGrayGlazedTerracottaData {
    facing: Facing,
}
impl LightGrayGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for LightGrayGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CyanGlazedTerracottaData {
    facing: Facing,
}
impl CyanGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for CyanGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PurpleGlazedTerracottaData {
    facing: Facing,
}
impl PurpleGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for PurpleGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BlueGlazedTerracottaData {
    facing: Facing,
}
impl BlueGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for BlueGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BrownGlazedTerracottaData {
    facing: Facing,
}
impl BrownGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for BrownGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct GreenGlazedTerracottaData {
    facing: Facing,
}
impl GreenGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for GreenGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RedGlazedTerracottaData {
    facing: Facing,
}
impl RedGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for RedGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BlackGlazedTerracottaData {
    facing: Facing,
}
impl BlackGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for BlackGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct KelpData {
    age: i32,
}
impl KelpData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            age: i32::from_snake_case(map.get("age")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("age".to_string(), self.age.to_snake_case());
        m
    }
}
impl Value for KelpData {
    fn value(&self) -> usize {
        (self.age.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct TurtleEggData {
    hatch: i32,
    eggs: i32,
}
impl TurtleEggData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            hatch: i32::from_snake_case(map.get("hatch")?)?,
            eggs: i32::from_snake_case(map.get("eggs")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("hatch".to_string(), self.hatch.to_snake_case());
        m.insert("eggs".to_string(), self.eggs.to_snake_case());
        m
    }
}
impl Value for TurtleEggData {
    fn value(&self) -> usize {
        (self.hatch.value() * 4usize) + (self.eggs.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadTubeCoralData {
    waterlogged: bool,
}
impl DeadTubeCoralData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for DeadTubeCoralData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadBrainCoralData {
    waterlogged: bool,
}
impl DeadBrainCoralData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for DeadBrainCoralData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadBubbleCoralData {
    waterlogged: bool,
}
impl DeadBubbleCoralData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for DeadBubbleCoralData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadFireCoralData {
    waterlogged: bool,
}
impl DeadFireCoralData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for DeadFireCoralData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadHornCoralData {
    waterlogged: bool,
}
impl DeadHornCoralData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for DeadHornCoralData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct TubeCoralData {
    waterlogged: bool,
}
impl TubeCoralData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for TubeCoralData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BrainCoralData {
    waterlogged: bool,
}
impl BrainCoralData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for BrainCoralData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BubbleCoralData {
    waterlogged: bool,
}
impl BubbleCoralData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for BubbleCoralData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct FireCoralData {
    waterlogged: bool,
}
impl FireCoralData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for FireCoralData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct HornCoralData {
    waterlogged: bool,
}
impl HornCoralData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for HornCoralData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadTubeCoralWallFanData {
    facing: Facing,
    waterlogged: bool,
}
impl DeadTubeCoralWallFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for DeadTubeCoralWallFanData {
    fn value(&self) -> usize {
        (self.facing.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadBrainCoralWallFanData {
    facing: Facing,
    waterlogged: bool,
}
impl DeadBrainCoralWallFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for DeadBrainCoralWallFanData {
    fn value(&self) -> usize {
        (self.facing.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadBubbleCoralWallFanData {
    waterlogged: bool,
    facing: Facing,
}
impl DeadBubbleCoralWallFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for DeadBubbleCoralWallFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 4usize) + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadFireCoralWallFanData {
    waterlogged: bool,
    facing: Facing,
}
impl DeadFireCoralWallFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for DeadFireCoralWallFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 4usize) + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadHornCoralWallFanData {
    facing: Facing,
    waterlogged: bool,
}
impl DeadHornCoralWallFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for DeadHornCoralWallFanData {
    fn value(&self) -> usize {
        (self.facing.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct TubeCoralWallFanData {
    facing: Facing,
    waterlogged: bool,
}
impl TubeCoralWallFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for TubeCoralWallFanData {
    fn value(&self) -> usize {
        (self.facing.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BrainCoralWallFanData {
    waterlogged: bool,
    facing: Facing,
}
impl BrainCoralWallFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for BrainCoralWallFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 4usize) + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BubbleCoralWallFanData {
    waterlogged: bool,
    facing: Facing,
}
impl BubbleCoralWallFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for BubbleCoralWallFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 4usize) + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct FireCoralWallFanData {
    waterlogged: bool,
    facing: Facing,
}
impl FireCoralWallFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for FireCoralWallFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 4usize) + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct HornCoralWallFanData {
    facing: Facing,
    waterlogged: bool,
}
impl HornCoralWallFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for HornCoralWallFanData {
    fn value(&self) -> usize {
        (self.facing.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadTubeCoralFanData {
    waterlogged: bool,
}
impl DeadTubeCoralFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for DeadTubeCoralFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadBrainCoralFanData {
    waterlogged: bool,
}
impl DeadBrainCoralFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for DeadBrainCoralFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadBubbleCoralFanData {
    waterlogged: bool,
}
impl DeadBubbleCoralFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for DeadBubbleCoralFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadFireCoralFanData {
    waterlogged: bool,
}
impl DeadFireCoralFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for DeadFireCoralFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadHornCoralFanData {
    waterlogged: bool,
}
impl DeadHornCoralFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for DeadHornCoralFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct TubeCoralFanData {
    waterlogged: bool,
}
impl TubeCoralFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for TubeCoralFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BrainCoralFanData {
    waterlogged: bool,
}
impl BrainCoralFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for BrainCoralFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BubbleCoralFanData {
    waterlogged: bool,
}
impl BubbleCoralFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for BubbleCoralFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct FireCoralFanData {
    waterlogged: bool,
}
impl FireCoralFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for FireCoralFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct HornCoralFanData {
    waterlogged: bool,
}
impl HornCoralFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for HornCoralFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SeaPickleData {
    pickles: i32,
    waterlogged: bool,
}
impl SeaPickleData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            pickles: i32::from_snake_case(map.get("pickles")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("pickles".to_string(), self.pickles.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for SeaPickleData {
    fn value(&self) -> usize {
        (self.pickles.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ConduitData {
    waterlogged: bool,
}
impl ConduitData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for ConduitData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BubbleColumnData {
    drag: bool,
}
impl BubbleColumnData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            drag: bool::from_snake_case(map.get("drag")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("drag".to_string(), self.drag.to_snake_case());
        m
    }
}
impl Value for BubbleColumnData {
    fn value(&self) -> usize {
        (self.drag.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StructureBlockData {
    mode: StructureBlockMode,
}
impl StructureBlockData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            mode: StructureBlockMode::from_snake_case(map.get("mode")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("mode".to_string(), self.mode.to_snake_case());
        m
    }
}
impl Value for StructureBlockData {
    fn value(&self) -> usize {
        (self.mode.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase)]
pub enum NoteBlockInstrument {
    Harp,
    Basedrum,
    Snare,
    Hat,
    Bass,
    Flute,
    Bell,
    Guitar,
    Chime,
    Xylophone,
}
impl Value for NoteBlockInstrument {
    fn value(&self) -> usize {
        *self as usize
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase)]
pub enum PistonHeadType {
    Normal,
    Sticky,
}
impl Value for PistonHeadType {
    fn value(&self) -> usize {
        *self as usize
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase)]
pub enum MovingPistonType {
    Normal,
    Sticky,
}
impl Value for MovingPistonType {
    fn value(&self) -> usize {
        *self as usize
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase)]
pub enum ChestType {
    Single,
    Left,
    Right,
}
impl Value for ChestType {
    fn value(&self) -> usize {
        *self as usize
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase)]
pub enum TrappedChestType {
    Single,
    Left,
    Right,
}
impl Value for TrappedChestType {
    fn value(&self) -> usize {
        *self as usize
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase)]
pub enum ComparatorMode {
    Compare,
    Subtract,
}
impl Value for ComparatorMode {
    fn value(&self) -> usize {
        *self as usize
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase)]
pub enum StructureBlockMode {
    Save,
    Load,
    Corner,
    Data,
}
impl Value for StructureBlockMode {
    fn value(&self) -> usize {
        *self as usize
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase)]
pub enum Facing {
    North,
    South,
    East,
    West,
    Up,
    Down,
}
impl Value for Facing {
    fn value(&self) -> usize {
        *self as usize
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase)]
pub enum Axis {
    X,
    Y,
    Z,
}
impl Value for Axis {
    fn value(&self) -> usize {
        *self as usize
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase)]
pub enum Half {
    Upper,
    Lower,
    Top,
    Bottom,
}
impl Value for Half {
    fn value(&self) -> usize {
        *self as usize
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase)]
pub enum Face {
    Floor,
    Wall,
    Ceiling,
}
impl Value for Face {
    fn value(&self) -> usize {
        *self as usize
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase)]
pub enum Hinge {
    Left,
    Right,
}
impl Value for Hinge {
    fn value(&self) -> usize {
        *self as usize
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase)]
pub enum Shape {
    Straight,
    InnerLeft,
    InnerRight,
    OuterLeft,
    AscendingNorth,
    AscendingSouth,
    AscendingEast,
    AscendingWest,
    NorthEast,
    NorthWest,
    SouthEast,
    SouthWest,
    NorthSouth,
    EastWest,
}
impl Value for Shape {
    fn value(&self) -> usize {
        *self as usize
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase)]
pub enum Part {
    Head,
    Foot,
}
impl Value for Part {
    fn value(&self) -> usize {
        *self as usize
    }
}
