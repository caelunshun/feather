//! This file was generated by /generators/blocks
use feather_codegen::{FromSnakeCase, ToSnakeCase};
use std::collections::HashMap;
const INTERNAL_ID_OFFSETS: [usize; 598usize] = [
    0usize, 1usize, 2usize, 3usize, 4usize, 5usize, 6usize, 7usize, 8usize, 10usize, 11usize,
    12usize, 14usize, 15usize, 16usize, 17usize, 18usize, 19usize, 20usize, 21usize, 23usize,
    25usize, 27usize, 29usize, 31usize, 33usize, 34usize, 50usize, 66usize, 67usize, 68usize,
    69usize, 70usize, 71usize, 72usize, 75usize, 78usize, 81usize, 84usize, 87usize, 90usize,
    93usize, 96usize, 99usize, 102usize, 105usize, 108usize, 111usize, 114usize, 117usize,
    120usize, 123usize, 126usize, 129usize, 132usize, 135usize, 138usize, 141usize, 144usize,
    158usize, 172usize, 186usize, 200usize, 214usize, 228usize, 229usize, 230usize, 231usize,
    232usize, 233usize, 245usize, 246usize, 247usize, 248usize, 748usize, 764usize, 780usize,
    796usize, 812usize, 828usize, 844usize, 860usize, 876usize, 892usize, 908usize, 924usize,
    940usize, 956usize, 972usize, 988usize, 1004usize, 1016usize, 1028usize, 1040usize, 1041usize,
    1042usize, 1043usize, 1044usize, 1045usize, 1047usize, 1059usize, 1083usize, 1084usize,
    1085usize, 1086usize, 1087usize, 1088usize, 1089usize, 1090usize, 1091usize, 1092usize,
    1093usize, 1094usize, 1095usize, 1096usize, 1097usize, 1098usize, 1099usize, 1111usize,
    1112usize, 1113usize, 1114usize, 1115usize, 1116usize, 1117usize, 1118usize, 1119usize,
    1120usize, 1121usize, 1122usize, 1123usize, 1124usize, 1125usize, 1126usize, 1128usize,
    1129usize, 1130usize, 1131usize, 1132usize, 1136usize, 1648usize, 1649usize, 1729usize,
    1753usize, 3049usize, 3050usize, 3051usize, 3052usize, 3060usize, 3068usize, 3076usize,
    3108usize, 3172usize, 3180usize, 3190usize, 3270usize, 3278usize, 3302usize, 3304usize,
    3368usize, 3370usize, 3372usize, 3374usize, 3376usize, 3378usize, 3380usize, 3382usize,
    3384usize, 3392usize, 3416usize, 3424usize, 3425usize, 3426usize, 3442usize, 3443usize,
    3459usize, 3461usize, 3493usize, 3494usize, 3495usize, 3496usize, 3497usize, 3499usize,
    3503usize, 3507usize, 3514usize, 3578usize, 3579usize, 3580usize, 3581usize, 3582usize,
    3583usize, 3584usize, 3585usize, 3586usize, 3587usize, 3588usize, 3589usize, 3590usize,
    3591usize, 3592usize, 3593usize, 3594usize, 3658usize, 3722usize, 3786usize, 3850usize,
    3914usize, 3978usize, 3979usize, 3980usize, 3981usize, 3982usize, 3983usize, 3984usize,
    3985usize, 3986usize, 3987usize, 3988usize, 4052usize, 4116usize, 4180usize, 4212usize,
    4244usize, 4245usize, 4249usize, 4253usize, 4261usize, 4269usize, 4301usize, 4333usize,
    4413usize, 4493usize, 4495usize, 4496usize, 4497usize, 4529usize, 4609usize, 4613usize,
    4614usize, 4622usize, 4626usize, 4627usize, 4635usize, 4636usize, 4637usize, 4639usize,
    4651usize, 4731usize, 4732usize, 4740usize, 4756usize, 4884usize, 4885usize, 4965usize,
    5045usize, 5125usize, 5137usize, 5138usize, 5202usize, 5266usize, 5267usize, 5268usize,
    5269usize, 5270usize, 5271usize, 5272usize, 5273usize, 5274usize, 5275usize, 5276usize,
    5277usize, 5278usize, 5279usize, 5280usize, 5281usize, 5282usize, 5283usize, 5284usize,
    5285usize, 5286usize, 5287usize, 5288usize, 5296usize, 5304usize, 5328usize, 5352usize,
    5376usize, 5400usize, 5424usize, 5448usize, 5452usize, 5468usize, 5472usize, 5488usize,
    5492usize, 5508usize, 5512usize, 5528usize, 5532usize, 5548usize, 5552usize, 5568usize,
    5572usize, 5576usize, 5580usize, 5604usize, 5620usize, 5636usize, 5652usize, 5684usize,
    5685usize, 5686usize, 5696usize, 5697usize, 5698usize, 5701usize, 5781usize, 5793usize,
    5805usize, 5806usize, 5807usize, 5808usize, 5809usize, 5810usize, 5811usize, 5812usize,
    5813usize, 5814usize, 5815usize, 5816usize, 5817usize, 5818usize, 5819usize, 5820usize,
    5821usize, 5853usize, 5885usize, 5917usize, 5949usize, 5981usize, 6013usize, 6045usize,
    6077usize, 6109usize, 6141usize, 6173usize, 6205usize, 6237usize, 6269usize, 6301usize,
    6333usize, 6413usize, 6493usize, 6494usize, 6495usize, 6559usize, 6560usize, 6561usize,
    6562usize, 6642usize, 6722usize, 6802usize, 6808usize, 6814usize, 6820usize, 6821usize,
    6824usize, 6825usize, 6826usize, 6827usize, 6828usize, 6829usize, 6830usize, 6831usize,
    6832usize, 6833usize, 6834usize, 6835usize, 6836usize, 6837usize, 6838usize, 6839usize,
    6840usize, 6841usize, 6842usize, 6843usize, 6845usize, 6847usize, 6849usize, 6851usize,
    6853usize, 6855usize, 6871usize, 6887usize, 6903usize, 6919usize, 6935usize, 6951usize,
    6967usize, 6983usize, 6999usize, 7015usize, 7031usize, 7047usize, 7063usize, 7079usize,
    7095usize, 7111usize, 7115usize, 7119usize, 7123usize, 7127usize, 7131usize, 7135usize,
    7139usize, 7143usize, 7147usize, 7151usize, 7155usize, 7159usize, 7163usize, 7167usize,
    7171usize, 7175usize, 7176usize, 7177usize, 7178usize, 7258usize, 7264usize, 7270usize,
    7276usize, 7282usize, 7288usize, 7294usize, 7300usize, 7306usize, 7312usize, 7318usize,
    7324usize, 7330usize, 7336usize, 7342usize, 7348usize, 7354usize, 7355usize, 7356usize,
    7357usize, 7358usize, 7390usize, 7422usize, 7454usize, 7486usize, 7518usize, 7550usize,
    7582usize, 7614usize, 7646usize, 7678usize, 7742usize, 7806usize, 7870usize, 7934usize,
    7998usize, 8004usize, 8068usize, 8074usize, 8075usize, 8078usize, 8158usize, 8159usize,
    8163usize, 8164usize, 8165usize, 8177usize, 8189usize, 8193usize, 8194usize, 8195usize,
    8196usize, 8199usize, 8200usize, 8212usize, 8218usize, 8224usize, 8230usize, 8236usize,
    8242usize, 8248usize, 8254usize, 8260usize, 8266usize, 8272usize, 8278usize, 8284usize,
    8290usize, 8296usize, 8302usize, 8308usize, 8314usize, 8318usize, 8322usize, 8326usize,
    8330usize, 8334usize, 8338usize, 8342usize, 8346usize, 8350usize, 8354usize, 8358usize,
    8362usize, 8366usize, 8370usize, 8374usize, 8378usize, 8379usize, 8380usize, 8381usize,
    8382usize, 8383usize, 8384usize, 8385usize, 8386usize, 8387usize, 8388usize, 8389usize,
    8390usize, 8391usize, 8392usize, 8393usize, 8394usize, 8395usize, 8396usize, 8397usize,
    8398usize, 8399usize, 8400usize, 8401usize, 8402usize, 8403usize, 8404usize, 8405usize,
    8406usize, 8407usize, 8408usize, 8409usize, 8410usize, 8436usize, 8437usize, 8438usize,
    8450usize, 8451usize, 8452usize, 8453usize, 8454usize, 8455usize, 8456usize, 8457usize,
    8458usize, 8459usize, 8460usize, 8462usize, 8464usize, 8466usize, 8468usize, 8470usize,
    8472usize, 8474usize, 8476usize, 8478usize, 8480usize, 8488usize, 8496usize, 8504usize,
    8512usize, 8520usize, 8528usize, 8536usize, 8544usize, 8552usize, 8560usize, 8562usize,
    8564usize, 8566usize, 8568usize, 8570usize, 8572usize, 8574usize, 8576usize, 8578usize,
    8580usize, 8588usize, 8589usize, 8591usize, 8592usize, 8593usize, 8595usize,
];
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum Block {
    Air,
    Stone,
    Granite,
    PolishedGranite,
    Diorite,
    PolishedDiorite,
    Andesite,
    PolishedAndesite,
    GrassBlock(GrassBlockData),
    Dirt,
    CoarseDirt,
    Podzol(PodzolData),
    Cobblestone,
    OakPlanks,
    SprucePlanks,
    BirchPlanks,
    JunglePlanks,
    AcaciaPlanks,
    DarkOakPlanks,
    OakSapling(OakSaplingData),
    SpruceSapling(SpruceSaplingData),
    BirchSapling(BirchSaplingData),
    JungleSapling(JungleSaplingData),
    AcaciaSapling(AcaciaSaplingData),
    DarkOakSapling(DarkOakSaplingData),
    Bedrock,
    Water(WaterData),
    Lava(LavaData),
    Sand,
    RedSand,
    Gravel,
    GoldOre,
    IronOre,
    CoalOre,
    OakLog(OakLogData),
    SpruceLog(SpruceLogData),
    BirchLog(BirchLogData),
    JungleLog(JungleLogData),
    AcaciaLog(AcaciaLogData),
    DarkOakLog(DarkOakLogData),
    StrippedSpruceLog(StrippedSpruceLogData),
    StrippedBirchLog(StrippedBirchLogData),
    StrippedJungleLog(StrippedJungleLogData),
    StrippedAcaciaLog(StrippedAcaciaLogData),
    StrippedDarkOakLog(StrippedDarkOakLogData),
    StrippedOakLog(StrippedOakLogData),
    OakWood(OakWoodData),
    SpruceWood(SpruceWoodData),
    BirchWood(BirchWoodData),
    JungleWood(JungleWoodData),
    AcaciaWood(AcaciaWoodData),
    DarkOakWood(DarkOakWoodData),
    StrippedOakWood(StrippedOakWoodData),
    StrippedSpruceWood(StrippedSpruceWoodData),
    StrippedBirchWood(StrippedBirchWoodData),
    StrippedJungleWood(StrippedJungleWoodData),
    StrippedAcaciaWood(StrippedAcaciaWoodData),
    StrippedDarkOakWood(StrippedDarkOakWoodData),
    OakLeaves(OakLeavesData),
    SpruceLeaves(SpruceLeavesData),
    BirchLeaves(BirchLeavesData),
    JungleLeaves(JungleLeavesData),
    AcaciaLeaves(AcaciaLeavesData),
    DarkOakLeaves(DarkOakLeavesData),
    Sponge,
    WetSponge,
    Glass,
    LapisOre,
    LapisBlock,
    Dispenser(DispenserData),
    Sandstone,
    ChiseledSandstone,
    CutSandstone,
    NoteBlock(NoteBlockData),
    WhiteBed(WhiteBedData),
    OrangeBed(OrangeBedData),
    MagentaBed(MagentaBedData),
    LightBlueBed(LightBlueBedData),
    YellowBed(YellowBedData),
    LimeBed(LimeBedData),
    PinkBed(PinkBedData),
    GrayBed(GrayBedData),
    LightGrayBed(LightGrayBedData),
    CyanBed(CyanBedData),
    PurpleBed(PurpleBedData),
    BlueBed(BlueBedData),
    BrownBed(BrownBedData),
    GreenBed(GreenBedData),
    RedBed(RedBedData),
    BlackBed(BlackBedData),
    PoweredRail(PoweredRailData),
    DetectorRail(DetectorRailData),
    StickyPiston(StickyPistonData),
    Cobweb,
    Grass,
    Fern,
    DeadBush,
    Seagrass,
    TallSeagrass(TallSeagrassData),
    Piston(PistonData),
    PistonHead(PistonHeadData),
    WhiteWool,
    OrangeWool,
    MagentaWool,
    LightBlueWool,
    YellowWool,
    LimeWool,
    PinkWool,
    GrayWool,
    LightGrayWool,
    CyanWool,
    PurpleWool,
    BlueWool,
    BrownWool,
    GreenWool,
    RedWool,
    BlackWool,
    MovingPiston(MovingPistonData),
    Dandelion,
    Poppy,
    BlueOrchid,
    Allium,
    AzureBluet,
    RedTulip,
    OrangeTulip,
    WhiteTulip,
    PinkTulip,
    OxeyeDaisy,
    BrownMushroom,
    RedMushroom,
    GoldBlock,
    IronBlock,
    Bricks,
    Tnt(TntData),
    Bookshelf,
    MossyCobblestone,
    Obsidian,
    Torch,
    WallTorch(WallTorchData),
    Fire(FireData),
    Spawner,
    OakStairs(OakStairsData),
    Chest(ChestData),
    RedstoneWire(RedstoneWireData),
    DiamondOre,
    DiamondBlock,
    CraftingTable,
    Wheat(WheatData),
    Farmland(FarmlandData),
    Furnace(FurnaceData),
    Sign(SignData),
    OakDoor(OakDoorData),
    Ladder(LadderData),
    Rail(RailData),
    CobblestoneStairs(CobblestoneStairsData),
    WallSign(WallSignData),
    Lever(LeverData),
    StonePressurePlate(StonePressurePlateData),
    IronDoor(IronDoorData),
    OakPressurePlate(OakPressurePlateData),
    SprucePressurePlate(SprucePressurePlateData),
    BirchPressurePlate(BirchPressurePlateData),
    JunglePressurePlate(JunglePressurePlateData),
    AcaciaPressurePlate(AcaciaPressurePlateData),
    DarkOakPressurePlate(DarkOakPressurePlateData),
    RedstoneOre(RedstoneOreData),
    RedstoneTorch(RedstoneTorchData),
    RedstoneWallTorch(RedstoneWallTorchData),
    StoneButton(StoneButtonData),
    Snow(SnowData),
    Ice,
    SnowBlock,
    Cactus(CactusData),
    Clay,
    SugarCane(SugarCaneData),
    Jukebox(JukeboxData),
    OakFence(OakFenceData),
    Pumpkin,
    Netherrack,
    SoulSand,
    Glowstone,
    NetherPortal(NetherPortalData),
    CarvedPumpkin(CarvedPumpkinData),
    JackOLantern(JackOLanternData),
    Cake(CakeData),
    Repeater(RepeaterData),
    WhiteStainedGlass,
    OrangeStainedGlass,
    MagentaStainedGlass,
    LightBlueStainedGlass,
    YellowStainedGlass,
    LimeStainedGlass,
    PinkStainedGlass,
    GrayStainedGlass,
    LightGrayStainedGlass,
    CyanStainedGlass,
    PurpleStainedGlass,
    BlueStainedGlass,
    BrownStainedGlass,
    GreenStainedGlass,
    RedStainedGlass,
    BlackStainedGlass,
    OakTrapdoor(OakTrapdoorData),
    SpruceTrapdoor(SpruceTrapdoorData),
    BirchTrapdoor(BirchTrapdoorData),
    JungleTrapdoor(JungleTrapdoorData),
    AcaciaTrapdoor(AcaciaTrapdoorData),
    DarkOakTrapdoor(DarkOakTrapdoorData),
    InfestedStone,
    InfestedCobblestone,
    InfestedStoneBricks,
    InfestedMossyStoneBricks,
    InfestedCrackedStoneBricks,
    InfestedChiseledStoneBricks,
    StoneBricks,
    MossyStoneBricks,
    CrackedStoneBricks,
    ChiseledStoneBricks,
    BrownMushroomBlock(BrownMushroomBlockData),
    RedMushroomBlock(RedMushroomBlockData),
    MushroomStem(MushroomStemData),
    IronBars(IronBarsData),
    GlassPane(GlassPaneData),
    Melon,
    AttachedPumpkinStem(AttachedPumpkinStemData),
    AttachedMelonStem(AttachedMelonStemData),
    PumpkinStem(PumpkinStemData),
    MelonStem(MelonStemData),
    Vine(VineData),
    OakFenceGate(OakFenceGateData),
    BrickStairs(BrickStairsData),
    StoneBrickStairs(StoneBrickStairsData),
    Mycelium(MyceliumData),
    LilyPad,
    NetherBricks,
    NetherBrickFence(NetherBrickFenceData),
    NetherBrickStairs(NetherBrickStairsData),
    NetherWart(NetherWartData),
    EnchantingTable,
    BrewingStand(BrewingStandData),
    Cauldron(CauldronData),
    EndPortal,
    EndPortalFrame(EndPortalFrameData),
    EndStone,
    DragonEgg,
    RedstoneLamp(RedstoneLampData),
    Cocoa(CocoaData),
    SandstoneStairs(SandstoneStairsData),
    EmeraldOre,
    EnderChest(EnderChestData),
    TripwireHook(TripwireHookData),
    Tripwire(TripwireData),
    EmeraldBlock,
    SpruceStairs(SpruceStairsData),
    BirchStairs(BirchStairsData),
    JungleStairs(JungleStairsData),
    CommandBlock(CommandBlockData),
    Beacon,
    CobblestoneWall(CobblestoneWallData),
    MossyCobblestoneWall(MossyCobblestoneWallData),
    FlowerPot,
    PottedOakSapling,
    PottedSpruceSapling,
    PottedBirchSapling,
    PottedJungleSapling,
    PottedAcaciaSapling,
    PottedDarkOakSapling,
    PottedFern,
    PottedDandelion,
    PottedPoppy,
    PottedBlueOrchid,
    PottedAllium,
    PottedAzureBluet,
    PottedRedTulip,
    PottedOrangeTulip,
    PottedWhiteTulip,
    PottedPinkTulip,
    PottedOxeyeDaisy,
    PottedRedMushroom,
    PottedBrownMushroom,
    PottedDeadBush,
    PottedCactus,
    Carrots(CarrotsData),
    Potatoes(PotatoesData),
    OakButton(OakButtonData),
    SpruceButton(SpruceButtonData),
    BirchButton(BirchButtonData),
    JungleButton(JungleButtonData),
    AcaciaButton(AcaciaButtonData),
    DarkOakButton(DarkOakButtonData),
    SkeletonWallSkull(SkeletonWallSkullData),
    SkeletonSkull(SkeletonSkullData),
    WitherSkeletonWallSkull(WitherSkeletonWallSkullData),
    WitherSkeletonSkull(WitherSkeletonSkullData),
    ZombieWallHead(ZombieWallHeadData),
    ZombieHead(ZombieHeadData),
    PlayerWallHead(PlayerWallHeadData),
    PlayerHead(PlayerHeadData),
    CreeperWallHead(CreeperWallHeadData),
    CreeperHead(CreeperHeadData),
    DragonWallHead(DragonWallHeadData),
    DragonHead(DragonHeadData),
    Anvil(AnvilData),
    ChippedAnvil(ChippedAnvilData),
    DamagedAnvil(DamagedAnvilData),
    TrappedChest(TrappedChestData),
    LightWeightedPressurePlate(LightWeightedPressurePlateData),
    HeavyWeightedPressurePlate(HeavyWeightedPressurePlateData),
    Comparator(ComparatorData),
    DaylightDetector(DaylightDetectorData),
    RedstoneBlock,
    NetherQuartzOre,
    Hopper(HopperData),
    QuartzBlock,
    ChiseledQuartzBlock,
    QuartzPillar(QuartzPillarData),
    QuartzStairs(QuartzStairsData),
    ActivatorRail(ActivatorRailData),
    Dropper(DropperData),
    WhiteTerracotta,
    OrangeTerracotta,
    MagentaTerracotta,
    LightBlueTerracotta,
    YellowTerracotta,
    LimeTerracotta,
    PinkTerracotta,
    GrayTerracotta,
    LightGrayTerracotta,
    CyanTerracotta,
    PurpleTerracotta,
    BlueTerracotta,
    BrownTerracotta,
    GreenTerracotta,
    RedTerracotta,
    BlackTerracotta,
    WhiteStainedGlassPane(WhiteStainedGlassPaneData),
    OrangeStainedGlassPane(OrangeStainedGlassPaneData),
    MagentaStainedGlassPane(MagentaStainedGlassPaneData),
    LightBlueStainedGlassPane(LightBlueStainedGlassPaneData),
    YellowStainedGlassPane(YellowStainedGlassPaneData),
    LimeStainedGlassPane(LimeStainedGlassPaneData),
    PinkStainedGlassPane(PinkStainedGlassPaneData),
    GrayStainedGlassPane(GrayStainedGlassPaneData),
    LightGrayStainedGlassPane(LightGrayStainedGlassPaneData),
    CyanStainedGlassPane(CyanStainedGlassPaneData),
    PurpleStainedGlassPane(PurpleStainedGlassPaneData),
    BlueStainedGlassPane(BlueStainedGlassPaneData),
    BrownStainedGlassPane(BrownStainedGlassPaneData),
    GreenStainedGlassPane(GreenStainedGlassPaneData),
    RedStainedGlassPane(RedStainedGlassPaneData),
    BlackStainedGlassPane(BlackStainedGlassPaneData),
    AcaciaStairs(AcaciaStairsData),
    DarkOakStairs(DarkOakStairsData),
    SlimeBlock,
    Barrier,
    IronTrapdoor(IronTrapdoorData),
    Prismarine,
    PrismarineBricks,
    DarkPrismarine,
    PrismarineStairs(PrismarineStairsData),
    PrismarineBrickStairs(PrismarineBrickStairsData),
    DarkPrismarineStairs(DarkPrismarineStairsData),
    PrismarineSlab(PrismarineSlabData),
    PrismarineBrickSlab(PrismarineBrickSlabData),
    DarkPrismarineSlab(DarkPrismarineSlabData),
    SeaLantern,
    HayBlock(HayBlockData),
    WhiteCarpet,
    OrangeCarpet,
    MagentaCarpet,
    LightBlueCarpet,
    YellowCarpet,
    LimeCarpet,
    PinkCarpet,
    GrayCarpet,
    LightGrayCarpet,
    CyanCarpet,
    PurpleCarpet,
    BlueCarpet,
    BrownCarpet,
    GreenCarpet,
    RedCarpet,
    BlackCarpet,
    Terracotta,
    CoalBlock,
    PackedIce,
    Sunflower(SunflowerData),
    Lilac(LilacData),
    RoseBush(RoseBushData),
    Peony(PeonyData),
    TallGrass(TallGrassData),
    LargeFern(LargeFernData),
    WhiteBanner(WhiteBannerData),
    OrangeBanner(OrangeBannerData),
    MagentaBanner(MagentaBannerData),
    LightBlueBanner(LightBlueBannerData),
    YellowBanner(YellowBannerData),
    LimeBanner(LimeBannerData),
    PinkBanner(PinkBannerData),
    GrayBanner(GrayBannerData),
    LightGrayBanner(LightGrayBannerData),
    CyanBanner(CyanBannerData),
    PurpleBanner(PurpleBannerData),
    BlueBanner(BlueBannerData),
    BrownBanner(BrownBannerData),
    GreenBanner(GreenBannerData),
    RedBanner(RedBannerData),
    BlackBanner(BlackBannerData),
    WhiteWallBanner(WhiteWallBannerData),
    OrangeWallBanner(OrangeWallBannerData),
    MagentaWallBanner(MagentaWallBannerData),
    LightBlueWallBanner(LightBlueWallBannerData),
    YellowWallBanner(YellowWallBannerData),
    LimeWallBanner(LimeWallBannerData),
    PinkWallBanner(PinkWallBannerData),
    GrayWallBanner(GrayWallBannerData),
    LightGrayWallBanner(LightGrayWallBannerData),
    CyanWallBanner(CyanWallBannerData),
    PurpleWallBanner(PurpleWallBannerData),
    BlueWallBanner(BlueWallBannerData),
    BrownWallBanner(BrownWallBannerData),
    GreenWallBanner(GreenWallBannerData),
    RedWallBanner(RedWallBannerData),
    BlackWallBanner(BlackWallBannerData),
    RedSandstone,
    ChiseledRedSandstone,
    CutRedSandstone,
    RedSandstoneStairs(RedSandstoneStairsData),
    OakSlab(OakSlabData),
    SpruceSlab(SpruceSlabData),
    BirchSlab(BirchSlabData),
    JungleSlab(JungleSlabData),
    AcaciaSlab(AcaciaSlabData),
    DarkOakSlab(DarkOakSlabData),
    StoneSlab(StoneSlabData),
    SandstoneSlab(SandstoneSlabData),
    PetrifiedOakSlab(PetrifiedOakSlabData),
    CobblestoneSlab(CobblestoneSlabData),
    BrickSlab(BrickSlabData),
    StoneBrickSlab(StoneBrickSlabData),
    NetherBrickSlab(NetherBrickSlabData),
    QuartzSlab(QuartzSlabData),
    RedSandstoneSlab(RedSandstoneSlabData),
    PurpurSlab(PurpurSlabData),
    SmoothStone,
    SmoothSandstone,
    SmoothQuartz,
    SmoothRedSandstone,
    SpruceFenceGate(SpruceFenceGateData),
    BirchFenceGate(BirchFenceGateData),
    JungleFenceGate(JungleFenceGateData),
    AcaciaFenceGate(AcaciaFenceGateData),
    DarkOakFenceGate(DarkOakFenceGateData),
    SpruceFence(SpruceFenceData),
    BirchFence(BirchFenceData),
    JungleFence(JungleFenceData),
    AcaciaFence(AcaciaFenceData),
    DarkOakFence(DarkOakFenceData),
    SpruceDoor(SpruceDoorData),
    BirchDoor(BirchDoorData),
    JungleDoor(JungleDoorData),
    AcaciaDoor(AcaciaDoorData),
    DarkOakDoor(DarkOakDoorData),
    EndRod(EndRodData),
    ChorusPlant(ChorusPlantData),
    ChorusFlower(ChorusFlowerData),
    PurpurBlock,
    PurpurPillar(PurpurPillarData),
    PurpurStairs(PurpurStairsData),
    EndStoneBricks,
    Beetroots(BeetrootsData),
    GrassPath,
    EndGateway,
    RepeatingCommandBlock(RepeatingCommandBlockData),
    ChainCommandBlock(ChainCommandBlockData),
    FrostedIce(FrostedIceData),
    MagmaBlock,
    NetherWartBlock,
    RedNetherBricks,
    BoneBlock(BoneBlockData),
    StructureVoid,
    Observer(ObserverData),
    ShulkerBox(ShulkerBoxData),
    WhiteShulkerBox(WhiteShulkerBoxData),
    OrangeShulkerBox(OrangeShulkerBoxData),
    MagentaShulkerBox(MagentaShulkerBoxData),
    LightBlueShulkerBox(LightBlueShulkerBoxData),
    YellowShulkerBox(YellowShulkerBoxData),
    LimeShulkerBox(LimeShulkerBoxData),
    PinkShulkerBox(PinkShulkerBoxData),
    GrayShulkerBox(GrayShulkerBoxData),
    LightGrayShulkerBox(LightGrayShulkerBoxData),
    CyanShulkerBox(CyanShulkerBoxData),
    PurpleShulkerBox(PurpleShulkerBoxData),
    BlueShulkerBox(BlueShulkerBoxData),
    BrownShulkerBox(BrownShulkerBoxData),
    GreenShulkerBox(GreenShulkerBoxData),
    RedShulkerBox(RedShulkerBoxData),
    BlackShulkerBox(BlackShulkerBoxData),
    WhiteGlazedTerracotta(WhiteGlazedTerracottaData),
    OrangeGlazedTerracotta(OrangeGlazedTerracottaData),
    MagentaGlazedTerracotta(MagentaGlazedTerracottaData),
    LightBlueGlazedTerracotta(LightBlueGlazedTerracottaData),
    YellowGlazedTerracotta(YellowGlazedTerracottaData),
    LimeGlazedTerracotta(LimeGlazedTerracottaData),
    PinkGlazedTerracotta(PinkGlazedTerracottaData),
    GrayGlazedTerracotta(GrayGlazedTerracottaData),
    LightGrayGlazedTerracotta(LightGrayGlazedTerracottaData),
    CyanGlazedTerracotta(CyanGlazedTerracottaData),
    PurpleGlazedTerracotta(PurpleGlazedTerracottaData),
    BlueGlazedTerracotta(BlueGlazedTerracottaData),
    BrownGlazedTerracotta(BrownGlazedTerracottaData),
    GreenGlazedTerracotta(GreenGlazedTerracottaData),
    RedGlazedTerracotta(RedGlazedTerracottaData),
    BlackGlazedTerracotta(BlackGlazedTerracottaData),
    WhiteConcrete,
    OrangeConcrete,
    MagentaConcrete,
    LightBlueConcrete,
    YellowConcrete,
    LimeConcrete,
    PinkConcrete,
    GrayConcrete,
    LightGrayConcrete,
    CyanConcrete,
    PurpleConcrete,
    BlueConcrete,
    BrownConcrete,
    GreenConcrete,
    RedConcrete,
    BlackConcrete,
    WhiteConcretePowder,
    OrangeConcretePowder,
    MagentaConcretePowder,
    LightBlueConcretePowder,
    YellowConcretePowder,
    LimeConcretePowder,
    PinkConcretePowder,
    GrayConcretePowder,
    LightGrayConcretePowder,
    CyanConcretePowder,
    PurpleConcretePowder,
    BlueConcretePowder,
    BrownConcretePowder,
    GreenConcretePowder,
    RedConcretePowder,
    BlackConcretePowder,
    Kelp(KelpData),
    KelpPlant,
    DriedKelpBlock,
    TurtleEgg(TurtleEggData),
    DeadTubeCoralBlock,
    DeadBrainCoralBlock,
    DeadBubbleCoralBlock,
    DeadFireCoralBlock,
    DeadHornCoralBlock,
    TubeCoralBlock,
    BrainCoralBlock,
    BubbleCoralBlock,
    FireCoralBlock,
    HornCoralBlock,
    DeadTubeCoral(DeadTubeCoralData),
    DeadBrainCoral(DeadBrainCoralData),
    DeadBubbleCoral(DeadBubbleCoralData),
    DeadFireCoral(DeadFireCoralData),
    DeadHornCoral(DeadHornCoralData),
    TubeCoral(TubeCoralData),
    BrainCoral(BrainCoralData),
    BubbleCoral(BubbleCoralData),
    FireCoral(FireCoralData),
    HornCoral(HornCoralData),
    DeadTubeCoralWallFan(DeadTubeCoralWallFanData),
    DeadBrainCoralWallFan(DeadBrainCoralWallFanData),
    DeadBubbleCoralWallFan(DeadBubbleCoralWallFanData),
    DeadFireCoralWallFan(DeadFireCoralWallFanData),
    DeadHornCoralWallFan(DeadHornCoralWallFanData),
    TubeCoralWallFan(TubeCoralWallFanData),
    BrainCoralWallFan(BrainCoralWallFanData),
    BubbleCoralWallFan(BubbleCoralWallFanData),
    FireCoralWallFan(FireCoralWallFanData),
    HornCoralWallFan(HornCoralWallFanData),
    DeadTubeCoralFan(DeadTubeCoralFanData),
    DeadBrainCoralFan(DeadBrainCoralFanData),
    DeadBubbleCoralFan(DeadBubbleCoralFanData),
    DeadFireCoralFan(DeadFireCoralFanData),
    DeadHornCoralFan(DeadHornCoralFanData),
    TubeCoralFan(TubeCoralFanData),
    BrainCoralFan(BrainCoralFanData),
    BubbleCoralFan(BubbleCoralFanData),
    FireCoralFan(FireCoralFanData),
    HornCoralFan(HornCoralFanData),
    SeaPickle(SeaPickleData),
    BlueIce,
    Conduit(ConduitData),
    VoidAir,
    CaveAir,
    BubbleColumn(BubbleColumnData),
    StructureBlock(StructureBlockData),
}
impl Block {
    fn internal_type_id(&self) -> usize {
        match self {
            Block::Air => 0usize,
            Block::Stone => 1usize,
            Block::Granite => 2usize,
            Block::PolishedGranite => 3usize,
            Block::Diorite => 4usize,
            Block::PolishedDiorite => 5usize,
            Block::Andesite => 6usize,
            Block::PolishedAndesite => 7usize,
            Block::GrassBlock(_) => 8usize,
            Block::Dirt => 9usize,
            Block::CoarseDirt => 10usize,
            Block::Podzol(_) => 11usize,
            Block::Cobblestone => 12usize,
            Block::OakPlanks => 13usize,
            Block::SprucePlanks => 14usize,
            Block::BirchPlanks => 15usize,
            Block::JunglePlanks => 16usize,
            Block::AcaciaPlanks => 17usize,
            Block::DarkOakPlanks => 18usize,
            Block::OakSapling(_) => 19usize,
            Block::SpruceSapling(_) => 20usize,
            Block::BirchSapling(_) => 21usize,
            Block::JungleSapling(_) => 22usize,
            Block::AcaciaSapling(_) => 23usize,
            Block::DarkOakSapling(_) => 24usize,
            Block::Bedrock => 25usize,
            Block::Water(_) => 26usize,
            Block::Lava(_) => 27usize,
            Block::Sand => 28usize,
            Block::RedSand => 29usize,
            Block::Gravel => 30usize,
            Block::GoldOre => 31usize,
            Block::IronOre => 32usize,
            Block::CoalOre => 33usize,
            Block::OakLog(_) => 34usize,
            Block::SpruceLog(_) => 35usize,
            Block::BirchLog(_) => 36usize,
            Block::JungleLog(_) => 37usize,
            Block::AcaciaLog(_) => 38usize,
            Block::DarkOakLog(_) => 39usize,
            Block::StrippedSpruceLog(_) => 40usize,
            Block::StrippedBirchLog(_) => 41usize,
            Block::StrippedJungleLog(_) => 42usize,
            Block::StrippedAcaciaLog(_) => 43usize,
            Block::StrippedDarkOakLog(_) => 44usize,
            Block::StrippedOakLog(_) => 45usize,
            Block::OakWood(_) => 46usize,
            Block::SpruceWood(_) => 47usize,
            Block::BirchWood(_) => 48usize,
            Block::JungleWood(_) => 49usize,
            Block::AcaciaWood(_) => 50usize,
            Block::DarkOakWood(_) => 51usize,
            Block::StrippedOakWood(_) => 52usize,
            Block::StrippedSpruceWood(_) => 53usize,
            Block::StrippedBirchWood(_) => 54usize,
            Block::StrippedJungleWood(_) => 55usize,
            Block::StrippedAcaciaWood(_) => 56usize,
            Block::StrippedDarkOakWood(_) => 57usize,
            Block::OakLeaves(_) => 58usize,
            Block::SpruceLeaves(_) => 59usize,
            Block::BirchLeaves(_) => 60usize,
            Block::JungleLeaves(_) => 61usize,
            Block::AcaciaLeaves(_) => 62usize,
            Block::DarkOakLeaves(_) => 63usize,
            Block::Sponge => 64usize,
            Block::WetSponge => 65usize,
            Block::Glass => 66usize,
            Block::LapisOre => 67usize,
            Block::LapisBlock => 68usize,
            Block::Dispenser(_) => 69usize,
            Block::Sandstone => 70usize,
            Block::ChiseledSandstone => 71usize,
            Block::CutSandstone => 72usize,
            Block::NoteBlock(_) => 73usize,
            Block::WhiteBed(_) => 74usize,
            Block::OrangeBed(_) => 75usize,
            Block::MagentaBed(_) => 76usize,
            Block::LightBlueBed(_) => 77usize,
            Block::YellowBed(_) => 78usize,
            Block::LimeBed(_) => 79usize,
            Block::PinkBed(_) => 80usize,
            Block::GrayBed(_) => 81usize,
            Block::LightGrayBed(_) => 82usize,
            Block::CyanBed(_) => 83usize,
            Block::PurpleBed(_) => 84usize,
            Block::BlueBed(_) => 85usize,
            Block::BrownBed(_) => 86usize,
            Block::GreenBed(_) => 87usize,
            Block::RedBed(_) => 88usize,
            Block::BlackBed(_) => 89usize,
            Block::PoweredRail(_) => 90usize,
            Block::DetectorRail(_) => 91usize,
            Block::StickyPiston(_) => 92usize,
            Block::Cobweb => 93usize,
            Block::Grass => 94usize,
            Block::Fern => 95usize,
            Block::DeadBush => 96usize,
            Block::Seagrass => 97usize,
            Block::TallSeagrass(_) => 98usize,
            Block::Piston(_) => 99usize,
            Block::PistonHead(_) => 100usize,
            Block::WhiteWool => 101usize,
            Block::OrangeWool => 102usize,
            Block::MagentaWool => 103usize,
            Block::LightBlueWool => 104usize,
            Block::YellowWool => 105usize,
            Block::LimeWool => 106usize,
            Block::PinkWool => 107usize,
            Block::GrayWool => 108usize,
            Block::LightGrayWool => 109usize,
            Block::CyanWool => 110usize,
            Block::PurpleWool => 111usize,
            Block::BlueWool => 112usize,
            Block::BrownWool => 113usize,
            Block::GreenWool => 114usize,
            Block::RedWool => 115usize,
            Block::BlackWool => 116usize,
            Block::MovingPiston(_) => 117usize,
            Block::Dandelion => 118usize,
            Block::Poppy => 119usize,
            Block::BlueOrchid => 120usize,
            Block::Allium => 121usize,
            Block::AzureBluet => 122usize,
            Block::RedTulip => 123usize,
            Block::OrangeTulip => 124usize,
            Block::WhiteTulip => 125usize,
            Block::PinkTulip => 126usize,
            Block::OxeyeDaisy => 127usize,
            Block::BrownMushroom => 128usize,
            Block::RedMushroom => 129usize,
            Block::GoldBlock => 130usize,
            Block::IronBlock => 131usize,
            Block::Bricks => 132usize,
            Block::Tnt(_) => 133usize,
            Block::Bookshelf => 134usize,
            Block::MossyCobblestone => 135usize,
            Block::Obsidian => 136usize,
            Block::Torch => 137usize,
            Block::WallTorch(_) => 138usize,
            Block::Fire(_) => 139usize,
            Block::Spawner => 140usize,
            Block::OakStairs(_) => 141usize,
            Block::Chest(_) => 142usize,
            Block::RedstoneWire(_) => 143usize,
            Block::DiamondOre => 144usize,
            Block::DiamondBlock => 145usize,
            Block::CraftingTable => 146usize,
            Block::Wheat(_) => 147usize,
            Block::Farmland(_) => 148usize,
            Block::Furnace(_) => 149usize,
            Block::Sign(_) => 150usize,
            Block::OakDoor(_) => 151usize,
            Block::Ladder(_) => 152usize,
            Block::Rail(_) => 153usize,
            Block::CobblestoneStairs(_) => 154usize,
            Block::WallSign(_) => 155usize,
            Block::Lever(_) => 156usize,
            Block::StonePressurePlate(_) => 157usize,
            Block::IronDoor(_) => 158usize,
            Block::OakPressurePlate(_) => 159usize,
            Block::SprucePressurePlate(_) => 160usize,
            Block::BirchPressurePlate(_) => 161usize,
            Block::JunglePressurePlate(_) => 162usize,
            Block::AcaciaPressurePlate(_) => 163usize,
            Block::DarkOakPressurePlate(_) => 164usize,
            Block::RedstoneOre(_) => 165usize,
            Block::RedstoneTorch(_) => 166usize,
            Block::RedstoneWallTorch(_) => 167usize,
            Block::StoneButton(_) => 168usize,
            Block::Snow(_) => 169usize,
            Block::Ice => 170usize,
            Block::SnowBlock => 171usize,
            Block::Cactus(_) => 172usize,
            Block::Clay => 173usize,
            Block::SugarCane(_) => 174usize,
            Block::Jukebox(_) => 175usize,
            Block::OakFence(_) => 176usize,
            Block::Pumpkin => 177usize,
            Block::Netherrack => 178usize,
            Block::SoulSand => 179usize,
            Block::Glowstone => 180usize,
            Block::NetherPortal(_) => 181usize,
            Block::CarvedPumpkin(_) => 182usize,
            Block::JackOLantern(_) => 183usize,
            Block::Cake(_) => 184usize,
            Block::Repeater(_) => 185usize,
            Block::WhiteStainedGlass => 186usize,
            Block::OrangeStainedGlass => 187usize,
            Block::MagentaStainedGlass => 188usize,
            Block::LightBlueStainedGlass => 189usize,
            Block::YellowStainedGlass => 190usize,
            Block::LimeStainedGlass => 191usize,
            Block::PinkStainedGlass => 192usize,
            Block::GrayStainedGlass => 193usize,
            Block::LightGrayStainedGlass => 194usize,
            Block::CyanStainedGlass => 195usize,
            Block::PurpleStainedGlass => 196usize,
            Block::BlueStainedGlass => 197usize,
            Block::BrownStainedGlass => 198usize,
            Block::GreenStainedGlass => 199usize,
            Block::RedStainedGlass => 200usize,
            Block::BlackStainedGlass => 201usize,
            Block::OakTrapdoor(_) => 202usize,
            Block::SpruceTrapdoor(_) => 203usize,
            Block::BirchTrapdoor(_) => 204usize,
            Block::JungleTrapdoor(_) => 205usize,
            Block::AcaciaTrapdoor(_) => 206usize,
            Block::DarkOakTrapdoor(_) => 207usize,
            Block::InfestedStone => 208usize,
            Block::InfestedCobblestone => 209usize,
            Block::InfestedStoneBricks => 210usize,
            Block::InfestedMossyStoneBricks => 211usize,
            Block::InfestedCrackedStoneBricks => 212usize,
            Block::InfestedChiseledStoneBricks => 213usize,
            Block::StoneBricks => 214usize,
            Block::MossyStoneBricks => 215usize,
            Block::CrackedStoneBricks => 216usize,
            Block::ChiseledStoneBricks => 217usize,
            Block::BrownMushroomBlock(_) => 218usize,
            Block::RedMushroomBlock(_) => 219usize,
            Block::MushroomStem(_) => 220usize,
            Block::IronBars(_) => 221usize,
            Block::GlassPane(_) => 222usize,
            Block::Melon => 223usize,
            Block::AttachedPumpkinStem(_) => 224usize,
            Block::AttachedMelonStem(_) => 225usize,
            Block::PumpkinStem(_) => 226usize,
            Block::MelonStem(_) => 227usize,
            Block::Vine(_) => 228usize,
            Block::OakFenceGate(_) => 229usize,
            Block::BrickStairs(_) => 230usize,
            Block::StoneBrickStairs(_) => 231usize,
            Block::Mycelium(_) => 232usize,
            Block::LilyPad => 233usize,
            Block::NetherBricks => 234usize,
            Block::NetherBrickFence(_) => 235usize,
            Block::NetherBrickStairs(_) => 236usize,
            Block::NetherWart(_) => 237usize,
            Block::EnchantingTable => 238usize,
            Block::BrewingStand(_) => 239usize,
            Block::Cauldron(_) => 240usize,
            Block::EndPortal => 241usize,
            Block::EndPortalFrame(_) => 242usize,
            Block::EndStone => 243usize,
            Block::DragonEgg => 244usize,
            Block::RedstoneLamp(_) => 245usize,
            Block::Cocoa(_) => 246usize,
            Block::SandstoneStairs(_) => 247usize,
            Block::EmeraldOre => 248usize,
            Block::EnderChest(_) => 249usize,
            Block::TripwireHook(_) => 250usize,
            Block::Tripwire(_) => 251usize,
            Block::EmeraldBlock => 252usize,
            Block::SpruceStairs(_) => 253usize,
            Block::BirchStairs(_) => 254usize,
            Block::JungleStairs(_) => 255usize,
            Block::CommandBlock(_) => 256usize,
            Block::Beacon => 257usize,
            Block::CobblestoneWall(_) => 258usize,
            Block::MossyCobblestoneWall(_) => 259usize,
            Block::FlowerPot => 260usize,
            Block::PottedOakSapling => 261usize,
            Block::PottedSpruceSapling => 262usize,
            Block::PottedBirchSapling => 263usize,
            Block::PottedJungleSapling => 264usize,
            Block::PottedAcaciaSapling => 265usize,
            Block::PottedDarkOakSapling => 266usize,
            Block::PottedFern => 267usize,
            Block::PottedDandelion => 268usize,
            Block::PottedPoppy => 269usize,
            Block::PottedBlueOrchid => 270usize,
            Block::PottedAllium => 271usize,
            Block::PottedAzureBluet => 272usize,
            Block::PottedRedTulip => 273usize,
            Block::PottedOrangeTulip => 274usize,
            Block::PottedWhiteTulip => 275usize,
            Block::PottedPinkTulip => 276usize,
            Block::PottedOxeyeDaisy => 277usize,
            Block::PottedRedMushroom => 278usize,
            Block::PottedBrownMushroom => 279usize,
            Block::PottedDeadBush => 280usize,
            Block::PottedCactus => 281usize,
            Block::Carrots(_) => 282usize,
            Block::Potatoes(_) => 283usize,
            Block::OakButton(_) => 284usize,
            Block::SpruceButton(_) => 285usize,
            Block::BirchButton(_) => 286usize,
            Block::JungleButton(_) => 287usize,
            Block::AcaciaButton(_) => 288usize,
            Block::DarkOakButton(_) => 289usize,
            Block::SkeletonWallSkull(_) => 290usize,
            Block::SkeletonSkull(_) => 291usize,
            Block::WitherSkeletonWallSkull(_) => 292usize,
            Block::WitherSkeletonSkull(_) => 293usize,
            Block::ZombieWallHead(_) => 294usize,
            Block::ZombieHead(_) => 295usize,
            Block::PlayerWallHead(_) => 296usize,
            Block::PlayerHead(_) => 297usize,
            Block::CreeperWallHead(_) => 298usize,
            Block::CreeperHead(_) => 299usize,
            Block::DragonWallHead(_) => 300usize,
            Block::DragonHead(_) => 301usize,
            Block::Anvil(_) => 302usize,
            Block::ChippedAnvil(_) => 303usize,
            Block::DamagedAnvil(_) => 304usize,
            Block::TrappedChest(_) => 305usize,
            Block::LightWeightedPressurePlate(_) => 306usize,
            Block::HeavyWeightedPressurePlate(_) => 307usize,
            Block::Comparator(_) => 308usize,
            Block::DaylightDetector(_) => 309usize,
            Block::RedstoneBlock => 310usize,
            Block::NetherQuartzOre => 311usize,
            Block::Hopper(_) => 312usize,
            Block::QuartzBlock => 313usize,
            Block::ChiseledQuartzBlock => 314usize,
            Block::QuartzPillar(_) => 315usize,
            Block::QuartzStairs(_) => 316usize,
            Block::ActivatorRail(_) => 317usize,
            Block::Dropper(_) => 318usize,
            Block::WhiteTerracotta => 319usize,
            Block::OrangeTerracotta => 320usize,
            Block::MagentaTerracotta => 321usize,
            Block::LightBlueTerracotta => 322usize,
            Block::YellowTerracotta => 323usize,
            Block::LimeTerracotta => 324usize,
            Block::PinkTerracotta => 325usize,
            Block::GrayTerracotta => 326usize,
            Block::LightGrayTerracotta => 327usize,
            Block::CyanTerracotta => 328usize,
            Block::PurpleTerracotta => 329usize,
            Block::BlueTerracotta => 330usize,
            Block::BrownTerracotta => 331usize,
            Block::GreenTerracotta => 332usize,
            Block::RedTerracotta => 333usize,
            Block::BlackTerracotta => 334usize,
            Block::WhiteStainedGlassPane(_) => 335usize,
            Block::OrangeStainedGlassPane(_) => 336usize,
            Block::MagentaStainedGlassPane(_) => 337usize,
            Block::LightBlueStainedGlassPane(_) => 338usize,
            Block::YellowStainedGlassPane(_) => 339usize,
            Block::LimeStainedGlassPane(_) => 340usize,
            Block::PinkStainedGlassPane(_) => 341usize,
            Block::GrayStainedGlassPane(_) => 342usize,
            Block::LightGrayStainedGlassPane(_) => 343usize,
            Block::CyanStainedGlassPane(_) => 344usize,
            Block::PurpleStainedGlassPane(_) => 345usize,
            Block::BlueStainedGlassPane(_) => 346usize,
            Block::BrownStainedGlassPane(_) => 347usize,
            Block::GreenStainedGlassPane(_) => 348usize,
            Block::RedStainedGlassPane(_) => 349usize,
            Block::BlackStainedGlassPane(_) => 350usize,
            Block::AcaciaStairs(_) => 351usize,
            Block::DarkOakStairs(_) => 352usize,
            Block::SlimeBlock => 353usize,
            Block::Barrier => 354usize,
            Block::IronTrapdoor(_) => 355usize,
            Block::Prismarine => 356usize,
            Block::PrismarineBricks => 357usize,
            Block::DarkPrismarine => 358usize,
            Block::PrismarineStairs(_) => 359usize,
            Block::PrismarineBrickStairs(_) => 360usize,
            Block::DarkPrismarineStairs(_) => 361usize,
            Block::PrismarineSlab(_) => 362usize,
            Block::PrismarineBrickSlab(_) => 363usize,
            Block::DarkPrismarineSlab(_) => 364usize,
            Block::SeaLantern => 365usize,
            Block::HayBlock(_) => 366usize,
            Block::WhiteCarpet => 367usize,
            Block::OrangeCarpet => 368usize,
            Block::MagentaCarpet => 369usize,
            Block::LightBlueCarpet => 370usize,
            Block::YellowCarpet => 371usize,
            Block::LimeCarpet => 372usize,
            Block::PinkCarpet => 373usize,
            Block::GrayCarpet => 374usize,
            Block::LightGrayCarpet => 375usize,
            Block::CyanCarpet => 376usize,
            Block::PurpleCarpet => 377usize,
            Block::BlueCarpet => 378usize,
            Block::BrownCarpet => 379usize,
            Block::GreenCarpet => 380usize,
            Block::RedCarpet => 381usize,
            Block::BlackCarpet => 382usize,
            Block::Terracotta => 383usize,
            Block::CoalBlock => 384usize,
            Block::PackedIce => 385usize,
            Block::Sunflower(_) => 386usize,
            Block::Lilac(_) => 387usize,
            Block::RoseBush(_) => 388usize,
            Block::Peony(_) => 389usize,
            Block::TallGrass(_) => 390usize,
            Block::LargeFern(_) => 391usize,
            Block::WhiteBanner(_) => 392usize,
            Block::OrangeBanner(_) => 393usize,
            Block::MagentaBanner(_) => 394usize,
            Block::LightBlueBanner(_) => 395usize,
            Block::YellowBanner(_) => 396usize,
            Block::LimeBanner(_) => 397usize,
            Block::PinkBanner(_) => 398usize,
            Block::GrayBanner(_) => 399usize,
            Block::LightGrayBanner(_) => 400usize,
            Block::CyanBanner(_) => 401usize,
            Block::PurpleBanner(_) => 402usize,
            Block::BlueBanner(_) => 403usize,
            Block::BrownBanner(_) => 404usize,
            Block::GreenBanner(_) => 405usize,
            Block::RedBanner(_) => 406usize,
            Block::BlackBanner(_) => 407usize,
            Block::WhiteWallBanner(_) => 408usize,
            Block::OrangeWallBanner(_) => 409usize,
            Block::MagentaWallBanner(_) => 410usize,
            Block::LightBlueWallBanner(_) => 411usize,
            Block::YellowWallBanner(_) => 412usize,
            Block::LimeWallBanner(_) => 413usize,
            Block::PinkWallBanner(_) => 414usize,
            Block::GrayWallBanner(_) => 415usize,
            Block::LightGrayWallBanner(_) => 416usize,
            Block::CyanWallBanner(_) => 417usize,
            Block::PurpleWallBanner(_) => 418usize,
            Block::BlueWallBanner(_) => 419usize,
            Block::BrownWallBanner(_) => 420usize,
            Block::GreenWallBanner(_) => 421usize,
            Block::RedWallBanner(_) => 422usize,
            Block::BlackWallBanner(_) => 423usize,
            Block::RedSandstone => 424usize,
            Block::ChiseledRedSandstone => 425usize,
            Block::CutRedSandstone => 426usize,
            Block::RedSandstoneStairs(_) => 427usize,
            Block::OakSlab(_) => 428usize,
            Block::SpruceSlab(_) => 429usize,
            Block::BirchSlab(_) => 430usize,
            Block::JungleSlab(_) => 431usize,
            Block::AcaciaSlab(_) => 432usize,
            Block::DarkOakSlab(_) => 433usize,
            Block::StoneSlab(_) => 434usize,
            Block::SandstoneSlab(_) => 435usize,
            Block::PetrifiedOakSlab(_) => 436usize,
            Block::CobblestoneSlab(_) => 437usize,
            Block::BrickSlab(_) => 438usize,
            Block::StoneBrickSlab(_) => 439usize,
            Block::NetherBrickSlab(_) => 440usize,
            Block::QuartzSlab(_) => 441usize,
            Block::RedSandstoneSlab(_) => 442usize,
            Block::PurpurSlab(_) => 443usize,
            Block::SmoothStone => 444usize,
            Block::SmoothSandstone => 445usize,
            Block::SmoothQuartz => 446usize,
            Block::SmoothRedSandstone => 447usize,
            Block::SpruceFenceGate(_) => 448usize,
            Block::BirchFenceGate(_) => 449usize,
            Block::JungleFenceGate(_) => 450usize,
            Block::AcaciaFenceGate(_) => 451usize,
            Block::DarkOakFenceGate(_) => 452usize,
            Block::SpruceFence(_) => 453usize,
            Block::BirchFence(_) => 454usize,
            Block::JungleFence(_) => 455usize,
            Block::AcaciaFence(_) => 456usize,
            Block::DarkOakFence(_) => 457usize,
            Block::SpruceDoor(_) => 458usize,
            Block::BirchDoor(_) => 459usize,
            Block::JungleDoor(_) => 460usize,
            Block::AcaciaDoor(_) => 461usize,
            Block::DarkOakDoor(_) => 462usize,
            Block::EndRod(_) => 463usize,
            Block::ChorusPlant(_) => 464usize,
            Block::ChorusFlower(_) => 465usize,
            Block::PurpurBlock => 466usize,
            Block::PurpurPillar(_) => 467usize,
            Block::PurpurStairs(_) => 468usize,
            Block::EndStoneBricks => 469usize,
            Block::Beetroots(_) => 470usize,
            Block::GrassPath => 471usize,
            Block::EndGateway => 472usize,
            Block::RepeatingCommandBlock(_) => 473usize,
            Block::ChainCommandBlock(_) => 474usize,
            Block::FrostedIce(_) => 475usize,
            Block::MagmaBlock => 476usize,
            Block::NetherWartBlock => 477usize,
            Block::RedNetherBricks => 478usize,
            Block::BoneBlock(_) => 479usize,
            Block::StructureVoid => 480usize,
            Block::Observer(_) => 481usize,
            Block::ShulkerBox(_) => 482usize,
            Block::WhiteShulkerBox(_) => 483usize,
            Block::OrangeShulkerBox(_) => 484usize,
            Block::MagentaShulkerBox(_) => 485usize,
            Block::LightBlueShulkerBox(_) => 486usize,
            Block::YellowShulkerBox(_) => 487usize,
            Block::LimeShulkerBox(_) => 488usize,
            Block::PinkShulkerBox(_) => 489usize,
            Block::GrayShulkerBox(_) => 490usize,
            Block::LightGrayShulkerBox(_) => 491usize,
            Block::CyanShulkerBox(_) => 492usize,
            Block::PurpleShulkerBox(_) => 493usize,
            Block::BlueShulkerBox(_) => 494usize,
            Block::BrownShulkerBox(_) => 495usize,
            Block::GreenShulkerBox(_) => 496usize,
            Block::RedShulkerBox(_) => 497usize,
            Block::BlackShulkerBox(_) => 498usize,
            Block::WhiteGlazedTerracotta(_) => 499usize,
            Block::OrangeGlazedTerracotta(_) => 500usize,
            Block::MagentaGlazedTerracotta(_) => 501usize,
            Block::LightBlueGlazedTerracotta(_) => 502usize,
            Block::YellowGlazedTerracotta(_) => 503usize,
            Block::LimeGlazedTerracotta(_) => 504usize,
            Block::PinkGlazedTerracotta(_) => 505usize,
            Block::GrayGlazedTerracotta(_) => 506usize,
            Block::LightGrayGlazedTerracotta(_) => 507usize,
            Block::CyanGlazedTerracotta(_) => 508usize,
            Block::PurpleGlazedTerracotta(_) => 509usize,
            Block::BlueGlazedTerracotta(_) => 510usize,
            Block::BrownGlazedTerracotta(_) => 511usize,
            Block::GreenGlazedTerracotta(_) => 512usize,
            Block::RedGlazedTerracotta(_) => 513usize,
            Block::BlackGlazedTerracotta(_) => 514usize,
            Block::WhiteConcrete => 515usize,
            Block::OrangeConcrete => 516usize,
            Block::MagentaConcrete => 517usize,
            Block::LightBlueConcrete => 518usize,
            Block::YellowConcrete => 519usize,
            Block::LimeConcrete => 520usize,
            Block::PinkConcrete => 521usize,
            Block::GrayConcrete => 522usize,
            Block::LightGrayConcrete => 523usize,
            Block::CyanConcrete => 524usize,
            Block::PurpleConcrete => 525usize,
            Block::BlueConcrete => 526usize,
            Block::BrownConcrete => 527usize,
            Block::GreenConcrete => 528usize,
            Block::RedConcrete => 529usize,
            Block::BlackConcrete => 530usize,
            Block::WhiteConcretePowder => 531usize,
            Block::OrangeConcretePowder => 532usize,
            Block::MagentaConcretePowder => 533usize,
            Block::LightBlueConcretePowder => 534usize,
            Block::YellowConcretePowder => 535usize,
            Block::LimeConcretePowder => 536usize,
            Block::PinkConcretePowder => 537usize,
            Block::GrayConcretePowder => 538usize,
            Block::LightGrayConcretePowder => 539usize,
            Block::CyanConcretePowder => 540usize,
            Block::PurpleConcretePowder => 541usize,
            Block::BlueConcretePowder => 542usize,
            Block::BrownConcretePowder => 543usize,
            Block::GreenConcretePowder => 544usize,
            Block::RedConcretePowder => 545usize,
            Block::BlackConcretePowder => 546usize,
            Block::Kelp(_) => 547usize,
            Block::KelpPlant => 548usize,
            Block::DriedKelpBlock => 549usize,
            Block::TurtleEgg(_) => 550usize,
            Block::DeadTubeCoralBlock => 551usize,
            Block::DeadBrainCoralBlock => 552usize,
            Block::DeadBubbleCoralBlock => 553usize,
            Block::DeadFireCoralBlock => 554usize,
            Block::DeadHornCoralBlock => 555usize,
            Block::TubeCoralBlock => 556usize,
            Block::BrainCoralBlock => 557usize,
            Block::BubbleCoralBlock => 558usize,
            Block::FireCoralBlock => 559usize,
            Block::HornCoralBlock => 560usize,
            Block::DeadTubeCoral(_) => 561usize,
            Block::DeadBrainCoral(_) => 562usize,
            Block::DeadBubbleCoral(_) => 563usize,
            Block::DeadFireCoral(_) => 564usize,
            Block::DeadHornCoral(_) => 565usize,
            Block::TubeCoral(_) => 566usize,
            Block::BrainCoral(_) => 567usize,
            Block::BubbleCoral(_) => 568usize,
            Block::FireCoral(_) => 569usize,
            Block::HornCoral(_) => 570usize,
            Block::DeadTubeCoralWallFan(_) => 571usize,
            Block::DeadBrainCoralWallFan(_) => 572usize,
            Block::DeadBubbleCoralWallFan(_) => 573usize,
            Block::DeadFireCoralWallFan(_) => 574usize,
            Block::DeadHornCoralWallFan(_) => 575usize,
            Block::TubeCoralWallFan(_) => 576usize,
            Block::BrainCoralWallFan(_) => 577usize,
            Block::BubbleCoralWallFan(_) => 578usize,
            Block::FireCoralWallFan(_) => 579usize,
            Block::HornCoralWallFan(_) => 580usize,
            Block::DeadTubeCoralFan(_) => 581usize,
            Block::DeadBrainCoralFan(_) => 582usize,
            Block::DeadBubbleCoralFan(_) => 583usize,
            Block::DeadFireCoralFan(_) => 584usize,
            Block::DeadHornCoralFan(_) => 585usize,
            Block::TubeCoralFan(_) => 586usize,
            Block::BrainCoralFan(_) => 587usize,
            Block::BubbleCoralFan(_) => 588usize,
            Block::FireCoralFan(_) => 589usize,
            Block::HornCoralFan(_) => 590usize,
            Block::SeaPickle(_) => 591usize,
            Block::BlueIce => 592usize,
            Block::Conduit(_) => 593usize,
            Block::VoidAir => 594usize,
            Block::CaveAir => 595usize,
            Block::BubbleColumn(_) => 596usize,
            Block::StructureBlock(_) => 597usize,
        }
    }
    fn internal_id_data_offset(&self) -> usize {
        match self {
            Block::Air => 0,
            Block::Stone => 0,
            Block::Granite => 0,
            Block::PolishedGranite => 0,
            Block::Diorite => 0,
            Block::PolishedDiorite => 0,
            Block::Andesite => 0,
            Block::PolishedAndesite => 0,
            Block::GrassBlock(data) => data.value(),
            Block::Dirt => 0,
            Block::CoarseDirt => 0,
            Block::Podzol(data) => data.value(),
            Block::Cobblestone => 0,
            Block::OakPlanks => 0,
            Block::SprucePlanks => 0,
            Block::BirchPlanks => 0,
            Block::JunglePlanks => 0,
            Block::AcaciaPlanks => 0,
            Block::DarkOakPlanks => 0,
            Block::OakSapling(data) => data.value(),
            Block::SpruceSapling(data) => data.value(),
            Block::BirchSapling(data) => data.value(),
            Block::JungleSapling(data) => data.value(),
            Block::AcaciaSapling(data) => data.value(),
            Block::DarkOakSapling(data) => data.value(),
            Block::Bedrock => 0,
            Block::Water(data) => data.value(),
            Block::Lava(data) => data.value(),
            Block::Sand => 0,
            Block::RedSand => 0,
            Block::Gravel => 0,
            Block::GoldOre => 0,
            Block::IronOre => 0,
            Block::CoalOre => 0,
            Block::OakLog(data) => data.value(),
            Block::SpruceLog(data) => data.value(),
            Block::BirchLog(data) => data.value(),
            Block::JungleLog(data) => data.value(),
            Block::AcaciaLog(data) => data.value(),
            Block::DarkOakLog(data) => data.value(),
            Block::StrippedSpruceLog(data) => data.value(),
            Block::StrippedBirchLog(data) => data.value(),
            Block::StrippedJungleLog(data) => data.value(),
            Block::StrippedAcaciaLog(data) => data.value(),
            Block::StrippedDarkOakLog(data) => data.value(),
            Block::StrippedOakLog(data) => data.value(),
            Block::OakWood(data) => data.value(),
            Block::SpruceWood(data) => data.value(),
            Block::BirchWood(data) => data.value(),
            Block::JungleWood(data) => data.value(),
            Block::AcaciaWood(data) => data.value(),
            Block::DarkOakWood(data) => data.value(),
            Block::StrippedOakWood(data) => data.value(),
            Block::StrippedSpruceWood(data) => data.value(),
            Block::StrippedBirchWood(data) => data.value(),
            Block::StrippedJungleWood(data) => data.value(),
            Block::StrippedAcaciaWood(data) => data.value(),
            Block::StrippedDarkOakWood(data) => data.value(),
            Block::OakLeaves(data) => data.value(),
            Block::SpruceLeaves(data) => data.value(),
            Block::BirchLeaves(data) => data.value(),
            Block::JungleLeaves(data) => data.value(),
            Block::AcaciaLeaves(data) => data.value(),
            Block::DarkOakLeaves(data) => data.value(),
            Block::Sponge => 0,
            Block::WetSponge => 0,
            Block::Glass => 0,
            Block::LapisOre => 0,
            Block::LapisBlock => 0,
            Block::Dispenser(data) => data.value(),
            Block::Sandstone => 0,
            Block::ChiseledSandstone => 0,
            Block::CutSandstone => 0,
            Block::NoteBlock(data) => data.value(),
            Block::WhiteBed(data) => data.value(),
            Block::OrangeBed(data) => data.value(),
            Block::MagentaBed(data) => data.value(),
            Block::LightBlueBed(data) => data.value(),
            Block::YellowBed(data) => data.value(),
            Block::LimeBed(data) => data.value(),
            Block::PinkBed(data) => data.value(),
            Block::GrayBed(data) => data.value(),
            Block::LightGrayBed(data) => data.value(),
            Block::CyanBed(data) => data.value(),
            Block::PurpleBed(data) => data.value(),
            Block::BlueBed(data) => data.value(),
            Block::BrownBed(data) => data.value(),
            Block::GreenBed(data) => data.value(),
            Block::RedBed(data) => data.value(),
            Block::BlackBed(data) => data.value(),
            Block::PoweredRail(data) => data.value(),
            Block::DetectorRail(data) => data.value(),
            Block::StickyPiston(data) => data.value(),
            Block::Cobweb => 0,
            Block::Grass => 0,
            Block::Fern => 0,
            Block::DeadBush => 0,
            Block::Seagrass => 0,
            Block::TallSeagrass(data) => data.value(),
            Block::Piston(data) => data.value(),
            Block::PistonHead(data) => data.value(),
            Block::WhiteWool => 0,
            Block::OrangeWool => 0,
            Block::MagentaWool => 0,
            Block::LightBlueWool => 0,
            Block::YellowWool => 0,
            Block::LimeWool => 0,
            Block::PinkWool => 0,
            Block::GrayWool => 0,
            Block::LightGrayWool => 0,
            Block::CyanWool => 0,
            Block::PurpleWool => 0,
            Block::BlueWool => 0,
            Block::BrownWool => 0,
            Block::GreenWool => 0,
            Block::RedWool => 0,
            Block::BlackWool => 0,
            Block::MovingPiston(data) => data.value(),
            Block::Dandelion => 0,
            Block::Poppy => 0,
            Block::BlueOrchid => 0,
            Block::Allium => 0,
            Block::AzureBluet => 0,
            Block::RedTulip => 0,
            Block::OrangeTulip => 0,
            Block::WhiteTulip => 0,
            Block::PinkTulip => 0,
            Block::OxeyeDaisy => 0,
            Block::BrownMushroom => 0,
            Block::RedMushroom => 0,
            Block::GoldBlock => 0,
            Block::IronBlock => 0,
            Block::Bricks => 0,
            Block::Tnt(data) => data.value(),
            Block::Bookshelf => 0,
            Block::MossyCobblestone => 0,
            Block::Obsidian => 0,
            Block::Torch => 0,
            Block::WallTorch(data) => data.value(),
            Block::Fire(data) => data.value(),
            Block::Spawner => 0,
            Block::OakStairs(data) => data.value(),
            Block::Chest(data) => data.value(),
            Block::RedstoneWire(data) => data.value(),
            Block::DiamondOre => 0,
            Block::DiamondBlock => 0,
            Block::CraftingTable => 0,
            Block::Wheat(data) => data.value(),
            Block::Farmland(data) => data.value(),
            Block::Furnace(data) => data.value(),
            Block::Sign(data) => data.value(),
            Block::OakDoor(data) => data.value(),
            Block::Ladder(data) => data.value(),
            Block::Rail(data) => data.value(),
            Block::CobblestoneStairs(data) => data.value(),
            Block::WallSign(data) => data.value(),
            Block::Lever(data) => data.value(),
            Block::StonePressurePlate(data) => data.value(),
            Block::IronDoor(data) => data.value(),
            Block::OakPressurePlate(data) => data.value(),
            Block::SprucePressurePlate(data) => data.value(),
            Block::BirchPressurePlate(data) => data.value(),
            Block::JunglePressurePlate(data) => data.value(),
            Block::AcaciaPressurePlate(data) => data.value(),
            Block::DarkOakPressurePlate(data) => data.value(),
            Block::RedstoneOre(data) => data.value(),
            Block::RedstoneTorch(data) => data.value(),
            Block::RedstoneWallTorch(data) => data.value(),
            Block::StoneButton(data) => data.value(),
            Block::Snow(data) => data.value(),
            Block::Ice => 0,
            Block::SnowBlock => 0,
            Block::Cactus(data) => data.value(),
            Block::Clay => 0,
            Block::SugarCane(data) => data.value(),
            Block::Jukebox(data) => data.value(),
            Block::OakFence(data) => data.value(),
            Block::Pumpkin => 0,
            Block::Netherrack => 0,
            Block::SoulSand => 0,
            Block::Glowstone => 0,
            Block::NetherPortal(data) => data.value(),
            Block::CarvedPumpkin(data) => data.value(),
            Block::JackOLantern(data) => data.value(),
            Block::Cake(data) => data.value(),
            Block::Repeater(data) => data.value(),
            Block::WhiteStainedGlass => 0,
            Block::OrangeStainedGlass => 0,
            Block::MagentaStainedGlass => 0,
            Block::LightBlueStainedGlass => 0,
            Block::YellowStainedGlass => 0,
            Block::LimeStainedGlass => 0,
            Block::PinkStainedGlass => 0,
            Block::GrayStainedGlass => 0,
            Block::LightGrayStainedGlass => 0,
            Block::CyanStainedGlass => 0,
            Block::PurpleStainedGlass => 0,
            Block::BlueStainedGlass => 0,
            Block::BrownStainedGlass => 0,
            Block::GreenStainedGlass => 0,
            Block::RedStainedGlass => 0,
            Block::BlackStainedGlass => 0,
            Block::OakTrapdoor(data) => data.value(),
            Block::SpruceTrapdoor(data) => data.value(),
            Block::BirchTrapdoor(data) => data.value(),
            Block::JungleTrapdoor(data) => data.value(),
            Block::AcaciaTrapdoor(data) => data.value(),
            Block::DarkOakTrapdoor(data) => data.value(),
            Block::InfestedStone => 0,
            Block::InfestedCobblestone => 0,
            Block::InfestedStoneBricks => 0,
            Block::InfestedMossyStoneBricks => 0,
            Block::InfestedCrackedStoneBricks => 0,
            Block::InfestedChiseledStoneBricks => 0,
            Block::StoneBricks => 0,
            Block::MossyStoneBricks => 0,
            Block::CrackedStoneBricks => 0,
            Block::ChiseledStoneBricks => 0,
            Block::BrownMushroomBlock(data) => data.value(),
            Block::RedMushroomBlock(data) => data.value(),
            Block::MushroomStem(data) => data.value(),
            Block::IronBars(data) => data.value(),
            Block::GlassPane(data) => data.value(),
            Block::Melon => 0,
            Block::AttachedPumpkinStem(data) => data.value(),
            Block::AttachedMelonStem(data) => data.value(),
            Block::PumpkinStem(data) => data.value(),
            Block::MelonStem(data) => data.value(),
            Block::Vine(data) => data.value(),
            Block::OakFenceGate(data) => data.value(),
            Block::BrickStairs(data) => data.value(),
            Block::StoneBrickStairs(data) => data.value(),
            Block::Mycelium(data) => data.value(),
            Block::LilyPad => 0,
            Block::NetherBricks => 0,
            Block::NetherBrickFence(data) => data.value(),
            Block::NetherBrickStairs(data) => data.value(),
            Block::NetherWart(data) => data.value(),
            Block::EnchantingTable => 0,
            Block::BrewingStand(data) => data.value(),
            Block::Cauldron(data) => data.value(),
            Block::EndPortal => 0,
            Block::EndPortalFrame(data) => data.value(),
            Block::EndStone => 0,
            Block::DragonEgg => 0,
            Block::RedstoneLamp(data) => data.value(),
            Block::Cocoa(data) => data.value(),
            Block::SandstoneStairs(data) => data.value(),
            Block::EmeraldOre => 0,
            Block::EnderChest(data) => data.value(),
            Block::TripwireHook(data) => data.value(),
            Block::Tripwire(data) => data.value(),
            Block::EmeraldBlock => 0,
            Block::SpruceStairs(data) => data.value(),
            Block::BirchStairs(data) => data.value(),
            Block::JungleStairs(data) => data.value(),
            Block::CommandBlock(data) => data.value(),
            Block::Beacon => 0,
            Block::CobblestoneWall(data) => data.value(),
            Block::MossyCobblestoneWall(data) => data.value(),
            Block::FlowerPot => 0,
            Block::PottedOakSapling => 0,
            Block::PottedSpruceSapling => 0,
            Block::PottedBirchSapling => 0,
            Block::PottedJungleSapling => 0,
            Block::PottedAcaciaSapling => 0,
            Block::PottedDarkOakSapling => 0,
            Block::PottedFern => 0,
            Block::PottedDandelion => 0,
            Block::PottedPoppy => 0,
            Block::PottedBlueOrchid => 0,
            Block::PottedAllium => 0,
            Block::PottedAzureBluet => 0,
            Block::PottedRedTulip => 0,
            Block::PottedOrangeTulip => 0,
            Block::PottedWhiteTulip => 0,
            Block::PottedPinkTulip => 0,
            Block::PottedOxeyeDaisy => 0,
            Block::PottedRedMushroom => 0,
            Block::PottedBrownMushroom => 0,
            Block::PottedDeadBush => 0,
            Block::PottedCactus => 0,
            Block::Carrots(data) => data.value(),
            Block::Potatoes(data) => data.value(),
            Block::OakButton(data) => data.value(),
            Block::SpruceButton(data) => data.value(),
            Block::BirchButton(data) => data.value(),
            Block::JungleButton(data) => data.value(),
            Block::AcaciaButton(data) => data.value(),
            Block::DarkOakButton(data) => data.value(),
            Block::SkeletonWallSkull(data) => data.value(),
            Block::SkeletonSkull(data) => data.value(),
            Block::WitherSkeletonWallSkull(data) => data.value(),
            Block::WitherSkeletonSkull(data) => data.value(),
            Block::ZombieWallHead(data) => data.value(),
            Block::ZombieHead(data) => data.value(),
            Block::PlayerWallHead(data) => data.value(),
            Block::PlayerHead(data) => data.value(),
            Block::CreeperWallHead(data) => data.value(),
            Block::CreeperHead(data) => data.value(),
            Block::DragonWallHead(data) => data.value(),
            Block::DragonHead(data) => data.value(),
            Block::Anvil(data) => data.value(),
            Block::ChippedAnvil(data) => data.value(),
            Block::DamagedAnvil(data) => data.value(),
            Block::TrappedChest(data) => data.value(),
            Block::LightWeightedPressurePlate(data) => data.value(),
            Block::HeavyWeightedPressurePlate(data) => data.value(),
            Block::Comparator(data) => data.value(),
            Block::DaylightDetector(data) => data.value(),
            Block::RedstoneBlock => 0,
            Block::NetherQuartzOre => 0,
            Block::Hopper(data) => data.value(),
            Block::QuartzBlock => 0,
            Block::ChiseledQuartzBlock => 0,
            Block::QuartzPillar(data) => data.value(),
            Block::QuartzStairs(data) => data.value(),
            Block::ActivatorRail(data) => data.value(),
            Block::Dropper(data) => data.value(),
            Block::WhiteTerracotta => 0,
            Block::OrangeTerracotta => 0,
            Block::MagentaTerracotta => 0,
            Block::LightBlueTerracotta => 0,
            Block::YellowTerracotta => 0,
            Block::LimeTerracotta => 0,
            Block::PinkTerracotta => 0,
            Block::GrayTerracotta => 0,
            Block::LightGrayTerracotta => 0,
            Block::CyanTerracotta => 0,
            Block::PurpleTerracotta => 0,
            Block::BlueTerracotta => 0,
            Block::BrownTerracotta => 0,
            Block::GreenTerracotta => 0,
            Block::RedTerracotta => 0,
            Block::BlackTerracotta => 0,
            Block::WhiteStainedGlassPane(data) => data.value(),
            Block::OrangeStainedGlassPane(data) => data.value(),
            Block::MagentaStainedGlassPane(data) => data.value(),
            Block::LightBlueStainedGlassPane(data) => data.value(),
            Block::YellowStainedGlassPane(data) => data.value(),
            Block::LimeStainedGlassPane(data) => data.value(),
            Block::PinkStainedGlassPane(data) => data.value(),
            Block::GrayStainedGlassPane(data) => data.value(),
            Block::LightGrayStainedGlassPane(data) => data.value(),
            Block::CyanStainedGlassPane(data) => data.value(),
            Block::PurpleStainedGlassPane(data) => data.value(),
            Block::BlueStainedGlassPane(data) => data.value(),
            Block::BrownStainedGlassPane(data) => data.value(),
            Block::GreenStainedGlassPane(data) => data.value(),
            Block::RedStainedGlassPane(data) => data.value(),
            Block::BlackStainedGlassPane(data) => data.value(),
            Block::AcaciaStairs(data) => data.value(),
            Block::DarkOakStairs(data) => data.value(),
            Block::SlimeBlock => 0,
            Block::Barrier => 0,
            Block::IronTrapdoor(data) => data.value(),
            Block::Prismarine => 0,
            Block::PrismarineBricks => 0,
            Block::DarkPrismarine => 0,
            Block::PrismarineStairs(data) => data.value(),
            Block::PrismarineBrickStairs(data) => data.value(),
            Block::DarkPrismarineStairs(data) => data.value(),
            Block::PrismarineSlab(data) => data.value(),
            Block::PrismarineBrickSlab(data) => data.value(),
            Block::DarkPrismarineSlab(data) => data.value(),
            Block::SeaLantern => 0,
            Block::HayBlock(data) => data.value(),
            Block::WhiteCarpet => 0,
            Block::OrangeCarpet => 0,
            Block::MagentaCarpet => 0,
            Block::LightBlueCarpet => 0,
            Block::YellowCarpet => 0,
            Block::LimeCarpet => 0,
            Block::PinkCarpet => 0,
            Block::GrayCarpet => 0,
            Block::LightGrayCarpet => 0,
            Block::CyanCarpet => 0,
            Block::PurpleCarpet => 0,
            Block::BlueCarpet => 0,
            Block::BrownCarpet => 0,
            Block::GreenCarpet => 0,
            Block::RedCarpet => 0,
            Block::BlackCarpet => 0,
            Block::Terracotta => 0,
            Block::CoalBlock => 0,
            Block::PackedIce => 0,
            Block::Sunflower(data) => data.value(),
            Block::Lilac(data) => data.value(),
            Block::RoseBush(data) => data.value(),
            Block::Peony(data) => data.value(),
            Block::TallGrass(data) => data.value(),
            Block::LargeFern(data) => data.value(),
            Block::WhiteBanner(data) => data.value(),
            Block::OrangeBanner(data) => data.value(),
            Block::MagentaBanner(data) => data.value(),
            Block::LightBlueBanner(data) => data.value(),
            Block::YellowBanner(data) => data.value(),
            Block::LimeBanner(data) => data.value(),
            Block::PinkBanner(data) => data.value(),
            Block::GrayBanner(data) => data.value(),
            Block::LightGrayBanner(data) => data.value(),
            Block::CyanBanner(data) => data.value(),
            Block::PurpleBanner(data) => data.value(),
            Block::BlueBanner(data) => data.value(),
            Block::BrownBanner(data) => data.value(),
            Block::GreenBanner(data) => data.value(),
            Block::RedBanner(data) => data.value(),
            Block::BlackBanner(data) => data.value(),
            Block::WhiteWallBanner(data) => data.value(),
            Block::OrangeWallBanner(data) => data.value(),
            Block::MagentaWallBanner(data) => data.value(),
            Block::LightBlueWallBanner(data) => data.value(),
            Block::YellowWallBanner(data) => data.value(),
            Block::LimeWallBanner(data) => data.value(),
            Block::PinkWallBanner(data) => data.value(),
            Block::GrayWallBanner(data) => data.value(),
            Block::LightGrayWallBanner(data) => data.value(),
            Block::CyanWallBanner(data) => data.value(),
            Block::PurpleWallBanner(data) => data.value(),
            Block::BlueWallBanner(data) => data.value(),
            Block::BrownWallBanner(data) => data.value(),
            Block::GreenWallBanner(data) => data.value(),
            Block::RedWallBanner(data) => data.value(),
            Block::BlackWallBanner(data) => data.value(),
            Block::RedSandstone => 0,
            Block::ChiseledRedSandstone => 0,
            Block::CutRedSandstone => 0,
            Block::RedSandstoneStairs(data) => data.value(),
            Block::OakSlab(data) => data.value(),
            Block::SpruceSlab(data) => data.value(),
            Block::BirchSlab(data) => data.value(),
            Block::JungleSlab(data) => data.value(),
            Block::AcaciaSlab(data) => data.value(),
            Block::DarkOakSlab(data) => data.value(),
            Block::StoneSlab(data) => data.value(),
            Block::SandstoneSlab(data) => data.value(),
            Block::PetrifiedOakSlab(data) => data.value(),
            Block::CobblestoneSlab(data) => data.value(),
            Block::BrickSlab(data) => data.value(),
            Block::StoneBrickSlab(data) => data.value(),
            Block::NetherBrickSlab(data) => data.value(),
            Block::QuartzSlab(data) => data.value(),
            Block::RedSandstoneSlab(data) => data.value(),
            Block::PurpurSlab(data) => data.value(),
            Block::SmoothStone => 0,
            Block::SmoothSandstone => 0,
            Block::SmoothQuartz => 0,
            Block::SmoothRedSandstone => 0,
            Block::SpruceFenceGate(data) => data.value(),
            Block::BirchFenceGate(data) => data.value(),
            Block::JungleFenceGate(data) => data.value(),
            Block::AcaciaFenceGate(data) => data.value(),
            Block::DarkOakFenceGate(data) => data.value(),
            Block::SpruceFence(data) => data.value(),
            Block::BirchFence(data) => data.value(),
            Block::JungleFence(data) => data.value(),
            Block::AcaciaFence(data) => data.value(),
            Block::DarkOakFence(data) => data.value(),
            Block::SpruceDoor(data) => data.value(),
            Block::BirchDoor(data) => data.value(),
            Block::JungleDoor(data) => data.value(),
            Block::AcaciaDoor(data) => data.value(),
            Block::DarkOakDoor(data) => data.value(),
            Block::EndRod(data) => data.value(),
            Block::ChorusPlant(data) => data.value(),
            Block::ChorusFlower(data) => data.value(),
            Block::PurpurBlock => 0,
            Block::PurpurPillar(data) => data.value(),
            Block::PurpurStairs(data) => data.value(),
            Block::EndStoneBricks => 0,
            Block::Beetroots(data) => data.value(),
            Block::GrassPath => 0,
            Block::EndGateway => 0,
            Block::RepeatingCommandBlock(data) => data.value(),
            Block::ChainCommandBlock(data) => data.value(),
            Block::FrostedIce(data) => data.value(),
            Block::MagmaBlock => 0,
            Block::NetherWartBlock => 0,
            Block::RedNetherBricks => 0,
            Block::BoneBlock(data) => data.value(),
            Block::StructureVoid => 0,
            Block::Observer(data) => data.value(),
            Block::ShulkerBox(data) => data.value(),
            Block::WhiteShulkerBox(data) => data.value(),
            Block::OrangeShulkerBox(data) => data.value(),
            Block::MagentaShulkerBox(data) => data.value(),
            Block::LightBlueShulkerBox(data) => data.value(),
            Block::YellowShulkerBox(data) => data.value(),
            Block::LimeShulkerBox(data) => data.value(),
            Block::PinkShulkerBox(data) => data.value(),
            Block::GrayShulkerBox(data) => data.value(),
            Block::LightGrayShulkerBox(data) => data.value(),
            Block::CyanShulkerBox(data) => data.value(),
            Block::PurpleShulkerBox(data) => data.value(),
            Block::BlueShulkerBox(data) => data.value(),
            Block::BrownShulkerBox(data) => data.value(),
            Block::GreenShulkerBox(data) => data.value(),
            Block::RedShulkerBox(data) => data.value(),
            Block::BlackShulkerBox(data) => data.value(),
            Block::WhiteGlazedTerracotta(data) => data.value(),
            Block::OrangeGlazedTerracotta(data) => data.value(),
            Block::MagentaGlazedTerracotta(data) => data.value(),
            Block::LightBlueGlazedTerracotta(data) => data.value(),
            Block::YellowGlazedTerracotta(data) => data.value(),
            Block::LimeGlazedTerracotta(data) => data.value(),
            Block::PinkGlazedTerracotta(data) => data.value(),
            Block::GrayGlazedTerracotta(data) => data.value(),
            Block::LightGrayGlazedTerracotta(data) => data.value(),
            Block::CyanGlazedTerracotta(data) => data.value(),
            Block::PurpleGlazedTerracotta(data) => data.value(),
            Block::BlueGlazedTerracotta(data) => data.value(),
            Block::BrownGlazedTerracotta(data) => data.value(),
            Block::GreenGlazedTerracotta(data) => data.value(),
            Block::RedGlazedTerracotta(data) => data.value(),
            Block::BlackGlazedTerracotta(data) => data.value(),
            Block::WhiteConcrete => 0,
            Block::OrangeConcrete => 0,
            Block::MagentaConcrete => 0,
            Block::LightBlueConcrete => 0,
            Block::YellowConcrete => 0,
            Block::LimeConcrete => 0,
            Block::PinkConcrete => 0,
            Block::GrayConcrete => 0,
            Block::LightGrayConcrete => 0,
            Block::CyanConcrete => 0,
            Block::PurpleConcrete => 0,
            Block::BlueConcrete => 0,
            Block::BrownConcrete => 0,
            Block::GreenConcrete => 0,
            Block::RedConcrete => 0,
            Block::BlackConcrete => 0,
            Block::WhiteConcretePowder => 0,
            Block::OrangeConcretePowder => 0,
            Block::MagentaConcretePowder => 0,
            Block::LightBlueConcretePowder => 0,
            Block::YellowConcretePowder => 0,
            Block::LimeConcretePowder => 0,
            Block::PinkConcretePowder => 0,
            Block::GrayConcretePowder => 0,
            Block::LightGrayConcretePowder => 0,
            Block::CyanConcretePowder => 0,
            Block::PurpleConcretePowder => 0,
            Block::BlueConcretePowder => 0,
            Block::BrownConcretePowder => 0,
            Block::GreenConcretePowder => 0,
            Block::RedConcretePowder => 0,
            Block::BlackConcretePowder => 0,
            Block::Kelp(data) => data.value(),
            Block::KelpPlant => 0,
            Block::DriedKelpBlock => 0,
            Block::TurtleEgg(data) => data.value(),
            Block::DeadTubeCoralBlock => 0,
            Block::DeadBrainCoralBlock => 0,
            Block::DeadBubbleCoralBlock => 0,
            Block::DeadFireCoralBlock => 0,
            Block::DeadHornCoralBlock => 0,
            Block::TubeCoralBlock => 0,
            Block::BrainCoralBlock => 0,
            Block::BubbleCoralBlock => 0,
            Block::FireCoralBlock => 0,
            Block::HornCoralBlock => 0,
            Block::DeadTubeCoral(data) => data.value(),
            Block::DeadBrainCoral(data) => data.value(),
            Block::DeadBubbleCoral(data) => data.value(),
            Block::DeadFireCoral(data) => data.value(),
            Block::DeadHornCoral(data) => data.value(),
            Block::TubeCoral(data) => data.value(),
            Block::BrainCoral(data) => data.value(),
            Block::BubbleCoral(data) => data.value(),
            Block::FireCoral(data) => data.value(),
            Block::HornCoral(data) => data.value(),
            Block::DeadTubeCoralWallFan(data) => data.value(),
            Block::DeadBrainCoralWallFan(data) => data.value(),
            Block::DeadBubbleCoralWallFan(data) => data.value(),
            Block::DeadFireCoralWallFan(data) => data.value(),
            Block::DeadHornCoralWallFan(data) => data.value(),
            Block::TubeCoralWallFan(data) => data.value(),
            Block::BrainCoralWallFan(data) => data.value(),
            Block::BubbleCoralWallFan(data) => data.value(),
            Block::FireCoralWallFan(data) => data.value(),
            Block::HornCoralWallFan(data) => data.value(),
            Block::DeadTubeCoralFan(data) => data.value(),
            Block::DeadBrainCoralFan(data) => data.value(),
            Block::DeadBubbleCoralFan(data) => data.value(),
            Block::DeadFireCoralFan(data) => data.value(),
            Block::DeadHornCoralFan(data) => data.value(),
            Block::TubeCoralFan(data) => data.value(),
            Block::BrainCoralFan(data) => data.value(),
            Block::BubbleCoralFan(data) => data.value(),
            Block::FireCoralFan(data) => data.value(),
            Block::HornCoralFan(data) => data.value(),
            Block::SeaPickle(data) => data.value(),
            Block::BlueIce => 0,
            Block::Conduit(data) => data.value(),
            Block::VoidAir => 0,
            Block::CaveAir => 0,
            Block::BubbleColumn(data) => data.value(),
            Block::StructureBlock(data) => data.value(),
        }
    }
    pub fn native_state_id(&self) -> usize {
        let type_offset = INTERNAL_ID_OFFSETS[self.internal_type_id()];
        let data_offset = self.internal_id_data_offset();
        type_offset + data_offset
    }
    pub fn from_name_and_props(name: &str, props: &HashMap<String, String>) -> Option<Self> {
        match name {
            "minecraft:air" => Some(Block::Air),
            "minecraft:stone" => Some(Block::Stone),
            "minecraft:granite" => Some(Block::Granite),
            "minecraft:polished_granite" => Some(Block::PolishedGranite),
            "minecraft:diorite" => Some(Block::Diorite),
            "minecraft:polished_diorite" => Some(Block::PolishedDiorite),
            "minecraft:andesite" => Some(Block::Andesite),
            "minecraft:polished_andesite" => Some(Block::PolishedAndesite),
            "minecraft:grass_block" => {
                let data = GrassBlockData::from_map(props)?;
                Some(Block::GrassBlock(data))
            }
            "minecraft:dirt" => Some(Block::Dirt),
            "minecraft:coarse_dirt" => Some(Block::CoarseDirt),
            "minecraft:podzol" => {
                let data = PodzolData::from_map(props)?;
                Some(Block::Podzol(data))
            }
            "minecraft:cobblestone" => Some(Block::Cobblestone),
            "minecraft:oak_planks" => Some(Block::OakPlanks),
            "minecraft:spruce_planks" => Some(Block::SprucePlanks),
            "minecraft:birch_planks" => Some(Block::BirchPlanks),
            "minecraft:jungle_planks" => Some(Block::JunglePlanks),
            "minecraft:acacia_planks" => Some(Block::AcaciaPlanks),
            "minecraft:dark_oak_planks" => Some(Block::DarkOakPlanks),
            "minecraft:oak_sapling" => {
                let data = OakSaplingData::from_map(props)?;
                Some(Block::OakSapling(data))
            }
            "minecraft:spruce_sapling" => {
                let data = SpruceSaplingData::from_map(props)?;
                Some(Block::SpruceSapling(data))
            }
            "minecraft:birch_sapling" => {
                let data = BirchSaplingData::from_map(props)?;
                Some(Block::BirchSapling(data))
            }
            "minecraft:jungle_sapling" => {
                let data = JungleSaplingData::from_map(props)?;
                Some(Block::JungleSapling(data))
            }
            "minecraft:acacia_sapling" => {
                let data = AcaciaSaplingData::from_map(props)?;
                Some(Block::AcaciaSapling(data))
            }
            "minecraft:dark_oak_sapling" => {
                let data = DarkOakSaplingData::from_map(props)?;
                Some(Block::DarkOakSapling(data))
            }
            "minecraft:bedrock" => Some(Block::Bedrock),
            "minecraft:water" => {
                let data = WaterData::from_map(props)?;
                Some(Block::Water(data))
            }
            "minecraft:lava" => {
                let data = LavaData::from_map(props)?;
                Some(Block::Lava(data))
            }
            "minecraft:sand" => Some(Block::Sand),
            "minecraft:red_sand" => Some(Block::RedSand),
            "minecraft:gravel" => Some(Block::Gravel),
            "minecraft:gold_ore" => Some(Block::GoldOre),
            "minecraft:iron_ore" => Some(Block::IronOre),
            "minecraft:coal_ore" => Some(Block::CoalOre),
            "minecraft:oak_log" => {
                let data = OakLogData::from_map(props)?;
                Some(Block::OakLog(data))
            }
            "minecraft:spruce_log" => {
                let data = SpruceLogData::from_map(props)?;
                Some(Block::SpruceLog(data))
            }
            "minecraft:birch_log" => {
                let data = BirchLogData::from_map(props)?;
                Some(Block::BirchLog(data))
            }
            "minecraft:jungle_log" => {
                let data = JungleLogData::from_map(props)?;
                Some(Block::JungleLog(data))
            }
            "minecraft:acacia_log" => {
                let data = AcaciaLogData::from_map(props)?;
                Some(Block::AcaciaLog(data))
            }
            "minecraft:dark_oak_log" => {
                let data = DarkOakLogData::from_map(props)?;
                Some(Block::DarkOakLog(data))
            }
            "minecraft:stripped_spruce_log" => {
                let data = StrippedSpruceLogData::from_map(props)?;
                Some(Block::StrippedSpruceLog(data))
            }
            "minecraft:stripped_birch_log" => {
                let data = StrippedBirchLogData::from_map(props)?;
                Some(Block::StrippedBirchLog(data))
            }
            "minecraft:stripped_jungle_log" => {
                let data = StrippedJungleLogData::from_map(props)?;
                Some(Block::StrippedJungleLog(data))
            }
            "minecraft:stripped_acacia_log" => {
                let data = StrippedAcaciaLogData::from_map(props)?;
                Some(Block::StrippedAcaciaLog(data))
            }
            "minecraft:stripped_dark_oak_log" => {
                let data = StrippedDarkOakLogData::from_map(props)?;
                Some(Block::StrippedDarkOakLog(data))
            }
            "minecraft:stripped_oak_log" => {
                let data = StrippedOakLogData::from_map(props)?;
                Some(Block::StrippedOakLog(data))
            }
            "minecraft:oak_wood" => {
                let data = OakWoodData::from_map(props)?;
                Some(Block::OakWood(data))
            }
            "minecraft:spruce_wood" => {
                let data = SpruceWoodData::from_map(props)?;
                Some(Block::SpruceWood(data))
            }
            "minecraft:birch_wood" => {
                let data = BirchWoodData::from_map(props)?;
                Some(Block::BirchWood(data))
            }
            "minecraft:jungle_wood" => {
                let data = JungleWoodData::from_map(props)?;
                Some(Block::JungleWood(data))
            }
            "minecraft:acacia_wood" => {
                let data = AcaciaWoodData::from_map(props)?;
                Some(Block::AcaciaWood(data))
            }
            "minecraft:dark_oak_wood" => {
                let data = DarkOakWoodData::from_map(props)?;
                Some(Block::DarkOakWood(data))
            }
            "minecraft:stripped_oak_wood" => {
                let data = StrippedOakWoodData::from_map(props)?;
                Some(Block::StrippedOakWood(data))
            }
            "minecraft:stripped_spruce_wood" => {
                let data = StrippedSpruceWoodData::from_map(props)?;
                Some(Block::StrippedSpruceWood(data))
            }
            "minecraft:stripped_birch_wood" => {
                let data = StrippedBirchWoodData::from_map(props)?;
                Some(Block::StrippedBirchWood(data))
            }
            "minecraft:stripped_jungle_wood" => {
                let data = StrippedJungleWoodData::from_map(props)?;
                Some(Block::StrippedJungleWood(data))
            }
            "minecraft:stripped_acacia_wood" => {
                let data = StrippedAcaciaWoodData::from_map(props)?;
                Some(Block::StrippedAcaciaWood(data))
            }
            "minecraft:stripped_dark_oak_wood" => {
                let data = StrippedDarkOakWoodData::from_map(props)?;
                Some(Block::StrippedDarkOakWood(data))
            }
            "minecraft:oak_leaves" => {
                let data = OakLeavesData::from_map(props)?;
                Some(Block::OakLeaves(data))
            }
            "minecraft:spruce_leaves" => {
                let data = SpruceLeavesData::from_map(props)?;
                Some(Block::SpruceLeaves(data))
            }
            "minecraft:birch_leaves" => {
                let data = BirchLeavesData::from_map(props)?;
                Some(Block::BirchLeaves(data))
            }
            "minecraft:jungle_leaves" => {
                let data = JungleLeavesData::from_map(props)?;
                Some(Block::JungleLeaves(data))
            }
            "minecraft:acacia_leaves" => {
                let data = AcaciaLeavesData::from_map(props)?;
                Some(Block::AcaciaLeaves(data))
            }
            "minecraft:dark_oak_leaves" => {
                let data = DarkOakLeavesData::from_map(props)?;
                Some(Block::DarkOakLeaves(data))
            }
            "minecraft:sponge" => Some(Block::Sponge),
            "minecraft:wet_sponge" => Some(Block::WetSponge),
            "minecraft:glass" => Some(Block::Glass),
            "minecraft:lapis_ore" => Some(Block::LapisOre),
            "minecraft:lapis_block" => Some(Block::LapisBlock),
            "minecraft:dispenser" => {
                let data = DispenserData::from_map(props)?;
                Some(Block::Dispenser(data))
            }
            "minecraft:sandstone" => Some(Block::Sandstone),
            "minecraft:chiseled_sandstone" => Some(Block::ChiseledSandstone),
            "minecraft:cut_sandstone" => Some(Block::CutSandstone),
            "minecraft:note_block" => {
                let data = NoteBlockData::from_map(props)?;
                Some(Block::NoteBlock(data))
            }
            "minecraft:white_bed" => {
                let data = WhiteBedData::from_map(props)?;
                Some(Block::WhiteBed(data))
            }
            "minecraft:orange_bed" => {
                let data = OrangeBedData::from_map(props)?;
                Some(Block::OrangeBed(data))
            }
            "minecraft:magenta_bed" => {
                let data = MagentaBedData::from_map(props)?;
                Some(Block::MagentaBed(data))
            }
            "minecraft:light_blue_bed" => {
                let data = LightBlueBedData::from_map(props)?;
                Some(Block::LightBlueBed(data))
            }
            "minecraft:yellow_bed" => {
                let data = YellowBedData::from_map(props)?;
                Some(Block::YellowBed(data))
            }
            "minecraft:lime_bed" => {
                let data = LimeBedData::from_map(props)?;
                Some(Block::LimeBed(data))
            }
            "minecraft:pink_bed" => {
                let data = PinkBedData::from_map(props)?;
                Some(Block::PinkBed(data))
            }
            "minecraft:gray_bed" => {
                let data = GrayBedData::from_map(props)?;
                Some(Block::GrayBed(data))
            }
            "minecraft:light_gray_bed" => {
                let data = LightGrayBedData::from_map(props)?;
                Some(Block::LightGrayBed(data))
            }
            "minecraft:cyan_bed" => {
                let data = CyanBedData::from_map(props)?;
                Some(Block::CyanBed(data))
            }
            "minecraft:purple_bed" => {
                let data = PurpleBedData::from_map(props)?;
                Some(Block::PurpleBed(data))
            }
            "minecraft:blue_bed" => {
                let data = BlueBedData::from_map(props)?;
                Some(Block::BlueBed(data))
            }
            "minecraft:brown_bed" => {
                let data = BrownBedData::from_map(props)?;
                Some(Block::BrownBed(data))
            }
            "minecraft:green_bed" => {
                let data = GreenBedData::from_map(props)?;
                Some(Block::GreenBed(data))
            }
            "minecraft:red_bed" => {
                let data = RedBedData::from_map(props)?;
                Some(Block::RedBed(data))
            }
            "minecraft:black_bed" => {
                let data = BlackBedData::from_map(props)?;
                Some(Block::BlackBed(data))
            }
            "minecraft:powered_rail" => {
                let data = PoweredRailData::from_map(props)?;
                Some(Block::PoweredRail(data))
            }
            "minecraft:detector_rail" => {
                let data = DetectorRailData::from_map(props)?;
                Some(Block::DetectorRail(data))
            }
            "minecraft:sticky_piston" => {
                let data = StickyPistonData::from_map(props)?;
                Some(Block::StickyPiston(data))
            }
            "minecraft:cobweb" => Some(Block::Cobweb),
            "minecraft:grass" => Some(Block::Grass),
            "minecraft:fern" => Some(Block::Fern),
            "minecraft:dead_bush" => Some(Block::DeadBush),
            "minecraft:seagrass" => Some(Block::Seagrass),
            "minecraft:tall_seagrass" => {
                let data = TallSeagrassData::from_map(props)?;
                Some(Block::TallSeagrass(data))
            }
            "minecraft:piston" => {
                let data = PistonData::from_map(props)?;
                Some(Block::Piston(data))
            }
            "minecraft:piston_head" => {
                let data = PistonHeadData::from_map(props)?;
                Some(Block::PistonHead(data))
            }
            "minecraft:white_wool" => Some(Block::WhiteWool),
            "minecraft:orange_wool" => Some(Block::OrangeWool),
            "minecraft:magenta_wool" => Some(Block::MagentaWool),
            "minecraft:light_blue_wool" => Some(Block::LightBlueWool),
            "minecraft:yellow_wool" => Some(Block::YellowWool),
            "minecraft:lime_wool" => Some(Block::LimeWool),
            "minecraft:pink_wool" => Some(Block::PinkWool),
            "minecraft:gray_wool" => Some(Block::GrayWool),
            "minecraft:light_gray_wool" => Some(Block::LightGrayWool),
            "minecraft:cyan_wool" => Some(Block::CyanWool),
            "minecraft:purple_wool" => Some(Block::PurpleWool),
            "minecraft:blue_wool" => Some(Block::BlueWool),
            "minecraft:brown_wool" => Some(Block::BrownWool),
            "minecraft:green_wool" => Some(Block::GreenWool),
            "minecraft:red_wool" => Some(Block::RedWool),
            "minecraft:black_wool" => Some(Block::BlackWool),
            "minecraft:moving_piston" => {
                let data = MovingPistonData::from_map(props)?;
                Some(Block::MovingPiston(data))
            }
            "minecraft:dandelion" => Some(Block::Dandelion),
            "minecraft:poppy" => Some(Block::Poppy),
            "minecraft:blue_orchid" => Some(Block::BlueOrchid),
            "minecraft:allium" => Some(Block::Allium),
            "minecraft:azure_bluet" => Some(Block::AzureBluet),
            "minecraft:red_tulip" => Some(Block::RedTulip),
            "minecraft:orange_tulip" => Some(Block::OrangeTulip),
            "minecraft:white_tulip" => Some(Block::WhiteTulip),
            "minecraft:pink_tulip" => Some(Block::PinkTulip),
            "minecraft:oxeye_daisy" => Some(Block::OxeyeDaisy),
            "minecraft:brown_mushroom" => Some(Block::BrownMushroom),
            "minecraft:red_mushroom" => Some(Block::RedMushroom),
            "minecraft:gold_block" => Some(Block::GoldBlock),
            "minecraft:iron_block" => Some(Block::IronBlock),
            "minecraft:bricks" => Some(Block::Bricks),
            "minecraft:tnt" => {
                let data = TntData::from_map(props)?;
                Some(Block::Tnt(data))
            }
            "minecraft:bookshelf" => Some(Block::Bookshelf),
            "minecraft:mossy_cobblestone" => Some(Block::MossyCobblestone),
            "minecraft:obsidian" => Some(Block::Obsidian),
            "minecraft:torch" => Some(Block::Torch),
            "minecraft:wall_torch" => {
                let data = WallTorchData::from_map(props)?;
                Some(Block::WallTorch(data))
            }
            "minecraft:fire" => {
                let data = FireData::from_map(props)?;
                Some(Block::Fire(data))
            }
            "minecraft:spawner" => Some(Block::Spawner),
            "minecraft:oak_stairs" => {
                let data = OakStairsData::from_map(props)?;
                Some(Block::OakStairs(data))
            }
            "minecraft:chest" => {
                let data = ChestData::from_map(props)?;
                Some(Block::Chest(data))
            }
            "minecraft:redstone_wire" => {
                let data = RedstoneWireData::from_map(props)?;
                Some(Block::RedstoneWire(data))
            }
            "minecraft:diamond_ore" => Some(Block::DiamondOre),
            "minecraft:diamond_block" => Some(Block::DiamondBlock),
            "minecraft:crafting_table" => Some(Block::CraftingTable),
            "minecraft:wheat" => {
                let data = WheatData::from_map(props)?;
                Some(Block::Wheat(data))
            }
            "minecraft:farmland" => {
                let data = FarmlandData::from_map(props)?;
                Some(Block::Farmland(data))
            }
            "minecraft:furnace" => {
                let data = FurnaceData::from_map(props)?;
                Some(Block::Furnace(data))
            }
            "minecraft:sign" => {
                let data = SignData::from_map(props)?;
                Some(Block::Sign(data))
            }
            "minecraft:oak_door" => {
                let data = OakDoorData::from_map(props)?;
                Some(Block::OakDoor(data))
            }
            "minecraft:ladder" => {
                let data = LadderData::from_map(props)?;
                Some(Block::Ladder(data))
            }
            "minecraft:rail" => {
                let data = RailData::from_map(props)?;
                Some(Block::Rail(data))
            }
            "minecraft:cobblestone_stairs" => {
                let data = CobblestoneStairsData::from_map(props)?;
                Some(Block::CobblestoneStairs(data))
            }
            "minecraft:wall_sign" => {
                let data = WallSignData::from_map(props)?;
                Some(Block::WallSign(data))
            }
            "minecraft:lever" => {
                let data = LeverData::from_map(props)?;
                Some(Block::Lever(data))
            }
            "minecraft:stone_pressure_plate" => {
                let data = StonePressurePlateData::from_map(props)?;
                Some(Block::StonePressurePlate(data))
            }
            "minecraft:iron_door" => {
                let data = IronDoorData::from_map(props)?;
                Some(Block::IronDoor(data))
            }
            "minecraft:oak_pressure_plate" => {
                let data = OakPressurePlateData::from_map(props)?;
                Some(Block::OakPressurePlate(data))
            }
            "minecraft:spruce_pressure_plate" => {
                let data = SprucePressurePlateData::from_map(props)?;
                Some(Block::SprucePressurePlate(data))
            }
            "minecraft:birch_pressure_plate" => {
                let data = BirchPressurePlateData::from_map(props)?;
                Some(Block::BirchPressurePlate(data))
            }
            "minecraft:jungle_pressure_plate" => {
                let data = JunglePressurePlateData::from_map(props)?;
                Some(Block::JunglePressurePlate(data))
            }
            "minecraft:acacia_pressure_plate" => {
                let data = AcaciaPressurePlateData::from_map(props)?;
                Some(Block::AcaciaPressurePlate(data))
            }
            "minecraft:dark_oak_pressure_plate" => {
                let data = DarkOakPressurePlateData::from_map(props)?;
                Some(Block::DarkOakPressurePlate(data))
            }
            "minecraft:redstone_ore" => {
                let data = RedstoneOreData::from_map(props)?;
                Some(Block::RedstoneOre(data))
            }
            "minecraft:redstone_torch" => {
                let data = RedstoneTorchData::from_map(props)?;
                Some(Block::RedstoneTorch(data))
            }
            "minecraft:redstone_wall_torch" => {
                let data = RedstoneWallTorchData::from_map(props)?;
                Some(Block::RedstoneWallTorch(data))
            }
            "minecraft:stone_button" => {
                let data = StoneButtonData::from_map(props)?;
                Some(Block::StoneButton(data))
            }
            "minecraft:snow" => {
                let data = SnowData::from_map(props)?;
                Some(Block::Snow(data))
            }
            "minecraft:ice" => Some(Block::Ice),
            "minecraft:snow_block" => Some(Block::SnowBlock),
            "minecraft:cactus" => {
                let data = CactusData::from_map(props)?;
                Some(Block::Cactus(data))
            }
            "minecraft:clay" => Some(Block::Clay),
            "minecraft:sugar_cane" => {
                let data = SugarCaneData::from_map(props)?;
                Some(Block::SugarCane(data))
            }
            "minecraft:jukebox" => {
                let data = JukeboxData::from_map(props)?;
                Some(Block::Jukebox(data))
            }
            "minecraft:oak_fence" => {
                let data = OakFenceData::from_map(props)?;
                Some(Block::OakFence(data))
            }
            "minecraft:pumpkin" => Some(Block::Pumpkin),
            "minecraft:netherrack" => Some(Block::Netherrack),
            "minecraft:soul_sand" => Some(Block::SoulSand),
            "minecraft:glowstone" => Some(Block::Glowstone),
            "minecraft:nether_portal" => {
                let data = NetherPortalData::from_map(props)?;
                Some(Block::NetherPortal(data))
            }
            "minecraft:carved_pumpkin" => {
                let data = CarvedPumpkinData::from_map(props)?;
                Some(Block::CarvedPumpkin(data))
            }
            "minecraft:jack_o_lantern" => {
                let data = JackOLanternData::from_map(props)?;
                Some(Block::JackOLantern(data))
            }
            "minecraft:cake" => {
                let data = CakeData::from_map(props)?;
                Some(Block::Cake(data))
            }
            "minecraft:repeater" => {
                let data = RepeaterData::from_map(props)?;
                Some(Block::Repeater(data))
            }
            "minecraft:white_stained_glass" => Some(Block::WhiteStainedGlass),
            "minecraft:orange_stained_glass" => Some(Block::OrangeStainedGlass),
            "minecraft:magenta_stained_glass" => Some(Block::MagentaStainedGlass),
            "minecraft:light_blue_stained_glass" => Some(Block::LightBlueStainedGlass),
            "minecraft:yellow_stained_glass" => Some(Block::YellowStainedGlass),
            "minecraft:lime_stained_glass" => Some(Block::LimeStainedGlass),
            "minecraft:pink_stained_glass" => Some(Block::PinkStainedGlass),
            "minecraft:gray_stained_glass" => Some(Block::GrayStainedGlass),
            "minecraft:light_gray_stained_glass" => Some(Block::LightGrayStainedGlass),
            "minecraft:cyan_stained_glass" => Some(Block::CyanStainedGlass),
            "minecraft:purple_stained_glass" => Some(Block::PurpleStainedGlass),
            "minecraft:blue_stained_glass" => Some(Block::BlueStainedGlass),
            "minecraft:brown_stained_glass" => Some(Block::BrownStainedGlass),
            "minecraft:green_stained_glass" => Some(Block::GreenStainedGlass),
            "minecraft:red_stained_glass" => Some(Block::RedStainedGlass),
            "minecraft:black_stained_glass" => Some(Block::BlackStainedGlass),
            "minecraft:oak_trapdoor" => {
                let data = OakTrapdoorData::from_map(props)?;
                Some(Block::OakTrapdoor(data))
            }
            "minecraft:spruce_trapdoor" => {
                let data = SpruceTrapdoorData::from_map(props)?;
                Some(Block::SpruceTrapdoor(data))
            }
            "minecraft:birch_trapdoor" => {
                let data = BirchTrapdoorData::from_map(props)?;
                Some(Block::BirchTrapdoor(data))
            }
            "minecraft:jungle_trapdoor" => {
                let data = JungleTrapdoorData::from_map(props)?;
                Some(Block::JungleTrapdoor(data))
            }
            "minecraft:acacia_trapdoor" => {
                let data = AcaciaTrapdoorData::from_map(props)?;
                Some(Block::AcaciaTrapdoor(data))
            }
            "minecraft:dark_oak_trapdoor" => {
                let data = DarkOakTrapdoorData::from_map(props)?;
                Some(Block::DarkOakTrapdoor(data))
            }
            "minecraft:infested_stone" => Some(Block::InfestedStone),
            "minecraft:infested_cobblestone" => Some(Block::InfestedCobblestone),
            "minecraft:infested_stone_bricks" => Some(Block::InfestedStoneBricks),
            "minecraft:infested_mossy_stone_bricks" => Some(Block::InfestedMossyStoneBricks),
            "minecraft:infested_cracked_stone_bricks" => Some(Block::InfestedCrackedStoneBricks),
            "minecraft:infested_chiseled_stone_bricks" => Some(Block::InfestedChiseledStoneBricks),
            "minecraft:stone_bricks" => Some(Block::StoneBricks),
            "minecraft:mossy_stone_bricks" => Some(Block::MossyStoneBricks),
            "minecraft:cracked_stone_bricks" => Some(Block::CrackedStoneBricks),
            "minecraft:chiseled_stone_bricks" => Some(Block::ChiseledStoneBricks),
            "minecraft:brown_mushroom_block" => {
                let data = BrownMushroomBlockData::from_map(props)?;
                Some(Block::BrownMushroomBlock(data))
            }
            "minecraft:red_mushroom_block" => {
                let data = RedMushroomBlockData::from_map(props)?;
                Some(Block::RedMushroomBlock(data))
            }
            "minecraft:mushroom_stem" => {
                let data = MushroomStemData::from_map(props)?;
                Some(Block::MushroomStem(data))
            }
            "minecraft:iron_bars" => {
                let data = IronBarsData::from_map(props)?;
                Some(Block::IronBars(data))
            }
            "minecraft:glass_pane" => {
                let data = GlassPaneData::from_map(props)?;
                Some(Block::GlassPane(data))
            }
            "minecraft:melon" => Some(Block::Melon),
            "minecraft:attached_pumpkin_stem" => {
                let data = AttachedPumpkinStemData::from_map(props)?;
                Some(Block::AttachedPumpkinStem(data))
            }
            "minecraft:attached_melon_stem" => {
                let data = AttachedMelonStemData::from_map(props)?;
                Some(Block::AttachedMelonStem(data))
            }
            "minecraft:pumpkin_stem" => {
                let data = PumpkinStemData::from_map(props)?;
                Some(Block::PumpkinStem(data))
            }
            "minecraft:melon_stem" => {
                let data = MelonStemData::from_map(props)?;
                Some(Block::MelonStem(data))
            }
            "minecraft:vine" => {
                let data = VineData::from_map(props)?;
                Some(Block::Vine(data))
            }
            "minecraft:oak_fence_gate" => {
                let data = OakFenceGateData::from_map(props)?;
                Some(Block::OakFenceGate(data))
            }
            "minecraft:brick_stairs" => {
                let data = BrickStairsData::from_map(props)?;
                Some(Block::BrickStairs(data))
            }
            "minecraft:stone_brick_stairs" => {
                let data = StoneBrickStairsData::from_map(props)?;
                Some(Block::StoneBrickStairs(data))
            }
            "minecraft:mycelium" => {
                let data = MyceliumData::from_map(props)?;
                Some(Block::Mycelium(data))
            }
            "minecraft:lily_pad" => Some(Block::LilyPad),
            "minecraft:nether_bricks" => Some(Block::NetherBricks),
            "minecraft:nether_brick_fence" => {
                let data = NetherBrickFenceData::from_map(props)?;
                Some(Block::NetherBrickFence(data))
            }
            "minecraft:nether_brick_stairs" => {
                let data = NetherBrickStairsData::from_map(props)?;
                Some(Block::NetherBrickStairs(data))
            }
            "minecraft:nether_wart" => {
                let data = NetherWartData::from_map(props)?;
                Some(Block::NetherWart(data))
            }
            "minecraft:enchanting_table" => Some(Block::EnchantingTable),
            "minecraft:brewing_stand" => {
                let data = BrewingStandData::from_map(props)?;
                Some(Block::BrewingStand(data))
            }
            "minecraft:cauldron" => {
                let data = CauldronData::from_map(props)?;
                Some(Block::Cauldron(data))
            }
            "minecraft:end_portal" => Some(Block::EndPortal),
            "minecraft:end_portal_frame" => {
                let data = EndPortalFrameData::from_map(props)?;
                Some(Block::EndPortalFrame(data))
            }
            "minecraft:end_stone" => Some(Block::EndStone),
            "minecraft:dragon_egg" => Some(Block::DragonEgg),
            "minecraft:redstone_lamp" => {
                let data = RedstoneLampData::from_map(props)?;
                Some(Block::RedstoneLamp(data))
            }
            "minecraft:cocoa" => {
                let data = CocoaData::from_map(props)?;
                Some(Block::Cocoa(data))
            }
            "minecraft:sandstone_stairs" => {
                let data = SandstoneStairsData::from_map(props)?;
                Some(Block::SandstoneStairs(data))
            }
            "minecraft:emerald_ore" => Some(Block::EmeraldOre),
            "minecraft:ender_chest" => {
                let data = EnderChestData::from_map(props)?;
                Some(Block::EnderChest(data))
            }
            "minecraft:tripwire_hook" => {
                let data = TripwireHookData::from_map(props)?;
                Some(Block::TripwireHook(data))
            }
            "minecraft:tripwire" => {
                let data = TripwireData::from_map(props)?;
                Some(Block::Tripwire(data))
            }
            "minecraft:emerald_block" => Some(Block::EmeraldBlock),
            "minecraft:spruce_stairs" => {
                let data = SpruceStairsData::from_map(props)?;
                Some(Block::SpruceStairs(data))
            }
            "minecraft:birch_stairs" => {
                let data = BirchStairsData::from_map(props)?;
                Some(Block::BirchStairs(data))
            }
            "minecraft:jungle_stairs" => {
                let data = JungleStairsData::from_map(props)?;
                Some(Block::JungleStairs(data))
            }
            "minecraft:command_block" => {
                let data = CommandBlockData::from_map(props)?;
                Some(Block::CommandBlock(data))
            }
            "minecraft:beacon" => Some(Block::Beacon),
            "minecraft:cobblestone_wall" => {
                let data = CobblestoneWallData::from_map(props)?;
                Some(Block::CobblestoneWall(data))
            }
            "minecraft:mossy_cobblestone_wall" => {
                let data = MossyCobblestoneWallData::from_map(props)?;
                Some(Block::MossyCobblestoneWall(data))
            }
            "minecraft:flower_pot" => Some(Block::FlowerPot),
            "minecraft:potted_oak_sapling" => Some(Block::PottedOakSapling),
            "minecraft:potted_spruce_sapling" => Some(Block::PottedSpruceSapling),
            "minecraft:potted_birch_sapling" => Some(Block::PottedBirchSapling),
            "minecraft:potted_jungle_sapling" => Some(Block::PottedJungleSapling),
            "minecraft:potted_acacia_sapling" => Some(Block::PottedAcaciaSapling),
            "minecraft:potted_dark_oak_sapling" => Some(Block::PottedDarkOakSapling),
            "minecraft:potted_fern" => Some(Block::PottedFern),
            "minecraft:potted_dandelion" => Some(Block::PottedDandelion),
            "minecraft:potted_poppy" => Some(Block::PottedPoppy),
            "minecraft:potted_blue_orchid" => Some(Block::PottedBlueOrchid),
            "minecraft:potted_allium" => Some(Block::PottedAllium),
            "minecraft:potted_azure_bluet" => Some(Block::PottedAzureBluet),
            "minecraft:potted_red_tulip" => Some(Block::PottedRedTulip),
            "minecraft:potted_orange_tulip" => Some(Block::PottedOrangeTulip),
            "minecraft:potted_white_tulip" => Some(Block::PottedWhiteTulip),
            "minecraft:potted_pink_tulip" => Some(Block::PottedPinkTulip),
            "minecraft:potted_oxeye_daisy" => Some(Block::PottedOxeyeDaisy),
            "minecraft:potted_red_mushroom" => Some(Block::PottedRedMushroom),
            "minecraft:potted_brown_mushroom" => Some(Block::PottedBrownMushroom),
            "minecraft:potted_dead_bush" => Some(Block::PottedDeadBush),
            "minecraft:potted_cactus" => Some(Block::PottedCactus),
            "minecraft:carrots" => {
                let data = CarrotsData::from_map(props)?;
                Some(Block::Carrots(data))
            }
            "minecraft:potatoes" => {
                let data = PotatoesData::from_map(props)?;
                Some(Block::Potatoes(data))
            }
            "minecraft:oak_button" => {
                let data = OakButtonData::from_map(props)?;
                Some(Block::OakButton(data))
            }
            "minecraft:spruce_button" => {
                let data = SpruceButtonData::from_map(props)?;
                Some(Block::SpruceButton(data))
            }
            "minecraft:birch_button" => {
                let data = BirchButtonData::from_map(props)?;
                Some(Block::BirchButton(data))
            }
            "minecraft:jungle_button" => {
                let data = JungleButtonData::from_map(props)?;
                Some(Block::JungleButton(data))
            }
            "minecraft:acacia_button" => {
                let data = AcaciaButtonData::from_map(props)?;
                Some(Block::AcaciaButton(data))
            }
            "minecraft:dark_oak_button" => {
                let data = DarkOakButtonData::from_map(props)?;
                Some(Block::DarkOakButton(data))
            }
            "minecraft:skeleton_wall_skull" => {
                let data = SkeletonWallSkullData::from_map(props)?;
                Some(Block::SkeletonWallSkull(data))
            }
            "minecraft:skeleton_skull" => {
                let data = SkeletonSkullData::from_map(props)?;
                Some(Block::SkeletonSkull(data))
            }
            "minecraft:wither_skeleton_wall_skull" => {
                let data = WitherSkeletonWallSkullData::from_map(props)?;
                Some(Block::WitherSkeletonWallSkull(data))
            }
            "minecraft:wither_skeleton_skull" => {
                let data = WitherSkeletonSkullData::from_map(props)?;
                Some(Block::WitherSkeletonSkull(data))
            }
            "minecraft:zombie_wall_head" => {
                let data = ZombieWallHeadData::from_map(props)?;
                Some(Block::ZombieWallHead(data))
            }
            "minecraft:zombie_head" => {
                let data = ZombieHeadData::from_map(props)?;
                Some(Block::ZombieHead(data))
            }
            "minecraft:player_wall_head" => {
                let data = PlayerWallHeadData::from_map(props)?;
                Some(Block::PlayerWallHead(data))
            }
            "minecraft:player_head" => {
                let data = PlayerHeadData::from_map(props)?;
                Some(Block::PlayerHead(data))
            }
            "minecraft:creeper_wall_head" => {
                let data = CreeperWallHeadData::from_map(props)?;
                Some(Block::CreeperWallHead(data))
            }
            "minecraft:creeper_head" => {
                let data = CreeperHeadData::from_map(props)?;
                Some(Block::CreeperHead(data))
            }
            "minecraft:dragon_wall_head" => {
                let data = DragonWallHeadData::from_map(props)?;
                Some(Block::DragonWallHead(data))
            }
            "minecraft:dragon_head" => {
                let data = DragonHeadData::from_map(props)?;
                Some(Block::DragonHead(data))
            }
            "minecraft:anvil" => {
                let data = AnvilData::from_map(props)?;
                Some(Block::Anvil(data))
            }
            "minecraft:chipped_anvil" => {
                let data = ChippedAnvilData::from_map(props)?;
                Some(Block::ChippedAnvil(data))
            }
            "minecraft:damaged_anvil" => {
                let data = DamagedAnvilData::from_map(props)?;
                Some(Block::DamagedAnvil(data))
            }
            "minecraft:trapped_chest" => {
                let data = TrappedChestData::from_map(props)?;
                Some(Block::TrappedChest(data))
            }
            "minecraft:light_weighted_pressure_plate" => {
                let data = LightWeightedPressurePlateData::from_map(props)?;
                Some(Block::LightWeightedPressurePlate(data))
            }
            "minecraft:heavy_weighted_pressure_plate" => {
                let data = HeavyWeightedPressurePlateData::from_map(props)?;
                Some(Block::HeavyWeightedPressurePlate(data))
            }
            "minecraft:comparator" => {
                let data = ComparatorData::from_map(props)?;
                Some(Block::Comparator(data))
            }
            "minecraft:daylight_detector" => {
                let data = DaylightDetectorData::from_map(props)?;
                Some(Block::DaylightDetector(data))
            }
            "minecraft:redstone_block" => Some(Block::RedstoneBlock),
            "minecraft:nether_quartz_ore" => Some(Block::NetherQuartzOre),
            "minecraft:hopper" => {
                let data = HopperData::from_map(props)?;
                Some(Block::Hopper(data))
            }
            "minecraft:quartz_block" => Some(Block::QuartzBlock),
            "minecraft:chiseled_quartz_block" => Some(Block::ChiseledQuartzBlock),
            "minecraft:quartz_pillar" => {
                let data = QuartzPillarData::from_map(props)?;
                Some(Block::QuartzPillar(data))
            }
            "minecraft:quartz_stairs" => {
                let data = QuartzStairsData::from_map(props)?;
                Some(Block::QuartzStairs(data))
            }
            "minecraft:activator_rail" => {
                let data = ActivatorRailData::from_map(props)?;
                Some(Block::ActivatorRail(data))
            }
            "minecraft:dropper" => {
                let data = DropperData::from_map(props)?;
                Some(Block::Dropper(data))
            }
            "minecraft:white_terracotta" => Some(Block::WhiteTerracotta),
            "minecraft:orange_terracotta" => Some(Block::OrangeTerracotta),
            "minecraft:magenta_terracotta" => Some(Block::MagentaTerracotta),
            "minecraft:light_blue_terracotta" => Some(Block::LightBlueTerracotta),
            "minecraft:yellow_terracotta" => Some(Block::YellowTerracotta),
            "minecraft:lime_terracotta" => Some(Block::LimeTerracotta),
            "minecraft:pink_terracotta" => Some(Block::PinkTerracotta),
            "minecraft:gray_terracotta" => Some(Block::GrayTerracotta),
            "minecraft:light_gray_terracotta" => Some(Block::LightGrayTerracotta),
            "minecraft:cyan_terracotta" => Some(Block::CyanTerracotta),
            "minecraft:purple_terracotta" => Some(Block::PurpleTerracotta),
            "minecraft:blue_terracotta" => Some(Block::BlueTerracotta),
            "minecraft:brown_terracotta" => Some(Block::BrownTerracotta),
            "minecraft:green_terracotta" => Some(Block::GreenTerracotta),
            "minecraft:red_terracotta" => Some(Block::RedTerracotta),
            "minecraft:black_terracotta" => Some(Block::BlackTerracotta),
            "minecraft:white_stained_glass_pane" => {
                let data = WhiteStainedGlassPaneData::from_map(props)?;
                Some(Block::WhiteStainedGlassPane(data))
            }
            "minecraft:orange_stained_glass_pane" => {
                let data = OrangeStainedGlassPaneData::from_map(props)?;
                Some(Block::OrangeStainedGlassPane(data))
            }
            "minecraft:magenta_stained_glass_pane" => {
                let data = MagentaStainedGlassPaneData::from_map(props)?;
                Some(Block::MagentaStainedGlassPane(data))
            }
            "minecraft:light_blue_stained_glass_pane" => {
                let data = LightBlueStainedGlassPaneData::from_map(props)?;
                Some(Block::LightBlueStainedGlassPane(data))
            }
            "minecraft:yellow_stained_glass_pane" => {
                let data = YellowStainedGlassPaneData::from_map(props)?;
                Some(Block::YellowStainedGlassPane(data))
            }
            "minecraft:lime_stained_glass_pane" => {
                let data = LimeStainedGlassPaneData::from_map(props)?;
                Some(Block::LimeStainedGlassPane(data))
            }
            "minecraft:pink_stained_glass_pane" => {
                let data = PinkStainedGlassPaneData::from_map(props)?;
                Some(Block::PinkStainedGlassPane(data))
            }
            "minecraft:gray_stained_glass_pane" => {
                let data = GrayStainedGlassPaneData::from_map(props)?;
                Some(Block::GrayStainedGlassPane(data))
            }
            "minecraft:light_gray_stained_glass_pane" => {
                let data = LightGrayStainedGlassPaneData::from_map(props)?;
                Some(Block::LightGrayStainedGlassPane(data))
            }
            "minecraft:cyan_stained_glass_pane" => {
                let data = CyanStainedGlassPaneData::from_map(props)?;
                Some(Block::CyanStainedGlassPane(data))
            }
            "minecraft:purple_stained_glass_pane" => {
                let data = PurpleStainedGlassPaneData::from_map(props)?;
                Some(Block::PurpleStainedGlassPane(data))
            }
            "minecraft:blue_stained_glass_pane" => {
                let data = BlueStainedGlassPaneData::from_map(props)?;
                Some(Block::BlueStainedGlassPane(data))
            }
            "minecraft:brown_stained_glass_pane" => {
                let data = BrownStainedGlassPaneData::from_map(props)?;
                Some(Block::BrownStainedGlassPane(data))
            }
            "minecraft:green_stained_glass_pane" => {
                let data = GreenStainedGlassPaneData::from_map(props)?;
                Some(Block::GreenStainedGlassPane(data))
            }
            "minecraft:red_stained_glass_pane" => {
                let data = RedStainedGlassPaneData::from_map(props)?;
                Some(Block::RedStainedGlassPane(data))
            }
            "minecraft:black_stained_glass_pane" => {
                let data = BlackStainedGlassPaneData::from_map(props)?;
                Some(Block::BlackStainedGlassPane(data))
            }
            "minecraft:acacia_stairs" => {
                let data = AcaciaStairsData::from_map(props)?;
                Some(Block::AcaciaStairs(data))
            }
            "minecraft:dark_oak_stairs" => {
                let data = DarkOakStairsData::from_map(props)?;
                Some(Block::DarkOakStairs(data))
            }
            "minecraft:slime_block" => Some(Block::SlimeBlock),
            "minecraft:barrier" => Some(Block::Barrier),
            "minecraft:iron_trapdoor" => {
                let data = IronTrapdoorData::from_map(props)?;
                Some(Block::IronTrapdoor(data))
            }
            "minecraft:prismarine" => Some(Block::Prismarine),
            "minecraft:prismarine_bricks" => Some(Block::PrismarineBricks),
            "minecraft:dark_prismarine" => Some(Block::DarkPrismarine),
            "minecraft:prismarine_stairs" => {
                let data = PrismarineStairsData::from_map(props)?;
                Some(Block::PrismarineStairs(data))
            }
            "minecraft:prismarine_brick_stairs" => {
                let data = PrismarineBrickStairsData::from_map(props)?;
                Some(Block::PrismarineBrickStairs(data))
            }
            "minecraft:dark_prismarine_stairs" => {
                let data = DarkPrismarineStairsData::from_map(props)?;
                Some(Block::DarkPrismarineStairs(data))
            }
            "minecraft:prismarine_slab" => {
                let data = PrismarineSlabData::from_map(props)?;
                Some(Block::PrismarineSlab(data))
            }
            "minecraft:prismarine_brick_slab" => {
                let data = PrismarineBrickSlabData::from_map(props)?;
                Some(Block::PrismarineBrickSlab(data))
            }
            "minecraft:dark_prismarine_slab" => {
                let data = DarkPrismarineSlabData::from_map(props)?;
                Some(Block::DarkPrismarineSlab(data))
            }
            "minecraft:sea_lantern" => Some(Block::SeaLantern),
            "minecraft:hay_block" => {
                let data = HayBlockData::from_map(props)?;
                Some(Block::HayBlock(data))
            }
            "minecraft:white_carpet" => Some(Block::WhiteCarpet),
            "minecraft:orange_carpet" => Some(Block::OrangeCarpet),
            "minecraft:magenta_carpet" => Some(Block::MagentaCarpet),
            "minecraft:light_blue_carpet" => Some(Block::LightBlueCarpet),
            "minecraft:yellow_carpet" => Some(Block::YellowCarpet),
            "minecraft:lime_carpet" => Some(Block::LimeCarpet),
            "minecraft:pink_carpet" => Some(Block::PinkCarpet),
            "minecraft:gray_carpet" => Some(Block::GrayCarpet),
            "minecraft:light_gray_carpet" => Some(Block::LightGrayCarpet),
            "minecraft:cyan_carpet" => Some(Block::CyanCarpet),
            "minecraft:purple_carpet" => Some(Block::PurpleCarpet),
            "minecraft:blue_carpet" => Some(Block::BlueCarpet),
            "minecraft:brown_carpet" => Some(Block::BrownCarpet),
            "minecraft:green_carpet" => Some(Block::GreenCarpet),
            "minecraft:red_carpet" => Some(Block::RedCarpet),
            "minecraft:black_carpet" => Some(Block::BlackCarpet),
            "minecraft:terracotta" => Some(Block::Terracotta),
            "minecraft:coal_block" => Some(Block::CoalBlock),
            "minecraft:packed_ice" => Some(Block::PackedIce),
            "minecraft:sunflower" => {
                let data = SunflowerData::from_map(props)?;
                Some(Block::Sunflower(data))
            }
            "minecraft:lilac" => {
                let data = LilacData::from_map(props)?;
                Some(Block::Lilac(data))
            }
            "minecraft:rose_bush" => {
                let data = RoseBushData::from_map(props)?;
                Some(Block::RoseBush(data))
            }
            "minecraft:peony" => {
                let data = PeonyData::from_map(props)?;
                Some(Block::Peony(data))
            }
            "minecraft:tall_grass" => {
                let data = TallGrassData::from_map(props)?;
                Some(Block::TallGrass(data))
            }
            "minecraft:large_fern" => {
                let data = LargeFernData::from_map(props)?;
                Some(Block::LargeFern(data))
            }
            "minecraft:white_banner" => {
                let data = WhiteBannerData::from_map(props)?;
                Some(Block::WhiteBanner(data))
            }
            "minecraft:orange_banner" => {
                let data = OrangeBannerData::from_map(props)?;
                Some(Block::OrangeBanner(data))
            }
            "minecraft:magenta_banner" => {
                let data = MagentaBannerData::from_map(props)?;
                Some(Block::MagentaBanner(data))
            }
            "minecraft:light_blue_banner" => {
                let data = LightBlueBannerData::from_map(props)?;
                Some(Block::LightBlueBanner(data))
            }
            "minecraft:yellow_banner" => {
                let data = YellowBannerData::from_map(props)?;
                Some(Block::YellowBanner(data))
            }
            "minecraft:lime_banner" => {
                let data = LimeBannerData::from_map(props)?;
                Some(Block::LimeBanner(data))
            }
            "minecraft:pink_banner" => {
                let data = PinkBannerData::from_map(props)?;
                Some(Block::PinkBanner(data))
            }
            "minecraft:gray_banner" => {
                let data = GrayBannerData::from_map(props)?;
                Some(Block::GrayBanner(data))
            }
            "minecraft:light_gray_banner" => {
                let data = LightGrayBannerData::from_map(props)?;
                Some(Block::LightGrayBanner(data))
            }
            "minecraft:cyan_banner" => {
                let data = CyanBannerData::from_map(props)?;
                Some(Block::CyanBanner(data))
            }
            "minecraft:purple_banner" => {
                let data = PurpleBannerData::from_map(props)?;
                Some(Block::PurpleBanner(data))
            }
            "minecraft:blue_banner" => {
                let data = BlueBannerData::from_map(props)?;
                Some(Block::BlueBanner(data))
            }
            "minecraft:brown_banner" => {
                let data = BrownBannerData::from_map(props)?;
                Some(Block::BrownBanner(data))
            }
            "minecraft:green_banner" => {
                let data = GreenBannerData::from_map(props)?;
                Some(Block::GreenBanner(data))
            }
            "minecraft:red_banner" => {
                let data = RedBannerData::from_map(props)?;
                Some(Block::RedBanner(data))
            }
            "minecraft:black_banner" => {
                let data = BlackBannerData::from_map(props)?;
                Some(Block::BlackBanner(data))
            }
            "minecraft:white_wall_banner" => {
                let data = WhiteWallBannerData::from_map(props)?;
                Some(Block::WhiteWallBanner(data))
            }
            "minecraft:orange_wall_banner" => {
                let data = OrangeWallBannerData::from_map(props)?;
                Some(Block::OrangeWallBanner(data))
            }
            "minecraft:magenta_wall_banner" => {
                let data = MagentaWallBannerData::from_map(props)?;
                Some(Block::MagentaWallBanner(data))
            }
            "minecraft:light_blue_wall_banner" => {
                let data = LightBlueWallBannerData::from_map(props)?;
                Some(Block::LightBlueWallBanner(data))
            }
            "minecraft:yellow_wall_banner" => {
                let data = YellowWallBannerData::from_map(props)?;
                Some(Block::YellowWallBanner(data))
            }
            "minecraft:lime_wall_banner" => {
                let data = LimeWallBannerData::from_map(props)?;
                Some(Block::LimeWallBanner(data))
            }
            "minecraft:pink_wall_banner" => {
                let data = PinkWallBannerData::from_map(props)?;
                Some(Block::PinkWallBanner(data))
            }
            "minecraft:gray_wall_banner" => {
                let data = GrayWallBannerData::from_map(props)?;
                Some(Block::GrayWallBanner(data))
            }
            "minecraft:light_gray_wall_banner" => {
                let data = LightGrayWallBannerData::from_map(props)?;
                Some(Block::LightGrayWallBanner(data))
            }
            "minecraft:cyan_wall_banner" => {
                let data = CyanWallBannerData::from_map(props)?;
                Some(Block::CyanWallBanner(data))
            }
            "minecraft:purple_wall_banner" => {
                let data = PurpleWallBannerData::from_map(props)?;
                Some(Block::PurpleWallBanner(data))
            }
            "minecraft:blue_wall_banner" => {
                let data = BlueWallBannerData::from_map(props)?;
                Some(Block::BlueWallBanner(data))
            }
            "minecraft:brown_wall_banner" => {
                let data = BrownWallBannerData::from_map(props)?;
                Some(Block::BrownWallBanner(data))
            }
            "minecraft:green_wall_banner" => {
                let data = GreenWallBannerData::from_map(props)?;
                Some(Block::GreenWallBanner(data))
            }
            "minecraft:red_wall_banner" => {
                let data = RedWallBannerData::from_map(props)?;
                Some(Block::RedWallBanner(data))
            }
            "minecraft:black_wall_banner" => {
                let data = BlackWallBannerData::from_map(props)?;
                Some(Block::BlackWallBanner(data))
            }
            "minecraft:red_sandstone" => Some(Block::RedSandstone),
            "minecraft:chiseled_red_sandstone" => Some(Block::ChiseledRedSandstone),
            "minecraft:cut_red_sandstone" => Some(Block::CutRedSandstone),
            "minecraft:red_sandstone_stairs" => {
                let data = RedSandstoneStairsData::from_map(props)?;
                Some(Block::RedSandstoneStairs(data))
            }
            "minecraft:oak_slab" => {
                let data = OakSlabData::from_map(props)?;
                Some(Block::OakSlab(data))
            }
            "minecraft:spruce_slab" => {
                let data = SpruceSlabData::from_map(props)?;
                Some(Block::SpruceSlab(data))
            }
            "minecraft:birch_slab" => {
                let data = BirchSlabData::from_map(props)?;
                Some(Block::BirchSlab(data))
            }
            "minecraft:jungle_slab" => {
                let data = JungleSlabData::from_map(props)?;
                Some(Block::JungleSlab(data))
            }
            "minecraft:acacia_slab" => {
                let data = AcaciaSlabData::from_map(props)?;
                Some(Block::AcaciaSlab(data))
            }
            "minecraft:dark_oak_slab" => {
                let data = DarkOakSlabData::from_map(props)?;
                Some(Block::DarkOakSlab(data))
            }
            "minecraft:stone_slab" => {
                let data = StoneSlabData::from_map(props)?;
                Some(Block::StoneSlab(data))
            }
            "minecraft:sandstone_slab" => {
                let data = SandstoneSlabData::from_map(props)?;
                Some(Block::SandstoneSlab(data))
            }
            "minecraft:petrified_oak_slab" => {
                let data = PetrifiedOakSlabData::from_map(props)?;
                Some(Block::PetrifiedOakSlab(data))
            }
            "minecraft:cobblestone_slab" => {
                let data = CobblestoneSlabData::from_map(props)?;
                Some(Block::CobblestoneSlab(data))
            }
            "minecraft:brick_slab" => {
                let data = BrickSlabData::from_map(props)?;
                Some(Block::BrickSlab(data))
            }
            "minecraft:stone_brick_slab" => {
                let data = StoneBrickSlabData::from_map(props)?;
                Some(Block::StoneBrickSlab(data))
            }
            "minecraft:nether_brick_slab" => {
                let data = NetherBrickSlabData::from_map(props)?;
                Some(Block::NetherBrickSlab(data))
            }
            "minecraft:quartz_slab" => {
                let data = QuartzSlabData::from_map(props)?;
                Some(Block::QuartzSlab(data))
            }
            "minecraft:red_sandstone_slab" => {
                let data = RedSandstoneSlabData::from_map(props)?;
                Some(Block::RedSandstoneSlab(data))
            }
            "minecraft:purpur_slab" => {
                let data = PurpurSlabData::from_map(props)?;
                Some(Block::PurpurSlab(data))
            }
            "minecraft:smooth_stone" => Some(Block::SmoothStone),
            "minecraft:smooth_sandstone" => Some(Block::SmoothSandstone),
            "minecraft:smooth_quartz" => Some(Block::SmoothQuartz),
            "minecraft:smooth_red_sandstone" => Some(Block::SmoothRedSandstone),
            "minecraft:spruce_fence_gate" => {
                let data = SpruceFenceGateData::from_map(props)?;
                Some(Block::SpruceFenceGate(data))
            }
            "minecraft:birch_fence_gate" => {
                let data = BirchFenceGateData::from_map(props)?;
                Some(Block::BirchFenceGate(data))
            }
            "minecraft:jungle_fence_gate" => {
                let data = JungleFenceGateData::from_map(props)?;
                Some(Block::JungleFenceGate(data))
            }
            "minecraft:acacia_fence_gate" => {
                let data = AcaciaFenceGateData::from_map(props)?;
                Some(Block::AcaciaFenceGate(data))
            }
            "minecraft:dark_oak_fence_gate" => {
                let data = DarkOakFenceGateData::from_map(props)?;
                Some(Block::DarkOakFenceGate(data))
            }
            "minecraft:spruce_fence" => {
                let data = SpruceFenceData::from_map(props)?;
                Some(Block::SpruceFence(data))
            }
            "minecraft:birch_fence" => {
                let data = BirchFenceData::from_map(props)?;
                Some(Block::BirchFence(data))
            }
            "minecraft:jungle_fence" => {
                let data = JungleFenceData::from_map(props)?;
                Some(Block::JungleFence(data))
            }
            "minecraft:acacia_fence" => {
                let data = AcaciaFenceData::from_map(props)?;
                Some(Block::AcaciaFence(data))
            }
            "minecraft:dark_oak_fence" => {
                let data = DarkOakFenceData::from_map(props)?;
                Some(Block::DarkOakFence(data))
            }
            "minecraft:spruce_door" => {
                let data = SpruceDoorData::from_map(props)?;
                Some(Block::SpruceDoor(data))
            }
            "minecraft:birch_door" => {
                let data = BirchDoorData::from_map(props)?;
                Some(Block::BirchDoor(data))
            }
            "minecraft:jungle_door" => {
                let data = JungleDoorData::from_map(props)?;
                Some(Block::JungleDoor(data))
            }
            "minecraft:acacia_door" => {
                let data = AcaciaDoorData::from_map(props)?;
                Some(Block::AcaciaDoor(data))
            }
            "minecraft:dark_oak_door" => {
                let data = DarkOakDoorData::from_map(props)?;
                Some(Block::DarkOakDoor(data))
            }
            "minecraft:end_rod" => {
                let data = EndRodData::from_map(props)?;
                Some(Block::EndRod(data))
            }
            "minecraft:chorus_plant" => {
                let data = ChorusPlantData::from_map(props)?;
                Some(Block::ChorusPlant(data))
            }
            "minecraft:chorus_flower" => {
                let data = ChorusFlowerData::from_map(props)?;
                Some(Block::ChorusFlower(data))
            }
            "minecraft:purpur_block" => Some(Block::PurpurBlock),
            "minecraft:purpur_pillar" => {
                let data = PurpurPillarData::from_map(props)?;
                Some(Block::PurpurPillar(data))
            }
            "minecraft:purpur_stairs" => {
                let data = PurpurStairsData::from_map(props)?;
                Some(Block::PurpurStairs(data))
            }
            "minecraft:end_stone_bricks" => Some(Block::EndStoneBricks),
            "minecraft:beetroots" => {
                let data = BeetrootsData::from_map(props)?;
                Some(Block::Beetroots(data))
            }
            "minecraft:grass_path" => Some(Block::GrassPath),
            "minecraft:end_gateway" => Some(Block::EndGateway),
            "minecraft:repeating_command_block" => {
                let data = RepeatingCommandBlockData::from_map(props)?;
                Some(Block::RepeatingCommandBlock(data))
            }
            "minecraft:chain_command_block" => {
                let data = ChainCommandBlockData::from_map(props)?;
                Some(Block::ChainCommandBlock(data))
            }
            "minecraft:frosted_ice" => {
                let data = FrostedIceData::from_map(props)?;
                Some(Block::FrostedIce(data))
            }
            "minecraft:magma_block" => Some(Block::MagmaBlock),
            "minecraft:nether_wart_block" => Some(Block::NetherWartBlock),
            "minecraft:red_nether_bricks" => Some(Block::RedNetherBricks),
            "minecraft:bone_block" => {
                let data = BoneBlockData::from_map(props)?;
                Some(Block::BoneBlock(data))
            }
            "minecraft:structure_void" => Some(Block::StructureVoid),
            "minecraft:observer" => {
                let data = ObserverData::from_map(props)?;
                Some(Block::Observer(data))
            }
            "minecraft:shulker_box" => {
                let data = ShulkerBoxData::from_map(props)?;
                Some(Block::ShulkerBox(data))
            }
            "minecraft:white_shulker_box" => {
                let data = WhiteShulkerBoxData::from_map(props)?;
                Some(Block::WhiteShulkerBox(data))
            }
            "minecraft:orange_shulker_box" => {
                let data = OrangeShulkerBoxData::from_map(props)?;
                Some(Block::OrangeShulkerBox(data))
            }
            "minecraft:magenta_shulker_box" => {
                let data = MagentaShulkerBoxData::from_map(props)?;
                Some(Block::MagentaShulkerBox(data))
            }
            "minecraft:light_blue_shulker_box" => {
                let data = LightBlueShulkerBoxData::from_map(props)?;
                Some(Block::LightBlueShulkerBox(data))
            }
            "minecraft:yellow_shulker_box" => {
                let data = YellowShulkerBoxData::from_map(props)?;
                Some(Block::YellowShulkerBox(data))
            }
            "minecraft:lime_shulker_box" => {
                let data = LimeShulkerBoxData::from_map(props)?;
                Some(Block::LimeShulkerBox(data))
            }
            "minecraft:pink_shulker_box" => {
                let data = PinkShulkerBoxData::from_map(props)?;
                Some(Block::PinkShulkerBox(data))
            }
            "minecraft:gray_shulker_box" => {
                let data = GrayShulkerBoxData::from_map(props)?;
                Some(Block::GrayShulkerBox(data))
            }
            "minecraft:light_gray_shulker_box" => {
                let data = LightGrayShulkerBoxData::from_map(props)?;
                Some(Block::LightGrayShulkerBox(data))
            }
            "minecraft:cyan_shulker_box" => {
                let data = CyanShulkerBoxData::from_map(props)?;
                Some(Block::CyanShulkerBox(data))
            }
            "minecraft:purple_shulker_box" => {
                let data = PurpleShulkerBoxData::from_map(props)?;
                Some(Block::PurpleShulkerBox(data))
            }
            "minecraft:blue_shulker_box" => {
                let data = BlueShulkerBoxData::from_map(props)?;
                Some(Block::BlueShulkerBox(data))
            }
            "minecraft:brown_shulker_box" => {
                let data = BrownShulkerBoxData::from_map(props)?;
                Some(Block::BrownShulkerBox(data))
            }
            "minecraft:green_shulker_box" => {
                let data = GreenShulkerBoxData::from_map(props)?;
                Some(Block::GreenShulkerBox(data))
            }
            "minecraft:red_shulker_box" => {
                let data = RedShulkerBoxData::from_map(props)?;
                Some(Block::RedShulkerBox(data))
            }
            "minecraft:black_shulker_box" => {
                let data = BlackShulkerBoxData::from_map(props)?;
                Some(Block::BlackShulkerBox(data))
            }
            "minecraft:white_glazed_terracotta" => {
                let data = WhiteGlazedTerracottaData::from_map(props)?;
                Some(Block::WhiteGlazedTerracotta(data))
            }
            "minecraft:orange_glazed_terracotta" => {
                let data = OrangeGlazedTerracottaData::from_map(props)?;
                Some(Block::OrangeGlazedTerracotta(data))
            }
            "minecraft:magenta_glazed_terracotta" => {
                let data = MagentaGlazedTerracottaData::from_map(props)?;
                Some(Block::MagentaGlazedTerracotta(data))
            }
            "minecraft:light_blue_glazed_terracotta" => {
                let data = LightBlueGlazedTerracottaData::from_map(props)?;
                Some(Block::LightBlueGlazedTerracotta(data))
            }
            "minecraft:yellow_glazed_terracotta" => {
                let data = YellowGlazedTerracottaData::from_map(props)?;
                Some(Block::YellowGlazedTerracotta(data))
            }
            "minecraft:lime_glazed_terracotta" => {
                let data = LimeGlazedTerracottaData::from_map(props)?;
                Some(Block::LimeGlazedTerracotta(data))
            }
            "minecraft:pink_glazed_terracotta" => {
                let data = PinkGlazedTerracottaData::from_map(props)?;
                Some(Block::PinkGlazedTerracotta(data))
            }
            "minecraft:gray_glazed_terracotta" => {
                let data = GrayGlazedTerracottaData::from_map(props)?;
                Some(Block::GrayGlazedTerracotta(data))
            }
            "minecraft:light_gray_glazed_terracotta" => {
                let data = LightGrayGlazedTerracottaData::from_map(props)?;
                Some(Block::LightGrayGlazedTerracotta(data))
            }
            "minecraft:cyan_glazed_terracotta" => {
                let data = CyanGlazedTerracottaData::from_map(props)?;
                Some(Block::CyanGlazedTerracotta(data))
            }
            "minecraft:purple_glazed_terracotta" => {
                let data = PurpleGlazedTerracottaData::from_map(props)?;
                Some(Block::PurpleGlazedTerracotta(data))
            }
            "minecraft:blue_glazed_terracotta" => {
                let data = BlueGlazedTerracottaData::from_map(props)?;
                Some(Block::BlueGlazedTerracotta(data))
            }
            "minecraft:brown_glazed_terracotta" => {
                let data = BrownGlazedTerracottaData::from_map(props)?;
                Some(Block::BrownGlazedTerracotta(data))
            }
            "minecraft:green_glazed_terracotta" => {
                let data = GreenGlazedTerracottaData::from_map(props)?;
                Some(Block::GreenGlazedTerracotta(data))
            }
            "minecraft:red_glazed_terracotta" => {
                let data = RedGlazedTerracottaData::from_map(props)?;
                Some(Block::RedGlazedTerracotta(data))
            }
            "minecraft:black_glazed_terracotta" => {
                let data = BlackGlazedTerracottaData::from_map(props)?;
                Some(Block::BlackGlazedTerracotta(data))
            }
            "minecraft:white_concrete" => Some(Block::WhiteConcrete),
            "minecraft:orange_concrete" => Some(Block::OrangeConcrete),
            "minecraft:magenta_concrete" => Some(Block::MagentaConcrete),
            "minecraft:light_blue_concrete" => Some(Block::LightBlueConcrete),
            "minecraft:yellow_concrete" => Some(Block::YellowConcrete),
            "minecraft:lime_concrete" => Some(Block::LimeConcrete),
            "minecraft:pink_concrete" => Some(Block::PinkConcrete),
            "minecraft:gray_concrete" => Some(Block::GrayConcrete),
            "minecraft:light_gray_concrete" => Some(Block::LightGrayConcrete),
            "minecraft:cyan_concrete" => Some(Block::CyanConcrete),
            "minecraft:purple_concrete" => Some(Block::PurpleConcrete),
            "minecraft:blue_concrete" => Some(Block::BlueConcrete),
            "minecraft:brown_concrete" => Some(Block::BrownConcrete),
            "minecraft:green_concrete" => Some(Block::GreenConcrete),
            "minecraft:red_concrete" => Some(Block::RedConcrete),
            "minecraft:black_concrete" => Some(Block::BlackConcrete),
            "minecraft:white_concrete_powder" => Some(Block::WhiteConcretePowder),
            "minecraft:orange_concrete_powder" => Some(Block::OrangeConcretePowder),
            "minecraft:magenta_concrete_powder" => Some(Block::MagentaConcretePowder),
            "minecraft:light_blue_concrete_powder" => Some(Block::LightBlueConcretePowder),
            "minecraft:yellow_concrete_powder" => Some(Block::YellowConcretePowder),
            "minecraft:lime_concrete_powder" => Some(Block::LimeConcretePowder),
            "minecraft:pink_concrete_powder" => Some(Block::PinkConcretePowder),
            "minecraft:gray_concrete_powder" => Some(Block::GrayConcretePowder),
            "minecraft:light_gray_concrete_powder" => Some(Block::LightGrayConcretePowder),
            "minecraft:cyan_concrete_powder" => Some(Block::CyanConcretePowder),
            "minecraft:purple_concrete_powder" => Some(Block::PurpleConcretePowder),
            "minecraft:blue_concrete_powder" => Some(Block::BlueConcretePowder),
            "minecraft:brown_concrete_powder" => Some(Block::BrownConcretePowder),
            "minecraft:green_concrete_powder" => Some(Block::GreenConcretePowder),
            "minecraft:red_concrete_powder" => Some(Block::RedConcretePowder),
            "minecraft:black_concrete_powder" => Some(Block::BlackConcretePowder),
            "minecraft:kelp" => {
                let data = KelpData::from_map(props)?;
                Some(Block::Kelp(data))
            }
            "minecraft:kelp_plant" => Some(Block::KelpPlant),
            "minecraft:dried_kelp_block" => Some(Block::DriedKelpBlock),
            "minecraft:turtle_egg" => {
                let data = TurtleEggData::from_map(props)?;
                Some(Block::TurtleEgg(data))
            }
            "minecraft:dead_tube_coral_block" => Some(Block::DeadTubeCoralBlock),
            "minecraft:dead_brain_coral_block" => Some(Block::DeadBrainCoralBlock),
            "minecraft:dead_bubble_coral_block" => Some(Block::DeadBubbleCoralBlock),
            "minecraft:dead_fire_coral_block" => Some(Block::DeadFireCoralBlock),
            "minecraft:dead_horn_coral_block" => Some(Block::DeadHornCoralBlock),
            "minecraft:tube_coral_block" => Some(Block::TubeCoralBlock),
            "minecraft:brain_coral_block" => Some(Block::BrainCoralBlock),
            "minecraft:bubble_coral_block" => Some(Block::BubbleCoralBlock),
            "minecraft:fire_coral_block" => Some(Block::FireCoralBlock),
            "minecraft:horn_coral_block" => Some(Block::HornCoralBlock),
            "minecraft:dead_tube_coral" => {
                let data = DeadTubeCoralData::from_map(props)?;
                Some(Block::DeadTubeCoral(data))
            }
            "minecraft:dead_brain_coral" => {
                let data = DeadBrainCoralData::from_map(props)?;
                Some(Block::DeadBrainCoral(data))
            }
            "minecraft:dead_bubble_coral" => {
                let data = DeadBubbleCoralData::from_map(props)?;
                Some(Block::DeadBubbleCoral(data))
            }
            "minecraft:dead_fire_coral" => {
                let data = DeadFireCoralData::from_map(props)?;
                Some(Block::DeadFireCoral(data))
            }
            "minecraft:dead_horn_coral" => {
                let data = DeadHornCoralData::from_map(props)?;
                Some(Block::DeadHornCoral(data))
            }
            "minecraft:tube_coral" => {
                let data = TubeCoralData::from_map(props)?;
                Some(Block::TubeCoral(data))
            }
            "minecraft:brain_coral" => {
                let data = BrainCoralData::from_map(props)?;
                Some(Block::BrainCoral(data))
            }
            "minecraft:bubble_coral" => {
                let data = BubbleCoralData::from_map(props)?;
                Some(Block::BubbleCoral(data))
            }
            "minecraft:fire_coral" => {
                let data = FireCoralData::from_map(props)?;
                Some(Block::FireCoral(data))
            }
            "minecraft:horn_coral" => {
                let data = HornCoralData::from_map(props)?;
                Some(Block::HornCoral(data))
            }
            "minecraft:dead_tube_coral_wall_fan" => {
                let data = DeadTubeCoralWallFanData::from_map(props)?;
                Some(Block::DeadTubeCoralWallFan(data))
            }
            "minecraft:dead_brain_coral_wall_fan" => {
                let data = DeadBrainCoralWallFanData::from_map(props)?;
                Some(Block::DeadBrainCoralWallFan(data))
            }
            "minecraft:dead_bubble_coral_wall_fan" => {
                let data = DeadBubbleCoralWallFanData::from_map(props)?;
                Some(Block::DeadBubbleCoralWallFan(data))
            }
            "minecraft:dead_fire_coral_wall_fan" => {
                let data = DeadFireCoralWallFanData::from_map(props)?;
                Some(Block::DeadFireCoralWallFan(data))
            }
            "minecraft:dead_horn_coral_wall_fan" => {
                let data = DeadHornCoralWallFanData::from_map(props)?;
                Some(Block::DeadHornCoralWallFan(data))
            }
            "minecraft:tube_coral_wall_fan" => {
                let data = TubeCoralWallFanData::from_map(props)?;
                Some(Block::TubeCoralWallFan(data))
            }
            "minecraft:brain_coral_wall_fan" => {
                let data = BrainCoralWallFanData::from_map(props)?;
                Some(Block::BrainCoralWallFan(data))
            }
            "minecraft:bubble_coral_wall_fan" => {
                let data = BubbleCoralWallFanData::from_map(props)?;
                Some(Block::BubbleCoralWallFan(data))
            }
            "minecraft:fire_coral_wall_fan" => {
                let data = FireCoralWallFanData::from_map(props)?;
                Some(Block::FireCoralWallFan(data))
            }
            "minecraft:horn_coral_wall_fan" => {
                let data = HornCoralWallFanData::from_map(props)?;
                Some(Block::HornCoralWallFan(data))
            }
            "minecraft:dead_tube_coral_fan" => {
                let data = DeadTubeCoralFanData::from_map(props)?;
                Some(Block::DeadTubeCoralFan(data))
            }
            "minecraft:dead_brain_coral_fan" => {
                let data = DeadBrainCoralFanData::from_map(props)?;
                Some(Block::DeadBrainCoralFan(data))
            }
            "minecraft:dead_bubble_coral_fan" => {
                let data = DeadBubbleCoralFanData::from_map(props)?;
                Some(Block::DeadBubbleCoralFan(data))
            }
            "minecraft:dead_fire_coral_fan" => {
                let data = DeadFireCoralFanData::from_map(props)?;
                Some(Block::DeadFireCoralFan(data))
            }
            "minecraft:dead_horn_coral_fan" => {
                let data = DeadHornCoralFanData::from_map(props)?;
                Some(Block::DeadHornCoralFan(data))
            }
            "minecraft:tube_coral_fan" => {
                let data = TubeCoralFanData::from_map(props)?;
                Some(Block::TubeCoralFan(data))
            }
            "minecraft:brain_coral_fan" => {
                let data = BrainCoralFanData::from_map(props)?;
                Some(Block::BrainCoralFan(data))
            }
            "minecraft:bubble_coral_fan" => {
                let data = BubbleCoralFanData::from_map(props)?;
                Some(Block::BubbleCoralFan(data))
            }
            "minecraft:fire_coral_fan" => {
                let data = FireCoralFanData::from_map(props)?;
                Some(Block::FireCoralFan(data))
            }
            "minecraft:horn_coral_fan" => {
                let data = HornCoralFanData::from_map(props)?;
                Some(Block::HornCoralFan(data))
            }
            "minecraft:sea_pickle" => {
                let data = SeaPickleData::from_map(props)?;
                Some(Block::SeaPickle(data))
            }
            "minecraft:blue_ice" => Some(Block::BlueIce),
            "minecraft:conduit" => {
                let data = ConduitData::from_map(props)?;
                Some(Block::Conduit(data))
            }
            "minecraft:void_air" => Some(Block::VoidAir),
            "minecraft:cave_air" => Some(Block::CaveAir),
            "minecraft:bubble_column" => {
                let data = BubbleColumnData::from_map(props)?;
                Some(Block::BubbleColumn(data))
            }
            "minecraft:structure_block" => {
                let data = StructureBlockData::from_map(props)?;
                Some(Block::StructureBlock(data))
            }
            _ => None,
        }
    }
}
pub trait Value {
    fn value(&self) -> usize;
}
impl Value for i32 {
    fn value(&self) -> usize {
        *self as usize
    }
}
impl Value for bool {
    fn value(&self) -> usize {
        match *self {
            true => 1,
            false => 0,
        }
    }
}
pub trait FromSnakeCase {
    fn from_snake_case(val: &str) -> Option<Self>
    where
        Self: Sized;
}
impl FromSnakeCase for i32 {
    fn from_snake_case(val: &str) -> Option<Self> {
        use std::str::FromStr;
        match i32::from_str(val) {
            Ok(x) => Some(x),
            Err(_) => None,
        }
    }
}
impl FromSnakeCase for bool {
    fn from_snake_case(val: &str) -> Option<Self> {
        use std::str::FromStr;
        match bool::from_str(val) {
            Ok(x) => Some(x),
            Err(_) => None,
        }
    }
}
pub trait ToSnakeCase {
    fn to_snake_case(&self) -> String;
}
impl ToSnakeCase for i32 {
    fn to_snake_case(&self) -> String {
        self.to_string()
    }
}
impl ToSnakeCase for bool {
    fn to_snake_case(&self) -> String {
        self.to_string()
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct GrassBlockData {
    snowy: bool,
}
impl GrassBlockData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            snowy: bool::from_snake_case(map.get("snowy")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("snowy".to_string(), self.snowy.to_snake_case());
        m
    }
}
impl Value for GrassBlockData {
    fn value(&self) -> usize {
        (self.snowy.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PodzolData {
    snowy: bool,
}
impl PodzolData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            snowy: bool::from_snake_case(map.get("snowy")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("snowy".to_string(), self.snowy.to_snake_case());
        m
    }
}
impl Value for PodzolData {
    fn value(&self) -> usize {
        (self.snowy.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OakSaplingData {
    stage: i32,
}
impl OakSaplingData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            stage: i32::from_snake_case(map.get("stage")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("stage".to_string(), self.stage.to_snake_case());
        m
    }
}
impl Value for OakSaplingData {
    fn value(&self) -> usize {
        (self.stage.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SpruceSaplingData {
    stage: i32,
}
impl SpruceSaplingData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            stage: i32::from_snake_case(map.get("stage")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("stage".to_string(), self.stage.to_snake_case());
        m
    }
}
impl Value for SpruceSaplingData {
    fn value(&self) -> usize {
        (self.stage.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BirchSaplingData {
    stage: i32,
}
impl BirchSaplingData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            stage: i32::from_snake_case(map.get("stage")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("stage".to_string(), self.stage.to_snake_case());
        m
    }
}
impl Value for BirchSaplingData {
    fn value(&self) -> usize {
        (self.stage.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct JungleSaplingData {
    stage: i32,
}
impl JungleSaplingData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            stage: i32::from_snake_case(map.get("stage")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("stage".to_string(), self.stage.to_snake_case());
        m
    }
}
impl Value for JungleSaplingData {
    fn value(&self) -> usize {
        (self.stage.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AcaciaSaplingData {
    stage: i32,
}
impl AcaciaSaplingData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            stage: i32::from_snake_case(map.get("stage")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("stage".to_string(), self.stage.to_snake_case());
        m
    }
}
impl Value for AcaciaSaplingData {
    fn value(&self) -> usize {
        (self.stage.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DarkOakSaplingData {
    stage: i32,
}
impl DarkOakSaplingData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            stage: i32::from_snake_case(map.get("stage")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("stage".to_string(), self.stage.to_snake_case());
        m
    }
}
impl Value for DarkOakSaplingData {
    fn value(&self) -> usize {
        (self.stage.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct WaterData {
    level: i32,
}
impl WaterData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            level: i32::from_snake_case(map.get("level")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("level".to_string(), self.level.to_snake_case());
        m
    }
}
impl Value for WaterData {
    fn value(&self) -> usize {
        (self.level.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LavaData {
    level: i32,
}
impl LavaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            level: i32::from_snake_case(map.get("level")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("level".to_string(), self.level.to_snake_case());
        m
    }
}
impl Value for LavaData {
    fn value(&self) -> usize {
        (self.level.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OakLogData {
    axis: Axis,
}
impl OakLogData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for OakLogData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SpruceLogData {
    axis: Axis,
}
impl SpruceLogData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for SpruceLogData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BirchLogData {
    axis: Axis,
}
impl BirchLogData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for BirchLogData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct JungleLogData {
    axis: Axis,
}
impl JungleLogData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for JungleLogData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AcaciaLogData {
    axis: Axis,
}
impl AcaciaLogData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for AcaciaLogData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DarkOakLogData {
    axis: Axis,
}
impl DarkOakLogData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for DarkOakLogData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StrippedSpruceLogData {
    axis: Axis,
}
impl StrippedSpruceLogData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for StrippedSpruceLogData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StrippedBirchLogData {
    axis: Axis,
}
impl StrippedBirchLogData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for StrippedBirchLogData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StrippedJungleLogData {
    axis: Axis,
}
impl StrippedJungleLogData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for StrippedJungleLogData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StrippedAcaciaLogData {
    axis: Axis,
}
impl StrippedAcaciaLogData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for StrippedAcaciaLogData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StrippedDarkOakLogData {
    axis: Axis,
}
impl StrippedDarkOakLogData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for StrippedDarkOakLogData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StrippedOakLogData {
    axis: Axis,
}
impl StrippedOakLogData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for StrippedOakLogData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OakWoodData {
    axis: Axis,
}
impl OakWoodData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for OakWoodData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SpruceWoodData {
    axis: Axis,
}
impl SpruceWoodData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for SpruceWoodData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BirchWoodData {
    axis: Axis,
}
impl BirchWoodData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for BirchWoodData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct JungleWoodData {
    axis: Axis,
}
impl JungleWoodData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for JungleWoodData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AcaciaWoodData {
    axis: Axis,
}
impl AcaciaWoodData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for AcaciaWoodData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DarkOakWoodData {
    axis: Axis,
}
impl DarkOakWoodData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for DarkOakWoodData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StrippedOakWoodData {
    axis: Axis,
}
impl StrippedOakWoodData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for StrippedOakWoodData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StrippedSpruceWoodData {
    axis: Axis,
}
impl StrippedSpruceWoodData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for StrippedSpruceWoodData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StrippedBirchWoodData {
    axis: Axis,
}
impl StrippedBirchWoodData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for StrippedBirchWoodData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StrippedJungleWoodData {
    axis: Axis,
}
impl StrippedJungleWoodData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for StrippedJungleWoodData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StrippedAcaciaWoodData {
    axis: Axis,
}
impl StrippedAcaciaWoodData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for StrippedAcaciaWoodData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StrippedDarkOakWoodData {
    axis: Axis,
}
impl StrippedDarkOakWoodData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for StrippedDarkOakWoodData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OakLeavesData {
    distance: i32,
    persistent: bool,
}
impl OakLeavesData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            distance: i32::from_snake_case(map.get("distance")?)?,
            persistent: bool::from_snake_case(map.get("persistent")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("distance".to_string(), self.distance.to_snake_case());
        m.insert("persistent".to_string(), self.persistent.to_snake_case());
        m
    }
}
impl Value for OakLeavesData {
    fn value(&self) -> usize {
        (self.distance.value() * 2usize) + (self.persistent.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SpruceLeavesData {
    persistent: bool,
    distance: i32,
}
impl SpruceLeavesData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            persistent: bool::from_snake_case(map.get("persistent")?)?,
            distance: i32::from_snake_case(map.get("distance")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("persistent".to_string(), self.persistent.to_snake_case());
        m.insert("distance".to_string(), self.distance.to_snake_case());
        m
    }
}
impl Value for SpruceLeavesData {
    fn value(&self) -> usize {
        (self.persistent.value() * 7usize) + (self.distance.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BirchLeavesData {
    distance: i32,
    persistent: bool,
}
impl BirchLeavesData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            distance: i32::from_snake_case(map.get("distance")?)?,
            persistent: bool::from_snake_case(map.get("persistent")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("distance".to_string(), self.distance.to_snake_case());
        m.insert("persistent".to_string(), self.persistent.to_snake_case());
        m
    }
}
impl Value for BirchLeavesData {
    fn value(&self) -> usize {
        (self.distance.value() * 2usize) + (self.persistent.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct JungleLeavesData {
    distance: i32,
    persistent: bool,
}
impl JungleLeavesData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            distance: i32::from_snake_case(map.get("distance")?)?,
            persistent: bool::from_snake_case(map.get("persistent")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("distance".to_string(), self.distance.to_snake_case());
        m.insert("persistent".to_string(), self.persistent.to_snake_case());
        m
    }
}
impl Value for JungleLeavesData {
    fn value(&self) -> usize {
        (self.distance.value() * 2usize) + (self.persistent.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AcaciaLeavesData {
    persistent: bool,
    distance: i32,
}
impl AcaciaLeavesData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            persistent: bool::from_snake_case(map.get("persistent")?)?,
            distance: i32::from_snake_case(map.get("distance")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("persistent".to_string(), self.persistent.to_snake_case());
        m.insert("distance".to_string(), self.distance.to_snake_case());
        m
    }
}
impl Value for AcaciaLeavesData {
    fn value(&self) -> usize {
        (self.persistent.value() * 7usize) + (self.distance.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DarkOakLeavesData {
    distance: i32,
    persistent: bool,
}
impl DarkOakLeavesData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            distance: i32::from_snake_case(map.get("distance")?)?,
            persistent: bool::from_snake_case(map.get("persistent")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("distance".to_string(), self.distance.to_snake_case());
        m.insert("persistent".to_string(), self.persistent.to_snake_case());
        m
    }
}
impl Value for DarkOakLeavesData {
    fn value(&self) -> usize {
        (self.distance.value() * 2usize) + (self.persistent.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DispenserData {
    triggered: bool,
    facing: Facing,
}
impl DispenserData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            triggered: bool::from_snake_case(map.get("triggered")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("triggered".to_string(), self.triggered.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for DispenserData {
    fn value(&self) -> usize {
        (self.triggered.value() * 6usize) + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct NoteBlockData {
    note: i32,
    powered: bool,
    instrument: NoteBlockInstrument,
}
impl NoteBlockData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            note: i32::from_snake_case(map.get("note")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            instrument: NoteBlockInstrument::from_snake_case(map.get("instrument")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("note".to_string(), self.note.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("instrument".to_string(), self.instrument.to_snake_case());
        m
    }
}
impl Value for NoteBlockData {
    fn value(&self) -> usize {
        (self.note.value() * 20usize)
            + (self.powered.value() * 10usize)
            + (self.instrument.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct WhiteBedData {
    facing: Facing,
    part: Part,
    occupied: bool,
}
impl WhiteBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            part: Part::from_snake_case(map.get("part")?)?,
            occupied: bool::from_snake_case(map.get("occupied")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("part".to_string(), self.part.to_snake_case());
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m
    }
}
impl Value for WhiteBedData {
    fn value(&self) -> usize {
        (self.facing.value() * 4usize)
            + (self.part.value() * 2usize)
            + (self.occupied.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OrangeBedData {
    facing: Facing,
    occupied: bool,
    part: Part,
}
impl OrangeBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            occupied: bool::from_snake_case(map.get("occupied")?)?,
            part: Part::from_snake_case(map.get("part")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m.insert("part".to_string(), self.part.to_snake_case());
        m
    }
}
impl Value for OrangeBedData {
    fn value(&self) -> usize {
        (self.facing.value() * 4usize)
            + (self.occupied.value() * 2usize)
            + (self.part.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct MagentaBedData {
    facing: Facing,
    occupied: bool,
    part: Part,
}
impl MagentaBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            occupied: bool::from_snake_case(map.get("occupied")?)?,
            part: Part::from_snake_case(map.get("part")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m.insert("part".to_string(), self.part.to_snake_case());
        m
    }
}
impl Value for MagentaBedData {
    fn value(&self) -> usize {
        (self.facing.value() * 4usize)
            + (self.occupied.value() * 2usize)
            + (self.part.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LightBlueBedData {
    occupied: bool,
    facing: Facing,
    part: Part,
}
impl LightBlueBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            occupied: bool::from_snake_case(map.get("occupied")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            part: Part::from_snake_case(map.get("part")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("part".to_string(), self.part.to_snake_case());
        m
    }
}
impl Value for LightBlueBedData {
    fn value(&self) -> usize {
        (self.occupied.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.part.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct YellowBedData {
    occupied: bool,
    part: Part,
    facing: Facing,
}
impl YellowBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            occupied: bool::from_snake_case(map.get("occupied")?)?,
            part: Part::from_snake_case(map.get("part")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m.insert("part".to_string(), self.part.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for YellowBedData {
    fn value(&self) -> usize {
        (self.occupied.value() * 8usize)
            + (self.part.value() * 4usize)
            + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LimeBedData {
    occupied: bool,
    part: Part,
    facing: Facing,
}
impl LimeBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            occupied: bool::from_snake_case(map.get("occupied")?)?,
            part: Part::from_snake_case(map.get("part")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m.insert("part".to_string(), self.part.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for LimeBedData {
    fn value(&self) -> usize {
        (self.occupied.value() * 8usize)
            + (self.part.value() * 4usize)
            + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PinkBedData {
    facing: Facing,
    part: Part,
    occupied: bool,
}
impl PinkBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            part: Part::from_snake_case(map.get("part")?)?,
            occupied: bool::from_snake_case(map.get("occupied")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("part".to_string(), self.part.to_snake_case());
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m
    }
}
impl Value for PinkBedData {
    fn value(&self) -> usize {
        (self.facing.value() * 4usize)
            + (self.part.value() * 2usize)
            + (self.occupied.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct GrayBedData {
    occupied: bool,
    part: Part,
    facing: Facing,
}
impl GrayBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            occupied: bool::from_snake_case(map.get("occupied")?)?,
            part: Part::from_snake_case(map.get("part")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m.insert("part".to_string(), self.part.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for GrayBedData {
    fn value(&self) -> usize {
        (self.occupied.value() * 8usize)
            + (self.part.value() * 4usize)
            + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LightGrayBedData {
    occupied: bool,
    part: Part,
    facing: Facing,
}
impl LightGrayBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            occupied: bool::from_snake_case(map.get("occupied")?)?,
            part: Part::from_snake_case(map.get("part")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m.insert("part".to_string(), self.part.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for LightGrayBedData {
    fn value(&self) -> usize {
        (self.occupied.value() * 8usize)
            + (self.part.value() * 4usize)
            + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CyanBedData {
    occupied: bool,
    part: Part,
    facing: Facing,
}
impl CyanBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            occupied: bool::from_snake_case(map.get("occupied")?)?,
            part: Part::from_snake_case(map.get("part")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m.insert("part".to_string(), self.part.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for CyanBedData {
    fn value(&self) -> usize {
        (self.occupied.value() * 8usize)
            + (self.part.value() * 4usize)
            + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PurpleBedData {
    facing: Facing,
    occupied: bool,
    part: Part,
}
impl PurpleBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            occupied: bool::from_snake_case(map.get("occupied")?)?,
            part: Part::from_snake_case(map.get("part")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m.insert("part".to_string(), self.part.to_snake_case());
        m
    }
}
impl Value for PurpleBedData {
    fn value(&self) -> usize {
        (self.facing.value() * 4usize)
            + (self.occupied.value() * 2usize)
            + (self.part.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BlueBedData {
    facing: Facing,
    occupied: bool,
    part: Part,
}
impl BlueBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            occupied: bool::from_snake_case(map.get("occupied")?)?,
            part: Part::from_snake_case(map.get("part")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m.insert("part".to_string(), self.part.to_snake_case());
        m
    }
}
impl Value for BlueBedData {
    fn value(&self) -> usize {
        (self.facing.value() * 4usize)
            + (self.occupied.value() * 2usize)
            + (self.part.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BrownBedData {
    facing: Facing,
    occupied: bool,
    part: Part,
}
impl BrownBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            occupied: bool::from_snake_case(map.get("occupied")?)?,
            part: Part::from_snake_case(map.get("part")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m.insert("part".to_string(), self.part.to_snake_case());
        m
    }
}
impl Value for BrownBedData {
    fn value(&self) -> usize {
        (self.facing.value() * 4usize)
            + (self.occupied.value() * 2usize)
            + (self.part.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct GreenBedData {
    facing: Facing,
    part: Part,
    occupied: bool,
}
impl GreenBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            part: Part::from_snake_case(map.get("part")?)?,
            occupied: bool::from_snake_case(map.get("occupied")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("part".to_string(), self.part.to_snake_case());
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m
    }
}
impl Value for GreenBedData {
    fn value(&self) -> usize {
        (self.facing.value() * 4usize)
            + (self.part.value() * 2usize)
            + (self.occupied.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RedBedData {
    occupied: bool,
    facing: Facing,
    part: Part,
}
impl RedBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            occupied: bool::from_snake_case(map.get("occupied")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            part: Part::from_snake_case(map.get("part")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("part".to_string(), self.part.to_snake_case());
        m
    }
}
impl Value for RedBedData {
    fn value(&self) -> usize {
        (self.occupied.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.part.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BlackBedData {
    occupied: bool,
    part: Part,
    facing: Facing,
}
impl BlackBedData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            occupied: bool::from_snake_case(map.get("occupied")?)?,
            part: Part::from_snake_case(map.get("part")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("occupied".to_string(), self.occupied.to_snake_case());
        m.insert("part".to_string(), self.part.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for BlackBedData {
    fn value(&self) -> usize {
        (self.occupied.value() * 8usize)
            + (self.part.value() * 4usize)
            + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PoweredRailData {
    shape: Shape,
    powered: bool,
}
impl PoweredRailData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            shape: Shape::from_snake_case(map.get("shape")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for PoweredRailData {
    fn value(&self) -> usize {
        (self.shape.value() * 2usize) + (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DetectorRailData {
    powered: bool,
    shape: Shape,
}
impl DetectorRailData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
            shape: Shape::from_snake_case(map.get("shape")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m
    }
}
impl Value for DetectorRailData {
    fn value(&self) -> usize {
        (self.powered.value() * 6usize) + (self.shape.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StickyPistonData {
    extended: bool,
    facing: Facing,
}
impl StickyPistonData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            extended: bool::from_snake_case(map.get("extended")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("extended".to_string(), self.extended.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for StickyPistonData {
    fn value(&self) -> usize {
        (self.extended.value() * 6usize) + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct TallSeagrassData {
    half: Half,
}
impl TallSeagrassData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            half: Half::from_snake_case(map.get("half")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("half".to_string(), self.half.to_snake_case());
        m
    }
}
impl Value for TallSeagrassData {
    fn value(&self) -> usize {
        (self.half.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PistonData {
    extended: bool,
    facing: Facing,
}
impl PistonData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            extended: bool::from_snake_case(map.get("extended")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("extended".to_string(), self.extended.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for PistonData {
    fn value(&self) -> usize {
        (self.extended.value() * 6usize) + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PistonHeadData {
    ty: PistonHeadType,
    facing: Facing,
    short: bool,
}
impl PistonHeadData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            ty: PistonHeadType::from_snake_case(map.get("type")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            short: bool::from_snake_case(map.get("short")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("type".to_string(), self.ty.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("short".to_string(), self.short.to_snake_case());
        m
    }
}
impl Value for PistonHeadData {
    fn value(&self) -> usize {
        (self.ty.value() * 12usize) + (self.facing.value() * 2usize) + (self.short.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct MovingPistonData {
    ty: MovingPistonType,
    facing: Facing,
}
impl MovingPistonData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            ty: MovingPistonType::from_snake_case(map.get("type")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("type".to_string(), self.ty.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for MovingPistonData {
    fn value(&self) -> usize {
        (self.ty.value() * 6usize) + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct TntData {
    unstable: bool,
}
impl TntData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            unstable: bool::from_snake_case(map.get("unstable")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("unstable".to_string(), self.unstable.to_snake_case());
        m
    }
}
impl Value for TntData {
    fn value(&self) -> usize {
        (self.unstable.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct WallTorchData {
    facing: Facing,
}
impl WallTorchData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for WallTorchData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct FireData {
    west: bool,
    north: bool,
    up: bool,
    east: bool,
    age: i32,
    south: bool,
}
impl FireData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            west: bool::from_snake_case(map.get("west")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            up: bool::from_snake_case(map.get("up")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            age: i32::from_snake_case(map.get("age")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("up".to_string(), self.up.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("age".to_string(), self.age.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m
    }
}
impl Value for FireData {
    fn value(&self) -> usize {
        (self.west.value() * 256usize)
            + (self.north.value() * 128usize)
            + (self.up.value() * 64usize)
            + (self.east.value() * 32usize)
            + (self.age.value() * 2usize)
            + (self.south.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OakStairsData {
    waterlogged: bool,
    shape: Shape,
    facing: Facing,
    half: Half,
}
impl OakStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            shape: Shape::from_snake_case(map.get("shape")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m
    }
}
impl Value for OakStairsData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 40usize)
            + (self.shape.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.half.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ChestData {
    ty: ChestType,
    waterlogged: bool,
    facing: Facing,
}
impl ChestData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            ty: ChestType::from_snake_case(map.get("type")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("type".to_string(), self.ty.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for ChestData {
    fn value(&self) -> usize {
        (self.ty.value() * 8usize)
            + (self.waterlogged.value() * 4usize)
            + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RedstoneWireData {
    power: i32,
    east: Facing,
    north: Facing,
    south: Facing,
    west: Facing,
}
impl RedstoneWireData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            power: i32::from_snake_case(map.get("power")?)?,
            east: Facing::from_snake_case(map.get("east")?)?,
            north: Facing::from_snake_case(map.get("north")?)?,
            south: Facing::from_snake_case(map.get("south")?)?,
            west: Facing::from_snake_case(map.get("west")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("power".to_string(), self.power.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m
    }
}
impl Value for RedstoneWireData {
    fn value(&self) -> usize {
        (self.power.value() * 81usize)
            + (self.east.value() * 27usize)
            + (self.north.value() * 9usize)
            + (self.south.value() * 3usize)
            + (self.west.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct WheatData {
    age: i32,
}
impl WheatData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            age: i32::from_snake_case(map.get("age")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("age".to_string(), self.age.to_snake_case());
        m
    }
}
impl Value for WheatData {
    fn value(&self) -> usize {
        (self.age.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct FarmlandData {
    moisture: i32,
}
impl FarmlandData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            moisture: i32::from_snake_case(map.get("moisture")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("moisture".to_string(), self.moisture.to_snake_case());
        m
    }
}
impl Value for FarmlandData {
    fn value(&self) -> usize {
        (self.moisture.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct FurnaceData {
    lit: bool,
    facing: Facing,
}
impl FurnaceData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            lit: bool::from_snake_case(map.get("lit")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("lit".to_string(), self.lit.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for FurnaceData {
    fn value(&self) -> usize {
        (self.lit.value() * 4usize) + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SignData {
    rotation: i32,
    waterlogged: bool,
}
impl SignData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for SignData {
    fn value(&self) -> usize {
        (self.rotation.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OakDoorData {
    powered: bool,
    half: Half,
    open: bool,
    hinge: Hinge,
    facing: Facing,
}
impl OakDoorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
            hinge: Hinge::from_snake_case(map.get("hinge")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("hinge".to_string(), self.hinge.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for OakDoorData {
    fn value(&self) -> usize {
        (self.powered.value() * 32usize)
            + (self.half.value() * 16usize)
            + (self.open.value() * 8usize)
            + (self.hinge.value() * 4usize)
            + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LadderData {
    facing: Facing,
    waterlogged: bool,
}
impl LadderData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for LadderData {
    fn value(&self) -> usize {
        (self.facing.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RailData {
    shape: Shape,
}
impl RailData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            shape: Shape::from_snake_case(map.get("shape")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m
    }
}
impl Value for RailData {
    fn value(&self) -> usize {
        (self.shape.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CobblestoneStairsData {
    facing: Facing,
    waterlogged: bool,
    half: Half,
    shape: Shape,
}
impl CobblestoneStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
            shape: Shape::from_snake_case(map.get("shape")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m
    }
}
impl Value for CobblestoneStairsData {
    fn value(&self) -> usize {
        (self.facing.value() * 20usize)
            + (self.waterlogged.value() * 10usize)
            + (self.half.value() * 5usize)
            + (self.shape.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct WallSignData {
    waterlogged: bool,
    facing: Facing,
}
impl WallSignData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for WallSignData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 4usize) + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LeverData {
    face: Face,
    facing: Facing,
    powered: bool,
}
impl LeverData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            face: Face::from_snake_case(map.get("face")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("face".to_string(), self.face.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for LeverData {
    fn value(&self) -> usize {
        (self.face.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StonePressurePlateData {
    powered: bool,
}
impl StonePressurePlateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for StonePressurePlateData {
    fn value(&self) -> usize {
        (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct IronDoorData {
    open: bool,
    facing: Facing,
    half: Half,
    powered: bool,
    hinge: Hinge,
}
impl IronDoorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            open: bool::from_snake_case(map.get("open")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            hinge: Hinge::from_snake_case(map.get("hinge")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("hinge".to_string(), self.hinge.to_snake_case());
        m
    }
}
impl Value for IronDoorData {
    fn value(&self) -> usize {
        (self.open.value() * 32usize)
            + (self.facing.value() * 8usize)
            + (self.half.value() * 4usize)
            + (self.powered.value() * 2usize)
            + (self.hinge.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OakPressurePlateData {
    powered: bool,
}
impl OakPressurePlateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for OakPressurePlateData {
    fn value(&self) -> usize {
        (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SprucePressurePlateData {
    powered: bool,
}
impl SprucePressurePlateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for SprucePressurePlateData {
    fn value(&self) -> usize {
        (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BirchPressurePlateData {
    powered: bool,
}
impl BirchPressurePlateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for BirchPressurePlateData {
    fn value(&self) -> usize {
        (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct JunglePressurePlateData {
    powered: bool,
}
impl JunglePressurePlateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for JunglePressurePlateData {
    fn value(&self) -> usize {
        (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AcaciaPressurePlateData {
    powered: bool,
}
impl AcaciaPressurePlateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for AcaciaPressurePlateData {
    fn value(&self) -> usize {
        (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DarkOakPressurePlateData {
    powered: bool,
}
impl DarkOakPressurePlateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for DarkOakPressurePlateData {
    fn value(&self) -> usize {
        (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RedstoneOreData {
    lit: bool,
}
impl RedstoneOreData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            lit: bool::from_snake_case(map.get("lit")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("lit".to_string(), self.lit.to_snake_case());
        m
    }
}
impl Value for RedstoneOreData {
    fn value(&self) -> usize {
        (self.lit.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RedstoneTorchData {
    lit: bool,
}
impl RedstoneTorchData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            lit: bool::from_snake_case(map.get("lit")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("lit".to_string(), self.lit.to_snake_case());
        m
    }
}
impl Value for RedstoneTorchData {
    fn value(&self) -> usize {
        (self.lit.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RedstoneWallTorchData {
    lit: bool,
    facing: Facing,
}
impl RedstoneWallTorchData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            lit: bool::from_snake_case(map.get("lit")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("lit".to_string(), self.lit.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for RedstoneWallTorchData {
    fn value(&self) -> usize {
        (self.lit.value() * 4usize) + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StoneButtonData {
    facing: Facing,
    powered: bool,
    face: Face,
}
impl StoneButtonData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            face: Face::from_snake_case(map.get("face")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("face".to_string(), self.face.to_snake_case());
        m
    }
}
impl Value for StoneButtonData {
    fn value(&self) -> usize {
        (self.facing.value() * 6usize)
            + (self.powered.value() * 3usize)
            + (self.face.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SnowData {
    layers: i32,
}
impl SnowData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            layers: i32::from_snake_case(map.get("layers")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("layers".to_string(), self.layers.to_snake_case());
        m
    }
}
impl Value for SnowData {
    fn value(&self) -> usize {
        (self.layers.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CactusData {
    age: i32,
}
impl CactusData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            age: i32::from_snake_case(map.get("age")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("age".to_string(), self.age.to_snake_case());
        m
    }
}
impl Value for CactusData {
    fn value(&self) -> usize {
        (self.age.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SugarCaneData {
    age: i32,
}
impl SugarCaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            age: i32::from_snake_case(map.get("age")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("age".to_string(), self.age.to_snake_case());
        m
    }
}
impl Value for SugarCaneData {
    fn value(&self) -> usize {
        (self.age.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct JukeboxData {
    has_record: bool,
}
impl JukeboxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            has_record: bool::from_snake_case(map.get("has_record")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("has_record".to_string(), self.has_record.to_snake_case());
        m
    }
}
impl Value for JukeboxData {
    fn value(&self) -> usize {
        (self.has_record.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OakFenceData {
    waterlogged: bool,
    east: bool,
    north: bool,
    south: bool,
    west: bool,
}
impl OakFenceData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m
    }
}
impl Value for OakFenceData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 16usize)
            + (self.east.value() * 8usize)
            + (self.north.value() * 4usize)
            + (self.south.value() * 2usize)
            + (self.west.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct NetherPortalData {
    axis: Axis,
}
impl NetherPortalData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for NetherPortalData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CarvedPumpkinData {
    facing: Facing,
}
impl CarvedPumpkinData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for CarvedPumpkinData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct JackOLanternData {
    facing: Facing,
}
impl JackOLanternData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for JackOLanternData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CakeData {
    bites: i32,
}
impl CakeData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            bites: i32::from_snake_case(map.get("bites")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("bites".to_string(), self.bites.to_snake_case());
        m
    }
}
impl Value for CakeData {
    fn value(&self) -> usize {
        (self.bites.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RepeaterData {
    delay: i32,
    facing: Facing,
    powered: bool,
    locked: bool,
}
impl RepeaterData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            delay: i32::from_snake_case(map.get("delay")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            locked: bool::from_snake_case(map.get("locked")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("delay".to_string(), self.delay.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("locked".to_string(), self.locked.to_snake_case());
        m
    }
}
impl Value for RepeaterData {
    fn value(&self) -> usize {
        (self.delay.value() * 16usize)
            + (self.facing.value() * 4usize)
            + (self.powered.value() * 2usize)
            + (self.locked.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OakTrapdoorData {
    facing: Facing,
    half: Half,
    open: bool,
    waterlogged: bool,
    powered: bool,
}
impl OakTrapdoorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for OakTrapdoorData {
    fn value(&self) -> usize {
        (self.facing.value() * 16usize)
            + (self.half.value() * 8usize)
            + (self.open.value() * 4usize)
            + (self.waterlogged.value() * 2usize)
            + (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SpruceTrapdoorData {
    half: Half,
    open: bool,
    powered: bool,
    waterlogged: bool,
    facing: Facing,
}
impl SpruceTrapdoorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            half: Half::from_snake_case(map.get("half")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for SpruceTrapdoorData {
    fn value(&self) -> usize {
        (self.half.value() * 32usize)
            + (self.open.value() * 16usize)
            + (self.powered.value() * 8usize)
            + (self.waterlogged.value() * 4usize)
            + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BirchTrapdoorData {
    half: Half,
    facing: Facing,
    waterlogged: bool,
    open: bool,
    powered: bool,
}
impl BirchTrapdoorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            half: Half::from_snake_case(map.get("half")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for BirchTrapdoorData {
    fn value(&self) -> usize {
        (self.half.value() * 32usize)
            + (self.facing.value() * 8usize)
            + (self.waterlogged.value() * 4usize)
            + (self.open.value() * 2usize)
            + (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct JungleTrapdoorData {
    powered: bool,
    open: bool,
    facing: Facing,
    half: Half,
    waterlogged: bool,
}
impl JungleTrapdoorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for JungleTrapdoorData {
    fn value(&self) -> usize {
        (self.powered.value() * 32usize)
            + (self.open.value() * 16usize)
            + (self.facing.value() * 4usize)
            + (self.half.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AcaciaTrapdoorData {
    waterlogged: bool,
    powered: bool,
    half: Half,
    facing: Facing,
    open: bool,
}
impl AcaciaTrapdoorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m
    }
}
impl Value for AcaciaTrapdoorData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 32usize)
            + (self.powered.value() * 16usize)
            + (self.half.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.open.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DarkOakTrapdoorData {
    open: bool,
    powered: bool,
    half: Half,
    facing: Facing,
    waterlogged: bool,
}
impl DarkOakTrapdoorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            open: bool::from_snake_case(map.get("open")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for DarkOakTrapdoorData {
    fn value(&self) -> usize {
        (self.open.value() * 32usize)
            + (self.powered.value() * 16usize)
            + (self.half.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BrownMushroomBlockData {
    east: bool,
    down: bool,
    up: bool,
    west: bool,
    south: bool,
    north: bool,
}
impl BrownMushroomBlockData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            east: bool::from_snake_case(map.get("east")?)?,
            down: bool::from_snake_case(map.get("down")?)?,
            up: bool::from_snake_case(map.get("up")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("down".to_string(), self.down.to_snake_case());
        m.insert("up".to_string(), self.up.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m
    }
}
impl Value for BrownMushroomBlockData {
    fn value(&self) -> usize {
        (self.east.value() * 32usize)
            + (self.down.value() * 16usize)
            + (self.up.value() * 8usize)
            + (self.west.value() * 4usize)
            + (self.south.value() * 2usize)
            + (self.north.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RedMushroomBlockData {
    up: bool,
    east: bool,
    north: bool,
    down: bool,
    south: bool,
    west: bool,
}
impl RedMushroomBlockData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            up: bool::from_snake_case(map.get("up")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            down: bool::from_snake_case(map.get("down")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("up".to_string(), self.up.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("down".to_string(), self.down.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m
    }
}
impl Value for RedMushroomBlockData {
    fn value(&self) -> usize {
        (self.up.value() * 32usize)
            + (self.east.value() * 16usize)
            + (self.north.value() * 8usize)
            + (self.down.value() * 4usize)
            + (self.south.value() * 2usize)
            + (self.west.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct MushroomStemData {
    down: bool,
    south: bool,
    east: bool,
    up: bool,
    west: bool,
    north: bool,
}
impl MushroomStemData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            down: bool::from_snake_case(map.get("down")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            up: bool::from_snake_case(map.get("up")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("down".to_string(), self.down.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("up".to_string(), self.up.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m
    }
}
impl Value for MushroomStemData {
    fn value(&self) -> usize {
        (self.down.value() * 32usize)
            + (self.south.value() * 16usize)
            + (self.east.value() * 8usize)
            + (self.up.value() * 4usize)
            + (self.west.value() * 2usize)
            + (self.north.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct IronBarsData {
    east: bool,
    waterlogged: bool,
    south: bool,
    north: bool,
    west: bool,
}
impl IronBarsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            east: bool::from_snake_case(map.get("east")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m
    }
}
impl Value for IronBarsData {
    fn value(&self) -> usize {
        (self.east.value() * 16usize)
            + (self.waterlogged.value() * 8usize)
            + (self.south.value() * 4usize)
            + (self.north.value() * 2usize)
            + (self.west.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct GlassPaneData {
    east: bool,
    west: bool,
    north: bool,
    south: bool,
    waterlogged: bool,
}
impl GlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            east: bool::from_snake_case(map.get("east")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for GlassPaneData {
    fn value(&self) -> usize {
        (self.east.value() * 16usize)
            + (self.west.value() * 8usize)
            + (self.north.value() * 4usize)
            + (self.south.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AttachedPumpkinStemData {
    facing: Facing,
}
impl AttachedPumpkinStemData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for AttachedPumpkinStemData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AttachedMelonStemData {
    facing: Facing,
}
impl AttachedMelonStemData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for AttachedMelonStemData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PumpkinStemData {
    age: i32,
}
impl PumpkinStemData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            age: i32::from_snake_case(map.get("age")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("age".to_string(), self.age.to_snake_case());
        m
    }
}
impl Value for PumpkinStemData {
    fn value(&self) -> usize {
        (self.age.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct MelonStemData {
    age: i32,
}
impl MelonStemData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            age: i32::from_snake_case(map.get("age")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("age".to_string(), self.age.to_snake_case());
        m
    }
}
impl Value for MelonStemData {
    fn value(&self) -> usize {
        (self.age.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct VineData {
    west: bool,
    east: bool,
    up: bool,
    north: bool,
    south: bool,
}
impl VineData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            west: bool::from_snake_case(map.get("west")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            up: bool::from_snake_case(map.get("up")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("up".to_string(), self.up.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m
    }
}
impl Value for VineData {
    fn value(&self) -> usize {
        (self.west.value() * 16usize)
            + (self.east.value() * 8usize)
            + (self.up.value() * 4usize)
            + (self.north.value() * 2usize)
            + (self.south.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OakFenceGateData {
    facing: Facing,
    in_wall: bool,
    open: bool,
    powered: bool,
}
impl OakFenceGateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            in_wall: bool::from_snake_case(map.get("in_wall")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("in_wall".to_string(), self.in_wall.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for OakFenceGateData {
    fn value(&self) -> usize {
        (self.facing.value() * 8usize)
            + (self.in_wall.value() * 4usize)
            + (self.open.value() * 2usize)
            + (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BrickStairsData {
    facing: Facing,
    waterlogged: bool,
    half: Half,
    shape: Shape,
}
impl BrickStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
            shape: Shape::from_snake_case(map.get("shape")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m
    }
}
impl Value for BrickStairsData {
    fn value(&self) -> usize {
        (self.facing.value() * 20usize)
            + (self.waterlogged.value() * 10usize)
            + (self.half.value() * 5usize)
            + (self.shape.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StoneBrickStairsData {
    half: Half,
    shape: Shape,
    facing: Facing,
    waterlogged: bool,
}
impl StoneBrickStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            half: Half::from_snake_case(map.get("half")?)?,
            shape: Shape::from_snake_case(map.get("shape")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for StoneBrickStairsData {
    fn value(&self) -> usize {
        (self.half.value() * 40usize)
            + (self.shape.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct MyceliumData {
    snowy: bool,
}
impl MyceliumData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            snowy: bool::from_snake_case(map.get("snowy")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("snowy".to_string(), self.snowy.to_snake_case());
        m
    }
}
impl Value for MyceliumData {
    fn value(&self) -> usize {
        (self.snowy.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct NetherBrickFenceData {
    west: bool,
    north: bool,
    east: bool,
    south: bool,
    waterlogged: bool,
}
impl NetherBrickFenceData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            west: bool::from_snake_case(map.get("west")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for NetherBrickFenceData {
    fn value(&self) -> usize {
        (self.west.value() * 16usize)
            + (self.north.value() * 8usize)
            + (self.east.value() * 4usize)
            + (self.south.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct NetherBrickStairsData {
    facing: Facing,
    half: Half,
    shape: Shape,
    waterlogged: bool,
}
impl NetherBrickStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
            shape: Shape::from_snake_case(map.get("shape")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for NetherBrickStairsData {
    fn value(&self) -> usize {
        (self.facing.value() * 20usize)
            + (self.half.value() * 10usize)
            + (self.shape.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct NetherWartData {
    age: i32,
}
impl NetherWartData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            age: i32::from_snake_case(map.get("age")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("age".to_string(), self.age.to_snake_case());
        m
    }
}
impl Value for NetherWartData {
    fn value(&self) -> usize {
        (self.age.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BrewingStandData {
    has_bottle_1: bool,
    has_bottle_2: bool,
    has_bottle_0: bool,
}
impl BrewingStandData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            has_bottle_1: bool::from_snake_case(map.get("has_bottle_1")?)?,
            has_bottle_2: bool::from_snake_case(map.get("has_bottle_2")?)?,
            has_bottle_0: bool::from_snake_case(map.get("has_bottle_0")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert(
            "has_bottle_1".to_string(),
            self.has_bottle_1.to_snake_case(),
        );
        m.insert(
            "has_bottle_2".to_string(),
            self.has_bottle_2.to_snake_case(),
        );
        m.insert(
            "has_bottle_0".to_string(),
            self.has_bottle_0.to_snake_case(),
        );
        m
    }
}
impl Value for BrewingStandData {
    fn value(&self) -> usize {
        (self.has_bottle_1.value() * 4usize)
            + (self.has_bottle_2.value() * 2usize)
            + (self.has_bottle_0.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CauldronData {
    level: i32,
}
impl CauldronData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            level: i32::from_snake_case(map.get("level")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("level".to_string(), self.level.to_snake_case());
        m
    }
}
impl Value for CauldronData {
    fn value(&self) -> usize {
        (self.level.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct EndPortalFrameData {
    eye: bool,
    facing: Facing,
}
impl EndPortalFrameData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            eye: bool::from_snake_case(map.get("eye")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("eye".to_string(), self.eye.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for EndPortalFrameData {
    fn value(&self) -> usize {
        (self.eye.value() * 4usize) + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RedstoneLampData {
    lit: bool,
}
impl RedstoneLampData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            lit: bool::from_snake_case(map.get("lit")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("lit".to_string(), self.lit.to_snake_case());
        m
    }
}
impl Value for RedstoneLampData {
    fn value(&self) -> usize {
        (self.lit.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CocoaData {
    facing: Facing,
    age: i32,
}
impl CocoaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            age: i32::from_snake_case(map.get("age")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("age".to_string(), self.age.to_snake_case());
        m
    }
}
impl Value for CocoaData {
    fn value(&self) -> usize {
        (self.facing.value() * 3usize) + (self.age.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SandstoneStairsData {
    facing: Facing,
    half: Half,
    waterlogged: bool,
    shape: Shape,
}
impl SandstoneStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            shape: Shape::from_snake_case(map.get("shape")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m
    }
}
impl Value for SandstoneStairsData {
    fn value(&self) -> usize {
        (self.facing.value() * 20usize)
            + (self.half.value() * 10usize)
            + (self.waterlogged.value() * 5usize)
            + (self.shape.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct EnderChestData {
    waterlogged: bool,
    facing: Facing,
}
impl EnderChestData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for EnderChestData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 4usize) + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct TripwireHookData {
    attached: bool,
    powered: bool,
    facing: Facing,
}
impl TripwireHookData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            attached: bool::from_snake_case(map.get("attached")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("attached".to_string(), self.attached.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for TripwireHookData {
    fn value(&self) -> usize {
        (self.attached.value() * 8usize)
            + (self.powered.value() * 4usize)
            + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct TripwireData {
    south: bool,
    west: bool,
    powered: bool,
    east: bool,
    attached: bool,
    north: bool,
    disarmed: bool,
}
impl TripwireData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            south: bool::from_snake_case(map.get("south")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            attached: bool::from_snake_case(map.get("attached")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            disarmed: bool::from_snake_case(map.get("disarmed")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("attached".to_string(), self.attached.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("disarmed".to_string(), self.disarmed.to_snake_case());
        m
    }
}
impl Value for TripwireData {
    fn value(&self) -> usize {
        (self.south.value() * 64usize)
            + (self.west.value() * 32usize)
            + (self.powered.value() * 16usize)
            + (self.east.value() * 8usize)
            + (self.attached.value() * 4usize)
            + (self.north.value() * 2usize)
            + (self.disarmed.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SpruceStairsData {
    waterlogged: bool,
    half: Half,
    facing: Facing,
    shape: Shape,
}
impl SpruceStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            shape: Shape::from_snake_case(map.get("shape")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m
    }
}
impl Value for SpruceStairsData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 40usize)
            + (self.half.value() * 20usize)
            + (self.facing.value() * 5usize)
            + (self.shape.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BirchStairsData {
    half: Half,
    facing: Facing,
    waterlogged: bool,
    shape: Shape,
}
impl BirchStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            half: Half::from_snake_case(map.get("half")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            shape: Shape::from_snake_case(map.get("shape")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m
    }
}
impl Value for BirchStairsData {
    fn value(&self) -> usize {
        (self.half.value() * 40usize)
            + (self.facing.value() * 10usize)
            + (self.waterlogged.value() * 5usize)
            + (self.shape.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct JungleStairsData {
    waterlogged: bool,
    half: Half,
    facing: Facing,
    shape: Shape,
}
impl JungleStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            shape: Shape::from_snake_case(map.get("shape")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m
    }
}
impl Value for JungleStairsData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 40usize)
            + (self.half.value() * 20usize)
            + (self.facing.value() * 5usize)
            + (self.shape.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CommandBlockData {
    conditional: bool,
    facing: Facing,
}
impl CommandBlockData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            conditional: bool::from_snake_case(map.get("conditional")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("conditional".to_string(), self.conditional.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for CommandBlockData {
    fn value(&self) -> usize {
        (self.conditional.value() * 6usize) + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CobblestoneWallData {
    west: bool,
    up: bool,
    east: bool,
    south: bool,
    waterlogged: bool,
    north: bool,
}
impl CobblestoneWallData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            west: bool::from_snake_case(map.get("west")?)?,
            up: bool::from_snake_case(map.get("up")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("up".to_string(), self.up.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m
    }
}
impl Value for CobblestoneWallData {
    fn value(&self) -> usize {
        (self.west.value() * 32usize)
            + (self.up.value() * 16usize)
            + (self.east.value() * 8usize)
            + (self.south.value() * 4usize)
            + (self.waterlogged.value() * 2usize)
            + (self.north.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct MossyCobblestoneWallData {
    up: bool,
    west: bool,
    north: bool,
    east: bool,
    south: bool,
    waterlogged: bool,
}
impl MossyCobblestoneWallData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            up: bool::from_snake_case(map.get("up")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("up".to_string(), self.up.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for MossyCobblestoneWallData {
    fn value(&self) -> usize {
        (self.up.value() * 32usize)
            + (self.west.value() * 16usize)
            + (self.north.value() * 8usize)
            + (self.east.value() * 4usize)
            + (self.south.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CarrotsData {
    age: i32,
}
impl CarrotsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            age: i32::from_snake_case(map.get("age")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("age".to_string(), self.age.to_snake_case());
        m
    }
}
impl Value for CarrotsData {
    fn value(&self) -> usize {
        (self.age.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PotatoesData {
    age: i32,
}
impl PotatoesData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            age: i32::from_snake_case(map.get("age")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("age".to_string(), self.age.to_snake_case());
        m
    }
}
impl Value for PotatoesData {
    fn value(&self) -> usize {
        (self.age.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OakButtonData {
    powered: bool,
    facing: Facing,
    face: Face,
}
impl OakButtonData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            face: Face::from_snake_case(map.get("face")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("face".to_string(), self.face.to_snake_case());
        m
    }
}
impl Value for OakButtonData {
    fn value(&self) -> usize {
        (self.powered.value() * 12usize)
            + (self.facing.value() * 3usize)
            + (self.face.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SpruceButtonData {
    facing: Facing,
    face: Face,
    powered: bool,
}
impl SpruceButtonData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            face: Face::from_snake_case(map.get("face")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("face".to_string(), self.face.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for SpruceButtonData {
    fn value(&self) -> usize {
        (self.facing.value() * 6usize)
            + (self.face.value() * 2usize)
            + (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BirchButtonData {
    face: Face,
    facing: Facing,
    powered: bool,
}
impl BirchButtonData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            face: Face::from_snake_case(map.get("face")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("face".to_string(), self.face.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for BirchButtonData {
    fn value(&self) -> usize {
        (self.face.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct JungleButtonData {
    powered: bool,
    face: Face,
    facing: Facing,
}
impl JungleButtonData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
            face: Face::from_snake_case(map.get("face")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("face".to_string(), self.face.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for JungleButtonData {
    fn value(&self) -> usize {
        (self.powered.value() * 12usize)
            + (self.face.value() * 4usize)
            + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AcaciaButtonData {
    face: Face,
    facing: Facing,
    powered: bool,
}
impl AcaciaButtonData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            face: Face::from_snake_case(map.get("face")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("face".to_string(), self.face.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for AcaciaButtonData {
    fn value(&self) -> usize {
        (self.face.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DarkOakButtonData {
    facing: Facing,
    face: Face,
    powered: bool,
}
impl DarkOakButtonData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            face: Face::from_snake_case(map.get("face")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("face".to_string(), self.face.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for DarkOakButtonData {
    fn value(&self) -> usize {
        (self.facing.value() * 6usize)
            + (self.face.value() * 2usize)
            + (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SkeletonWallSkullData {
    facing: Facing,
}
impl SkeletonWallSkullData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for SkeletonWallSkullData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SkeletonSkullData {
    rotation: i32,
}
impl SkeletonSkullData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for SkeletonSkullData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct WitherSkeletonWallSkullData {
    facing: Facing,
}
impl WitherSkeletonWallSkullData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for WitherSkeletonWallSkullData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct WitherSkeletonSkullData {
    rotation: i32,
}
impl WitherSkeletonSkullData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for WitherSkeletonSkullData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ZombieWallHeadData {
    facing: Facing,
}
impl ZombieWallHeadData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for ZombieWallHeadData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ZombieHeadData {
    rotation: i32,
}
impl ZombieHeadData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for ZombieHeadData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PlayerWallHeadData {
    facing: Facing,
}
impl PlayerWallHeadData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for PlayerWallHeadData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PlayerHeadData {
    rotation: i32,
}
impl PlayerHeadData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for PlayerHeadData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CreeperWallHeadData {
    facing: Facing,
}
impl CreeperWallHeadData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for CreeperWallHeadData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CreeperHeadData {
    rotation: i32,
}
impl CreeperHeadData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for CreeperHeadData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DragonWallHeadData {
    facing: Facing,
}
impl DragonWallHeadData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for DragonWallHeadData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DragonHeadData {
    rotation: i32,
}
impl DragonHeadData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for DragonHeadData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AnvilData {
    facing: Facing,
}
impl AnvilData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for AnvilData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ChippedAnvilData {
    facing: Facing,
}
impl ChippedAnvilData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for ChippedAnvilData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DamagedAnvilData {
    facing: Facing,
}
impl DamagedAnvilData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for DamagedAnvilData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct TrappedChestData {
    facing: Facing,
    ty: TrappedChestType,
    waterlogged: bool,
}
impl TrappedChestData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            ty: TrappedChestType::from_snake_case(map.get("type")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("type".to_string(), self.ty.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for TrappedChestData {
    fn value(&self) -> usize {
        (self.facing.value() * 6usize)
            + (self.ty.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LightWeightedPressurePlateData {
    power: i32,
}
impl LightWeightedPressurePlateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            power: i32::from_snake_case(map.get("power")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("power".to_string(), self.power.to_snake_case());
        m
    }
}
impl Value for LightWeightedPressurePlateData {
    fn value(&self) -> usize {
        (self.power.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct HeavyWeightedPressurePlateData {
    power: i32,
}
impl HeavyWeightedPressurePlateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            power: i32::from_snake_case(map.get("power")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("power".to_string(), self.power.to_snake_case());
        m
    }
}
impl Value for HeavyWeightedPressurePlateData {
    fn value(&self) -> usize {
        (self.power.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ComparatorData {
    mode: ComparatorMode,
    powered: bool,
    facing: Facing,
}
impl ComparatorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            mode: ComparatorMode::from_snake_case(map.get("mode")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("mode".to_string(), self.mode.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for ComparatorData {
    fn value(&self) -> usize {
        (self.mode.value() * 8usize)
            + (self.powered.value() * 4usize)
            + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DaylightDetectorData {
    inverted: bool,
    power: i32,
}
impl DaylightDetectorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            inverted: bool::from_snake_case(map.get("inverted")?)?,
            power: i32::from_snake_case(map.get("power")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("inverted".to_string(), self.inverted.to_snake_case());
        m.insert("power".to_string(), self.power.to_snake_case());
        m
    }
}
impl Value for DaylightDetectorData {
    fn value(&self) -> usize {
        (self.inverted.value() * 16usize) + (self.power.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct HopperData {
    enabled: bool,
    facing: Facing,
}
impl HopperData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            enabled: bool::from_snake_case(map.get("enabled")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("enabled".to_string(), self.enabled.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for HopperData {
    fn value(&self) -> usize {
        (self.enabled.value() * 5usize) + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct QuartzPillarData {
    axis: Axis,
}
impl QuartzPillarData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for QuartzPillarData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct QuartzStairsData {
    facing: Facing,
    shape: Shape,
    waterlogged: bool,
    half: Half,
}
impl QuartzStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            shape: Shape::from_snake_case(map.get("shape")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m
    }
}
impl Value for QuartzStairsData {
    fn value(&self) -> usize {
        (self.facing.value() * 20usize)
            + (self.shape.value() * 4usize)
            + (self.waterlogged.value() * 2usize)
            + (self.half.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ActivatorRailData {
    shape: Shape,
    powered: bool,
}
impl ActivatorRailData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            shape: Shape::from_snake_case(map.get("shape")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for ActivatorRailData {
    fn value(&self) -> usize {
        (self.shape.value() * 2usize) + (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DropperData {
    triggered: bool,
    facing: Facing,
}
impl DropperData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            triggered: bool::from_snake_case(map.get("triggered")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("triggered".to_string(), self.triggered.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for DropperData {
    fn value(&self) -> usize {
        (self.triggered.value() * 6usize) + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct WhiteStainedGlassPaneData {
    east: bool,
    west: bool,
    waterlogged: bool,
    north: bool,
    south: bool,
}
impl WhiteStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            east: bool::from_snake_case(map.get("east")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m
    }
}
impl Value for WhiteStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.east.value() * 16usize)
            + (self.west.value() * 8usize)
            + (self.waterlogged.value() * 4usize)
            + (self.north.value() * 2usize)
            + (self.south.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OrangeStainedGlassPaneData {
    north: bool,
    south: bool,
    west: bool,
    waterlogged: bool,
    east: bool,
}
impl OrangeStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            north: bool::from_snake_case(map.get("north")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m
    }
}
impl Value for OrangeStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.north.value() * 16usize)
            + (self.south.value() * 8usize)
            + (self.west.value() * 4usize)
            + (self.waterlogged.value() * 2usize)
            + (self.east.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct MagentaStainedGlassPaneData {
    east: bool,
    west: bool,
    north: bool,
    waterlogged: bool,
    south: bool,
}
impl MagentaStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            east: bool::from_snake_case(map.get("east")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m
    }
}
impl Value for MagentaStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.east.value() * 16usize)
            + (self.west.value() * 8usize)
            + (self.north.value() * 4usize)
            + (self.waterlogged.value() * 2usize)
            + (self.south.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LightBlueStainedGlassPaneData {
    east: bool,
    waterlogged: bool,
    west: bool,
    north: bool,
    south: bool,
}
impl LightBlueStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            east: bool::from_snake_case(map.get("east")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m
    }
}
impl Value for LightBlueStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.east.value() * 16usize)
            + (self.waterlogged.value() * 8usize)
            + (self.west.value() * 4usize)
            + (self.north.value() * 2usize)
            + (self.south.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct YellowStainedGlassPaneData {
    north: bool,
    south: bool,
    waterlogged: bool,
    west: bool,
    east: bool,
}
impl YellowStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            north: bool::from_snake_case(map.get("north")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m
    }
}
impl Value for YellowStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.north.value() * 16usize)
            + (self.south.value() * 8usize)
            + (self.waterlogged.value() * 4usize)
            + (self.west.value() * 2usize)
            + (self.east.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LimeStainedGlassPaneData {
    south: bool,
    east: bool,
    north: bool,
    west: bool,
    waterlogged: bool,
}
impl LimeStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            south: bool::from_snake_case(map.get("south")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for LimeStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.south.value() * 16usize)
            + (self.east.value() * 8usize)
            + (self.north.value() * 4usize)
            + (self.west.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PinkStainedGlassPaneData {
    west: bool,
    north: bool,
    south: bool,
    east: bool,
    waterlogged: bool,
}
impl PinkStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            west: bool::from_snake_case(map.get("west")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for PinkStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.west.value() * 16usize)
            + (self.north.value() * 8usize)
            + (self.south.value() * 4usize)
            + (self.east.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct GrayStainedGlassPaneData {
    west: bool,
    north: bool,
    east: bool,
    south: bool,
    waterlogged: bool,
}
impl GrayStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            west: bool::from_snake_case(map.get("west")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for GrayStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.west.value() * 16usize)
            + (self.north.value() * 8usize)
            + (self.east.value() * 4usize)
            + (self.south.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LightGrayStainedGlassPaneData {
    east: bool,
    south: bool,
    west: bool,
    waterlogged: bool,
    north: bool,
}
impl LightGrayStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            east: bool::from_snake_case(map.get("east")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m
    }
}
impl Value for LightGrayStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.east.value() * 16usize)
            + (self.south.value() * 8usize)
            + (self.west.value() * 4usize)
            + (self.waterlogged.value() * 2usize)
            + (self.north.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CyanStainedGlassPaneData {
    south: bool,
    east: bool,
    west: bool,
    waterlogged: bool,
    north: bool,
}
impl CyanStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            south: bool::from_snake_case(map.get("south")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m
    }
}
impl Value for CyanStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.south.value() * 16usize)
            + (self.east.value() * 8usize)
            + (self.west.value() * 4usize)
            + (self.waterlogged.value() * 2usize)
            + (self.north.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PurpleStainedGlassPaneData {
    west: bool,
    waterlogged: bool,
    east: bool,
    south: bool,
    north: bool,
}
impl PurpleStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            west: bool::from_snake_case(map.get("west")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m
    }
}
impl Value for PurpleStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.west.value() * 16usize)
            + (self.waterlogged.value() * 8usize)
            + (self.east.value() * 4usize)
            + (self.south.value() * 2usize)
            + (self.north.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BlueStainedGlassPaneData {
    east: bool,
    north: bool,
    west: bool,
    waterlogged: bool,
    south: bool,
}
impl BlueStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            east: bool::from_snake_case(map.get("east")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m
    }
}
impl Value for BlueStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.east.value() * 16usize)
            + (self.north.value() * 8usize)
            + (self.west.value() * 4usize)
            + (self.waterlogged.value() * 2usize)
            + (self.south.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BrownStainedGlassPaneData {
    north: bool,
    south: bool,
    east: bool,
    waterlogged: bool,
    west: bool,
}
impl BrownStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            north: bool::from_snake_case(map.get("north")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m
    }
}
impl Value for BrownStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.north.value() * 16usize)
            + (self.south.value() * 8usize)
            + (self.east.value() * 4usize)
            + (self.waterlogged.value() * 2usize)
            + (self.west.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct GreenStainedGlassPaneData {
    north: bool,
    east: bool,
    waterlogged: bool,
    west: bool,
    south: bool,
}
impl GreenStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            north: bool::from_snake_case(map.get("north")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m
    }
}
impl Value for GreenStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.north.value() * 16usize)
            + (self.east.value() * 8usize)
            + (self.waterlogged.value() * 4usize)
            + (self.west.value() * 2usize)
            + (self.south.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RedStainedGlassPaneData {
    north: bool,
    west: bool,
    east: bool,
    south: bool,
    waterlogged: bool,
}
impl RedStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            north: bool::from_snake_case(map.get("north")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for RedStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.north.value() * 16usize)
            + (self.west.value() * 8usize)
            + (self.east.value() * 4usize)
            + (self.south.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BlackStainedGlassPaneData {
    south: bool,
    north: bool,
    east: bool,
    west: bool,
    waterlogged: bool,
}
impl BlackStainedGlassPaneData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            south: bool::from_snake_case(map.get("south")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for BlackStainedGlassPaneData {
    fn value(&self) -> usize {
        (self.south.value() * 16usize)
            + (self.north.value() * 8usize)
            + (self.east.value() * 4usize)
            + (self.west.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AcaciaStairsData {
    waterlogged: bool,
    half: Half,
    facing: Facing,
    shape: Shape,
}
impl AcaciaStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            shape: Shape::from_snake_case(map.get("shape")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m
    }
}
impl Value for AcaciaStairsData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 40usize)
            + (self.half.value() * 20usize)
            + (self.facing.value() * 5usize)
            + (self.shape.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DarkOakStairsData {
    half: Half,
    waterlogged: bool,
    shape: Shape,
    facing: Facing,
}
impl DarkOakStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            half: Half::from_snake_case(map.get("half")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            shape: Shape::from_snake_case(map.get("shape")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for DarkOakStairsData {
    fn value(&self) -> usize {
        (self.half.value() * 40usize)
            + (self.waterlogged.value() * 20usize)
            + (self.shape.value() * 4usize)
            + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct IronTrapdoorData {
    powered: bool,
    half: Half,
    facing: Facing,
    waterlogged: bool,
    open: bool,
}
impl IronTrapdoorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            powered: bool::from_snake_case(map.get("powered")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m
    }
}
impl Value for IronTrapdoorData {
    fn value(&self) -> usize {
        (self.powered.value() * 32usize)
            + (self.half.value() * 16usize)
            + (self.facing.value() * 4usize)
            + (self.waterlogged.value() * 2usize)
            + (self.open.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PrismarineStairsData {
    waterlogged: bool,
    facing: Facing,
    shape: Shape,
    half: Half,
}
impl PrismarineStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            shape: Shape::from_snake_case(map.get("shape")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m
    }
}
impl Value for PrismarineStairsData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 40usize)
            + (self.facing.value() * 10usize)
            + (self.shape.value() * 2usize)
            + (self.half.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PrismarineBrickStairsData {
    shape: Shape,
    facing: Facing,
    half: Half,
    waterlogged: bool,
}
impl PrismarineBrickStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            shape: Shape::from_snake_case(map.get("shape")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for PrismarineBrickStairsData {
    fn value(&self) -> usize {
        (self.shape.value() * 16usize)
            + (self.facing.value() * 4usize)
            + (self.half.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DarkPrismarineStairsData {
    half: Half,
    shape: Shape,
    facing: Facing,
    waterlogged: bool,
}
impl DarkPrismarineStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            half: Half::from_snake_case(map.get("half")?)?,
            shape: Shape::from_snake_case(map.get("shape")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for DarkPrismarineStairsData {
    fn value(&self) -> usize {
        (self.half.value() * 40usize)
            + (self.shape.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PrismarineSlabData {
    waterlogged: bool,
    ty: Half,
}
impl PrismarineSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            ty: Half::from_snake_case(map.get("type")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("type".to_string(), self.ty.to_snake_case());
        m
    }
}
impl Value for PrismarineSlabData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 3usize) + (self.ty.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PrismarineBrickSlabData {
    ty: Half,
    waterlogged: bool,
}
impl PrismarineBrickSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            ty: Half::from_snake_case(map.get("type")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("type".to_string(), self.ty.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for PrismarineBrickSlabData {
    fn value(&self) -> usize {
        (self.ty.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DarkPrismarineSlabData {
    waterlogged: bool,
    ty: Half,
}
impl DarkPrismarineSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            ty: Half::from_snake_case(map.get("type")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("type".to_string(), self.ty.to_snake_case());
        m
    }
}
impl Value for DarkPrismarineSlabData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 3usize) + (self.ty.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct HayBlockData {
    axis: Axis,
}
impl HayBlockData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for HayBlockData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SunflowerData {
    half: Half,
}
impl SunflowerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            half: Half::from_snake_case(map.get("half")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("half".to_string(), self.half.to_snake_case());
        m
    }
}
impl Value for SunflowerData {
    fn value(&self) -> usize {
        (self.half.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LilacData {
    half: Half,
}
impl LilacData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            half: Half::from_snake_case(map.get("half")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("half".to_string(), self.half.to_snake_case());
        m
    }
}
impl Value for LilacData {
    fn value(&self) -> usize {
        (self.half.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RoseBushData {
    half: Half,
}
impl RoseBushData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            half: Half::from_snake_case(map.get("half")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("half".to_string(), self.half.to_snake_case());
        m
    }
}
impl Value for RoseBushData {
    fn value(&self) -> usize {
        (self.half.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PeonyData {
    half: Half,
}
impl PeonyData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            half: Half::from_snake_case(map.get("half")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("half".to_string(), self.half.to_snake_case());
        m
    }
}
impl Value for PeonyData {
    fn value(&self) -> usize {
        (self.half.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct TallGrassData {
    half: Half,
}
impl TallGrassData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            half: Half::from_snake_case(map.get("half")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("half".to_string(), self.half.to_snake_case());
        m
    }
}
impl Value for TallGrassData {
    fn value(&self) -> usize {
        (self.half.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LargeFernData {
    half: Half,
}
impl LargeFernData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            half: Half::from_snake_case(map.get("half")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("half".to_string(), self.half.to_snake_case());
        m
    }
}
impl Value for LargeFernData {
    fn value(&self) -> usize {
        (self.half.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct WhiteBannerData {
    rotation: i32,
}
impl WhiteBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for WhiteBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OrangeBannerData {
    rotation: i32,
}
impl OrangeBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for OrangeBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct MagentaBannerData {
    rotation: i32,
}
impl MagentaBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for MagentaBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LightBlueBannerData {
    rotation: i32,
}
impl LightBlueBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for LightBlueBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct YellowBannerData {
    rotation: i32,
}
impl YellowBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for YellowBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LimeBannerData {
    rotation: i32,
}
impl LimeBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for LimeBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PinkBannerData {
    rotation: i32,
}
impl PinkBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for PinkBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct GrayBannerData {
    rotation: i32,
}
impl GrayBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for GrayBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LightGrayBannerData {
    rotation: i32,
}
impl LightGrayBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for LightGrayBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CyanBannerData {
    rotation: i32,
}
impl CyanBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for CyanBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PurpleBannerData {
    rotation: i32,
}
impl PurpleBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for PurpleBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BlueBannerData {
    rotation: i32,
}
impl BlueBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for BlueBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BrownBannerData {
    rotation: i32,
}
impl BrownBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for BrownBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct GreenBannerData {
    rotation: i32,
}
impl GreenBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for GreenBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RedBannerData {
    rotation: i32,
}
impl RedBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for RedBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BlackBannerData {
    rotation: i32,
}
impl BlackBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            rotation: i32::from_snake_case(map.get("rotation")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("rotation".to_string(), self.rotation.to_snake_case());
        m
    }
}
impl Value for BlackBannerData {
    fn value(&self) -> usize {
        (self.rotation.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct WhiteWallBannerData {
    facing: Facing,
}
impl WhiteWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for WhiteWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OrangeWallBannerData {
    facing: Facing,
}
impl OrangeWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for OrangeWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct MagentaWallBannerData {
    facing: Facing,
}
impl MagentaWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for MagentaWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LightBlueWallBannerData {
    facing: Facing,
}
impl LightBlueWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for LightBlueWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct YellowWallBannerData {
    facing: Facing,
}
impl YellowWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for YellowWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LimeWallBannerData {
    facing: Facing,
}
impl LimeWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for LimeWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PinkWallBannerData {
    facing: Facing,
}
impl PinkWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for PinkWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct GrayWallBannerData {
    facing: Facing,
}
impl GrayWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for GrayWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LightGrayWallBannerData {
    facing: Facing,
}
impl LightGrayWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for LightGrayWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CyanWallBannerData {
    facing: Facing,
}
impl CyanWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for CyanWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PurpleWallBannerData {
    facing: Facing,
}
impl PurpleWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for PurpleWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BlueWallBannerData {
    facing: Facing,
}
impl BlueWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for BlueWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BrownWallBannerData {
    facing: Facing,
}
impl BrownWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for BrownWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct GreenWallBannerData {
    facing: Facing,
}
impl GreenWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for GreenWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RedWallBannerData {
    facing: Facing,
}
impl RedWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for RedWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BlackWallBannerData {
    facing: Facing,
}
impl BlackWallBannerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for BlackWallBannerData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RedSandstoneStairsData {
    facing: Facing,
    half: Half,
    shape: Shape,
    waterlogged: bool,
}
impl RedSandstoneStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
            shape: Shape::from_snake_case(map.get("shape")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for RedSandstoneStairsData {
    fn value(&self) -> usize {
        (self.facing.value() * 20usize)
            + (self.half.value() * 10usize)
            + (self.shape.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OakSlabData {
    waterlogged: bool,
    ty: Half,
}
impl OakSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            ty: Half::from_snake_case(map.get("type")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("type".to_string(), self.ty.to_snake_case());
        m
    }
}
impl Value for OakSlabData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 3usize) + (self.ty.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SpruceSlabData {
    waterlogged: bool,
    ty: Half,
}
impl SpruceSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            ty: Half::from_snake_case(map.get("type")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("type".to_string(), self.ty.to_snake_case());
        m
    }
}
impl Value for SpruceSlabData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 3usize) + (self.ty.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BirchSlabData {
    waterlogged: bool,
    ty: Half,
}
impl BirchSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            ty: Half::from_snake_case(map.get("type")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("type".to_string(), self.ty.to_snake_case());
        m
    }
}
impl Value for BirchSlabData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 3usize) + (self.ty.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct JungleSlabData {
    waterlogged: bool,
    ty: Half,
}
impl JungleSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            ty: Half::from_snake_case(map.get("type")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("type".to_string(), self.ty.to_snake_case());
        m
    }
}
impl Value for JungleSlabData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 3usize) + (self.ty.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AcaciaSlabData {
    waterlogged: bool,
    ty: Half,
}
impl AcaciaSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            ty: Half::from_snake_case(map.get("type")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("type".to_string(), self.ty.to_snake_case());
        m
    }
}
impl Value for AcaciaSlabData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 3usize) + (self.ty.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DarkOakSlabData {
    waterlogged: bool,
    ty: Half,
}
impl DarkOakSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            ty: Half::from_snake_case(map.get("type")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("type".to_string(), self.ty.to_snake_case());
        m
    }
}
impl Value for DarkOakSlabData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 3usize) + (self.ty.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StoneSlabData {
    ty: Half,
    waterlogged: bool,
}
impl StoneSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            ty: Half::from_snake_case(map.get("type")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("type".to_string(), self.ty.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for StoneSlabData {
    fn value(&self) -> usize {
        (self.ty.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SandstoneSlabData {
    ty: Half,
    waterlogged: bool,
}
impl SandstoneSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            ty: Half::from_snake_case(map.get("type")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("type".to_string(), self.ty.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for SandstoneSlabData {
    fn value(&self) -> usize {
        (self.ty.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PetrifiedOakSlabData {
    ty: Half,
    waterlogged: bool,
}
impl PetrifiedOakSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            ty: Half::from_snake_case(map.get("type")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("type".to_string(), self.ty.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for PetrifiedOakSlabData {
    fn value(&self) -> usize {
        (self.ty.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CobblestoneSlabData {
    waterlogged: bool,
    ty: Half,
}
impl CobblestoneSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            ty: Half::from_snake_case(map.get("type")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("type".to_string(), self.ty.to_snake_case());
        m
    }
}
impl Value for CobblestoneSlabData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 3usize) + (self.ty.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BrickSlabData {
    waterlogged: bool,
    ty: Half,
}
impl BrickSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            ty: Half::from_snake_case(map.get("type")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("type".to_string(), self.ty.to_snake_case());
        m
    }
}
impl Value for BrickSlabData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 3usize) + (self.ty.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StoneBrickSlabData {
    ty: Half,
    waterlogged: bool,
}
impl StoneBrickSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            ty: Half::from_snake_case(map.get("type")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("type".to_string(), self.ty.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for StoneBrickSlabData {
    fn value(&self) -> usize {
        (self.ty.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct NetherBrickSlabData {
    ty: Half,
    waterlogged: bool,
}
impl NetherBrickSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            ty: Half::from_snake_case(map.get("type")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("type".to_string(), self.ty.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for NetherBrickSlabData {
    fn value(&self) -> usize {
        (self.ty.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct QuartzSlabData {
    waterlogged: bool,
    ty: Half,
}
impl QuartzSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            ty: Half::from_snake_case(map.get("type")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("type".to_string(), self.ty.to_snake_case());
        m
    }
}
impl Value for QuartzSlabData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 3usize) + (self.ty.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RedSandstoneSlabData {
    ty: Half,
    waterlogged: bool,
}
impl RedSandstoneSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            ty: Half::from_snake_case(map.get("type")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("type".to_string(), self.ty.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for RedSandstoneSlabData {
    fn value(&self) -> usize {
        (self.ty.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PurpurSlabData {
    ty: Half,
    waterlogged: bool,
}
impl PurpurSlabData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            ty: Half::from_snake_case(map.get("type")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("type".to_string(), self.ty.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for PurpurSlabData {
    fn value(&self) -> usize {
        (self.ty.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SpruceFenceGateData {
    facing: Facing,
    open: bool,
    powered: bool,
    in_wall: bool,
}
impl SpruceFenceGateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            in_wall: bool::from_snake_case(map.get("in_wall")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("in_wall".to_string(), self.in_wall.to_snake_case());
        m
    }
}
impl Value for SpruceFenceGateData {
    fn value(&self) -> usize {
        (self.facing.value() * 8usize)
            + (self.open.value() * 4usize)
            + (self.powered.value() * 2usize)
            + (self.in_wall.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BirchFenceGateData {
    open: bool,
    powered: bool,
    in_wall: bool,
    facing: Facing,
}
impl BirchFenceGateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            open: bool::from_snake_case(map.get("open")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            in_wall: bool::from_snake_case(map.get("in_wall")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("in_wall".to_string(), self.in_wall.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for BirchFenceGateData {
    fn value(&self) -> usize {
        (self.open.value() * 16usize)
            + (self.powered.value() * 8usize)
            + (self.in_wall.value() * 4usize)
            + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct JungleFenceGateData {
    open: bool,
    in_wall: bool,
    powered: bool,
    facing: Facing,
}
impl JungleFenceGateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            open: bool::from_snake_case(map.get("open")?)?,
            in_wall: bool::from_snake_case(map.get("in_wall")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("in_wall".to_string(), self.in_wall.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for JungleFenceGateData {
    fn value(&self) -> usize {
        (self.open.value() * 16usize)
            + (self.in_wall.value() * 8usize)
            + (self.powered.value() * 4usize)
            + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AcaciaFenceGateData {
    facing: Facing,
    in_wall: bool,
    open: bool,
    powered: bool,
}
impl AcaciaFenceGateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            in_wall: bool::from_snake_case(map.get("in_wall")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("in_wall".to_string(), self.in_wall.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for AcaciaFenceGateData {
    fn value(&self) -> usize {
        (self.facing.value() * 8usize)
            + (self.in_wall.value() * 4usize)
            + (self.open.value() * 2usize)
            + (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DarkOakFenceGateData {
    facing: Facing,
    powered: bool,
    open: bool,
    in_wall: bool,
}
impl DarkOakFenceGateData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
            in_wall: bool::from_snake_case(map.get("in_wall")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("in_wall".to_string(), self.in_wall.to_snake_case());
        m
    }
}
impl Value for DarkOakFenceGateData {
    fn value(&self) -> usize {
        (self.facing.value() * 8usize)
            + (self.powered.value() * 4usize)
            + (self.open.value() * 2usize)
            + (self.in_wall.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SpruceFenceData {
    south: bool,
    north: bool,
    east: bool,
    west: bool,
    waterlogged: bool,
}
impl SpruceFenceData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            south: bool::from_snake_case(map.get("south")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for SpruceFenceData {
    fn value(&self) -> usize {
        (self.south.value() * 16usize)
            + (self.north.value() * 8usize)
            + (self.east.value() * 4usize)
            + (self.west.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BirchFenceData {
    west: bool,
    north: bool,
    waterlogged: bool,
    south: bool,
    east: bool,
}
impl BirchFenceData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            west: bool::from_snake_case(map.get("west")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m
    }
}
impl Value for BirchFenceData {
    fn value(&self) -> usize {
        (self.west.value() * 16usize)
            + (self.north.value() * 8usize)
            + (self.waterlogged.value() * 4usize)
            + (self.south.value() * 2usize)
            + (self.east.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct JungleFenceData {
    south: bool,
    north: bool,
    east: bool,
    waterlogged: bool,
    west: bool,
}
impl JungleFenceData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            south: bool::from_snake_case(map.get("south")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m
    }
}
impl Value for JungleFenceData {
    fn value(&self) -> usize {
        (self.south.value() * 16usize)
            + (self.north.value() * 8usize)
            + (self.east.value() * 4usize)
            + (self.waterlogged.value() * 2usize)
            + (self.west.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AcaciaFenceData {
    north: bool,
    west: bool,
    south: bool,
    east: bool,
    waterlogged: bool,
}
impl AcaciaFenceData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            north: bool::from_snake_case(map.get("north")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for AcaciaFenceData {
    fn value(&self) -> usize {
        (self.north.value() * 16usize)
            + (self.west.value() * 8usize)
            + (self.south.value() * 4usize)
            + (self.east.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DarkOakFenceData {
    west: bool,
    south: bool,
    east: bool,
    north: bool,
    waterlogged: bool,
}
impl DarkOakFenceData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            west: bool::from_snake_case(map.get("west")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            east: bool::from_snake_case(map.get("east")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for DarkOakFenceData {
    fn value(&self) -> usize {
        (self.west.value() * 16usize)
            + (self.south.value() * 8usize)
            + (self.east.value() * 4usize)
            + (self.north.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SpruceDoorData {
    open: bool,
    half: Half,
    hinge: Hinge,
    facing: Facing,
    powered: bool,
}
impl SpruceDoorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            open: bool::from_snake_case(map.get("open")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
            hinge: Hinge::from_snake_case(map.get("hinge")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("hinge".to_string(), self.hinge.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for SpruceDoorData {
    fn value(&self) -> usize {
        (self.open.value() * 32usize)
            + (self.half.value() * 16usize)
            + (self.hinge.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BirchDoorData {
    hinge: Hinge,
    open: bool,
    half: Half,
    powered: bool,
    facing: Facing,
}
impl BirchDoorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            hinge: Hinge::from_snake_case(map.get("hinge")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("hinge".to_string(), self.hinge.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for BirchDoorData {
    fn value(&self) -> usize {
        (self.hinge.value() * 32usize)
            + (self.open.value() * 16usize)
            + (self.half.value() * 8usize)
            + (self.powered.value() * 4usize)
            + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct JungleDoorData {
    hinge: Hinge,
    open: bool,
    half: Half,
    powered: bool,
    facing: Facing,
}
impl JungleDoorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            hinge: Hinge::from_snake_case(map.get("hinge")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("hinge".to_string(), self.hinge.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for JungleDoorData {
    fn value(&self) -> usize {
        (self.hinge.value() * 32usize)
            + (self.open.value() * 16usize)
            + (self.half.value() * 8usize)
            + (self.powered.value() * 4usize)
            + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AcaciaDoorData {
    open: bool,
    facing: Facing,
    hinge: Hinge,
    half: Half,
    powered: bool,
}
impl AcaciaDoorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            open: bool::from_snake_case(map.get("open")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            hinge: Hinge::from_snake_case(map.get("hinge")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("hinge".to_string(), self.hinge.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for AcaciaDoorData {
    fn value(&self) -> usize {
        (self.open.value() * 32usize)
            + (self.facing.value() * 8usize)
            + (self.hinge.value() * 4usize)
            + (self.half.value() * 2usize)
            + (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DarkOakDoorData {
    facing: Facing,
    hinge: Hinge,
    half: Half,
    open: bool,
    powered: bool,
}
impl DarkOakDoorData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            hinge: Hinge::from_snake_case(map.get("hinge")?)?,
            half: Half::from_snake_case(map.get("half")?)?,
            open: bool::from_snake_case(map.get("open")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("hinge".to_string(), self.hinge.to_snake_case());
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("open".to_string(), self.open.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for DarkOakDoorData {
    fn value(&self) -> usize {
        (self.facing.value() * 16usize)
            + (self.hinge.value() * 8usize)
            + (self.half.value() * 4usize)
            + (self.open.value() * 2usize)
            + (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct EndRodData {
    facing: Facing,
}
impl EndRodData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for EndRodData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ChorusPlantData {
    east: bool,
    north: bool,
    south: bool,
    down: bool,
    west: bool,
    up: bool,
}
impl ChorusPlantData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            east: bool::from_snake_case(map.get("east")?)?,
            north: bool::from_snake_case(map.get("north")?)?,
            south: bool::from_snake_case(map.get("south")?)?,
            down: bool::from_snake_case(map.get("down")?)?,
            west: bool::from_snake_case(map.get("west")?)?,
            up: bool::from_snake_case(map.get("up")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("east".to_string(), self.east.to_snake_case());
        m.insert("north".to_string(), self.north.to_snake_case());
        m.insert("south".to_string(), self.south.to_snake_case());
        m.insert("down".to_string(), self.down.to_snake_case());
        m.insert("west".to_string(), self.west.to_snake_case());
        m.insert("up".to_string(), self.up.to_snake_case());
        m
    }
}
impl Value for ChorusPlantData {
    fn value(&self) -> usize {
        (self.east.value() * 32usize)
            + (self.north.value() * 16usize)
            + (self.south.value() * 8usize)
            + (self.down.value() * 4usize)
            + (self.west.value() * 2usize)
            + (self.up.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ChorusFlowerData {
    age: i32,
}
impl ChorusFlowerData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            age: i32::from_snake_case(map.get("age")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("age".to_string(), self.age.to_snake_case());
        m
    }
}
impl Value for ChorusFlowerData {
    fn value(&self) -> usize {
        (self.age.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PurpurPillarData {
    axis: Axis,
}
impl PurpurPillarData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for PurpurPillarData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PurpurStairsData {
    half: Half,
    shape: Shape,
    facing: Facing,
    waterlogged: bool,
}
impl PurpurStairsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            half: Half::from_snake_case(map.get("half")?)?,
            shape: Shape::from_snake_case(map.get("shape")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("half".to_string(), self.half.to_snake_case());
        m.insert("shape".to_string(), self.shape.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for PurpurStairsData {
    fn value(&self) -> usize {
        (self.half.value() * 40usize)
            + (self.shape.value() * 8usize)
            + (self.facing.value() * 2usize)
            + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BeetrootsData {
    age: i32,
}
impl BeetrootsData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            age: i32::from_snake_case(map.get("age")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("age".to_string(), self.age.to_snake_case());
        m
    }
}
impl Value for BeetrootsData {
    fn value(&self) -> usize {
        (self.age.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RepeatingCommandBlockData {
    conditional: bool,
    facing: Facing,
}
impl RepeatingCommandBlockData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            conditional: bool::from_snake_case(map.get("conditional")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("conditional".to_string(), self.conditional.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for RepeatingCommandBlockData {
    fn value(&self) -> usize {
        (self.conditional.value() * 6usize) + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ChainCommandBlockData {
    conditional: bool,
    facing: Facing,
}
impl ChainCommandBlockData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            conditional: bool::from_snake_case(map.get("conditional")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("conditional".to_string(), self.conditional.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for ChainCommandBlockData {
    fn value(&self) -> usize {
        (self.conditional.value() * 6usize) + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct FrostedIceData {
    age: i32,
}
impl FrostedIceData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            age: i32::from_snake_case(map.get("age")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("age".to_string(), self.age.to_snake_case());
        m
    }
}
impl Value for FrostedIceData {
    fn value(&self) -> usize {
        (self.age.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BoneBlockData {
    axis: Axis,
}
impl BoneBlockData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            axis: Axis::from_snake_case(map.get("axis")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("axis".to_string(), self.axis.to_snake_case());
        m
    }
}
impl Value for BoneBlockData {
    fn value(&self) -> usize {
        (self.axis.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ObserverData {
    facing: Facing,
    powered: bool,
}
impl ObserverData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            powered: bool::from_snake_case(map.get("powered")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("powered".to_string(), self.powered.to_snake_case());
        m
    }
}
impl Value for ObserverData {
    fn value(&self) -> usize {
        (self.facing.value() * 2usize) + (self.powered.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ShulkerBoxData {
    facing: Facing,
}
impl ShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for ShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct WhiteShulkerBoxData {
    facing: Facing,
}
impl WhiteShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for WhiteShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OrangeShulkerBoxData {
    facing: Facing,
}
impl OrangeShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for OrangeShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct MagentaShulkerBoxData {
    facing: Facing,
}
impl MagentaShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for MagentaShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LightBlueShulkerBoxData {
    facing: Facing,
}
impl LightBlueShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for LightBlueShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct YellowShulkerBoxData {
    facing: Facing,
}
impl YellowShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for YellowShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LimeShulkerBoxData {
    facing: Facing,
}
impl LimeShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for LimeShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PinkShulkerBoxData {
    facing: Facing,
}
impl PinkShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for PinkShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct GrayShulkerBoxData {
    facing: Facing,
}
impl GrayShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for GrayShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LightGrayShulkerBoxData {
    facing: Facing,
}
impl LightGrayShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for LightGrayShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CyanShulkerBoxData {
    facing: Facing,
}
impl CyanShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for CyanShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PurpleShulkerBoxData {
    facing: Facing,
}
impl PurpleShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for PurpleShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BlueShulkerBoxData {
    facing: Facing,
}
impl BlueShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for BlueShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BrownShulkerBoxData {
    facing: Facing,
}
impl BrownShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for BrownShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct GreenShulkerBoxData {
    facing: Facing,
}
impl GreenShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for GreenShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RedShulkerBoxData {
    facing: Facing,
}
impl RedShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for RedShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BlackShulkerBoxData {
    facing: Facing,
}
impl BlackShulkerBoxData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for BlackShulkerBoxData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct WhiteGlazedTerracottaData {
    facing: Facing,
}
impl WhiteGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for WhiteGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct OrangeGlazedTerracottaData {
    facing: Facing,
}
impl OrangeGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for OrangeGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct MagentaGlazedTerracottaData {
    facing: Facing,
}
impl MagentaGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for MagentaGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LightBlueGlazedTerracottaData {
    facing: Facing,
}
impl LightBlueGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for LightBlueGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct YellowGlazedTerracottaData {
    facing: Facing,
}
impl YellowGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for YellowGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LimeGlazedTerracottaData {
    facing: Facing,
}
impl LimeGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for LimeGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PinkGlazedTerracottaData {
    facing: Facing,
}
impl PinkGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for PinkGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct GrayGlazedTerracottaData {
    facing: Facing,
}
impl GrayGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for GrayGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LightGrayGlazedTerracottaData {
    facing: Facing,
}
impl LightGrayGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for LightGrayGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CyanGlazedTerracottaData {
    facing: Facing,
}
impl CyanGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for CyanGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PurpleGlazedTerracottaData {
    facing: Facing,
}
impl PurpleGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for PurpleGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BlueGlazedTerracottaData {
    facing: Facing,
}
impl BlueGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for BlueGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BrownGlazedTerracottaData {
    facing: Facing,
}
impl BrownGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for BrownGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct GreenGlazedTerracottaData {
    facing: Facing,
}
impl GreenGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for GreenGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RedGlazedTerracottaData {
    facing: Facing,
}
impl RedGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for RedGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BlackGlazedTerracottaData {
    facing: Facing,
}
impl BlackGlazedTerracottaData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for BlackGlazedTerracottaData {
    fn value(&self) -> usize {
        (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct KelpData {
    age: i32,
}
impl KelpData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            age: i32::from_snake_case(map.get("age")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("age".to_string(), self.age.to_snake_case());
        m
    }
}
impl Value for KelpData {
    fn value(&self) -> usize {
        (self.age.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct TurtleEggData {
    hatch: i32,
    eggs: i32,
}
impl TurtleEggData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            hatch: i32::from_snake_case(map.get("hatch")?)?,
            eggs: i32::from_snake_case(map.get("eggs")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("hatch".to_string(), self.hatch.to_snake_case());
        m.insert("eggs".to_string(), self.eggs.to_snake_case());
        m
    }
}
impl Value for TurtleEggData {
    fn value(&self) -> usize {
        (self.hatch.value() * 4usize) + (self.eggs.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadTubeCoralData {
    waterlogged: bool,
}
impl DeadTubeCoralData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for DeadTubeCoralData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadBrainCoralData {
    waterlogged: bool,
}
impl DeadBrainCoralData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for DeadBrainCoralData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadBubbleCoralData {
    waterlogged: bool,
}
impl DeadBubbleCoralData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for DeadBubbleCoralData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadFireCoralData {
    waterlogged: bool,
}
impl DeadFireCoralData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for DeadFireCoralData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadHornCoralData {
    waterlogged: bool,
}
impl DeadHornCoralData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for DeadHornCoralData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct TubeCoralData {
    waterlogged: bool,
}
impl TubeCoralData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for TubeCoralData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BrainCoralData {
    waterlogged: bool,
}
impl BrainCoralData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for BrainCoralData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BubbleCoralData {
    waterlogged: bool,
}
impl BubbleCoralData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for BubbleCoralData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct FireCoralData {
    waterlogged: bool,
}
impl FireCoralData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for FireCoralData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct HornCoralData {
    waterlogged: bool,
}
impl HornCoralData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for HornCoralData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadTubeCoralWallFanData {
    facing: Facing,
    waterlogged: bool,
}
impl DeadTubeCoralWallFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for DeadTubeCoralWallFanData {
    fn value(&self) -> usize {
        (self.facing.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadBrainCoralWallFanData {
    facing: Facing,
    waterlogged: bool,
}
impl DeadBrainCoralWallFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for DeadBrainCoralWallFanData {
    fn value(&self) -> usize {
        (self.facing.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadBubbleCoralWallFanData {
    facing: Facing,
    waterlogged: bool,
}
impl DeadBubbleCoralWallFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for DeadBubbleCoralWallFanData {
    fn value(&self) -> usize {
        (self.facing.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadFireCoralWallFanData {
    waterlogged: bool,
    facing: Facing,
}
impl DeadFireCoralWallFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for DeadFireCoralWallFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 4usize) + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadHornCoralWallFanData {
    waterlogged: bool,
    facing: Facing,
}
impl DeadHornCoralWallFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for DeadHornCoralWallFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 4usize) + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct TubeCoralWallFanData {
    waterlogged: bool,
    facing: Facing,
}
impl TubeCoralWallFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for TubeCoralWallFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 4usize) + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BrainCoralWallFanData {
    waterlogged: bool,
    facing: Facing,
}
impl BrainCoralWallFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for BrainCoralWallFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 4usize) + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BubbleCoralWallFanData {
    waterlogged: bool,
    facing: Facing,
}
impl BubbleCoralWallFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for BubbleCoralWallFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 4usize) + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct FireCoralWallFanData {
    facing: Facing,
    waterlogged: bool,
}
impl FireCoralWallFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            facing: Facing::from_snake_case(map.get("facing")?)?,
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for FireCoralWallFanData {
    fn value(&self) -> usize {
        (self.facing.value() * 2usize) + (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct HornCoralWallFanData {
    waterlogged: bool,
    facing: Facing,
}
impl HornCoralWallFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            facing: Facing::from_snake_case(map.get("facing")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("facing".to_string(), self.facing.to_snake_case());
        m
    }
}
impl Value for HornCoralWallFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 4usize) + (self.facing.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadTubeCoralFanData {
    waterlogged: bool,
}
impl DeadTubeCoralFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for DeadTubeCoralFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadBrainCoralFanData {
    waterlogged: bool,
}
impl DeadBrainCoralFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for DeadBrainCoralFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadBubbleCoralFanData {
    waterlogged: bool,
}
impl DeadBubbleCoralFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for DeadBubbleCoralFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadFireCoralFanData {
    waterlogged: bool,
}
impl DeadFireCoralFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for DeadFireCoralFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct DeadHornCoralFanData {
    waterlogged: bool,
}
impl DeadHornCoralFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for DeadHornCoralFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct TubeCoralFanData {
    waterlogged: bool,
}
impl TubeCoralFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for TubeCoralFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BrainCoralFanData {
    waterlogged: bool,
}
impl BrainCoralFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for BrainCoralFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BubbleCoralFanData {
    waterlogged: bool,
}
impl BubbleCoralFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for BubbleCoralFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct FireCoralFanData {
    waterlogged: bool,
}
impl FireCoralFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for FireCoralFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct HornCoralFanData {
    waterlogged: bool,
}
impl HornCoralFanData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for HornCoralFanData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SeaPickleData {
    waterlogged: bool,
    pickles: i32,
}
impl SeaPickleData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
            pickles: i32::from_snake_case(map.get("pickles")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m.insert("pickles".to_string(), self.pickles.to_snake_case());
        m
    }
}
impl Value for SeaPickleData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 4usize) + (self.pickles.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ConduitData {
    waterlogged: bool,
}
impl ConduitData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            waterlogged: bool::from_snake_case(map.get("waterlogged")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("waterlogged".to_string(), self.waterlogged.to_snake_case());
        m
    }
}
impl Value for ConduitData {
    fn value(&self) -> usize {
        (self.waterlogged.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BubbleColumnData {
    drag: bool,
}
impl BubbleColumnData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            drag: bool::from_snake_case(map.get("drag")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("drag".to_string(), self.drag.to_snake_case());
        m
    }
}
impl Value for BubbleColumnData {
    fn value(&self) -> usize {
        (self.drag.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct StructureBlockData {
    mode: StructureBlockMode,
}
impl StructureBlockData {
    pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
        Some(Self {
            mode: StructureBlockMode::from_snake_case(map.get("mode")?)?,
        })
    }
    pub fn to_map(&self) -> HashMap<String, String> {
        let mut m = HashMap::new();
        m.insert("mode".to_string(), self.mode.to_snake_case());
        m
    }
}
impl Value for StructureBlockData {
    fn value(&self) -> usize {
        (self.mode.value() * 1usize)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase)]
pub enum NoteBlockInstrument {
    Harp,
    Basedrum,
    Snare,
    Hat,
    Bass,
    Flute,
    Bell,
    Guitar,
    Chime,
    Xylophone,
}
impl Value for NoteBlockInstrument {
    fn value(&self) -> usize {
        *self as usize
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase)]
pub enum PistonHeadType {
    Normal,
    Sticky,
}
impl Value for PistonHeadType {
    fn value(&self) -> usize {
        *self as usize
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase)]
pub enum MovingPistonType {
    Normal,
    Sticky,
}
impl Value for MovingPistonType {
    fn value(&self) -> usize {
        *self as usize
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase)]
pub enum ChestType {
    Single,
    Left,
    Right,
}
impl Value for ChestType {
    fn value(&self) -> usize {
        *self as usize
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase)]
pub enum TrappedChestType {
    Single,
    Left,
    Right,
}
impl Value for TrappedChestType {
    fn value(&self) -> usize {
        *self as usize
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase)]
pub enum ComparatorMode {
    Compare,
    Subtract,
}
impl Value for ComparatorMode {
    fn value(&self) -> usize {
        *self as usize
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase)]
pub enum StructureBlockMode {
    Save,
    Load,
    Corner,
    Data,
}
impl Value for StructureBlockMode {
    fn value(&self) -> usize {
        *self as usize
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase)]
pub enum Facing {
    North,
    South,
    East,
    West,
    Up,
    Down,
}
impl Value for Facing {
    fn value(&self) -> usize {
        *self as usize
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase)]
pub enum Axis {
    X,
    Y,
    Z,
}
impl Value for Axis {
    fn value(&self) -> usize {
        *self as usize
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase)]
pub enum Half {
    Upper,
    Lower,
    Top,
    Bottom,
}
impl Value for Half {
    fn value(&self) -> usize {
        *self as usize
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase)]
pub enum Face {
    Floor,
    Wall,
    Ceiling,
}
impl Value for Face {
    fn value(&self) -> usize {
        *self as usize
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase)]
pub enum Hinge {
    Left,
    Right,
}
impl Value for Hinge {
    fn value(&self) -> usize {
        *self as usize
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase)]
pub enum Shape {
    Straight,
    InnerLeft,
    InnerRight,
    OuterLeft,
    AscendingNorth,
    AscendingSouth,
    AscendingEast,
    AscendingWest,
    NorthEast,
    NorthWest,
    SouthEast,
    SouthWest,
    NorthSouth,
    EastWest,
}
impl Value for Shape {
    fn value(&self) -> usize {
        *self as usize
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase)]
pub enum Part {
    Head,
    Foot,
}
impl Value for Part {
    fn value(&self) -> usize {
        *self as usize
    }
}
