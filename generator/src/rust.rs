//! Yeah... don't even try reading this.
//! It's probably the messiest code I've ever
//! written - but at least it works.

use super::*;
use quote::ToTokens;
use std::process::Command;
use syn::LitInt;

pub fn generate_rust_code(input: &str, output: &str) -> Result<(), Error> {
    info!(
        "Writing Rust `Block` enum and data structs to {} using native input report {}",
        output, input,
    );

    let in_file = File::open(input)?;
    let mut out_file = File::create(output)?;

    info!("Parsing data file");
    let report: BlockReport = serde_json::from_reader(BufReader::new(&in_file))?;
    info!("Parsing successful");

    let mut enum_entries = vec![];
    //let mut name_fn_entries = vec![];
    //let mut from_name_and_props_fn_entries = vec![];
    let mut data_structs = vec![];
    let mut property_enums = vec![];

    let mut native_type_id_entries = vec![];

    info!("Generating code");

    for (count, (block_name, block)) in report.blocks.iter().enumerate() {
        generate_block_code(
            block,
            block_name,
            &mut property_enums,
            &mut data_structs,
            &mut enum_entries,
            &mut native_type_id_entries,
            count,
        );
    }

    let internal_id_data_offset_fn = generate_internal_id_data_offset_fn(&report);
    let internal_id_offsets = generate_internal_id_offsets(&report);
    let internal_state_id_fn = generate_internal_state_id_fn();
    let from_name_and_props_fn = generate_from_name_and_props_fn(&report);
    let from_name_and_default_props_fn = generate_from_and_default_props_fn(&report);
    let from_internal_state_id_fn = generate_from_internal_state_id_fn(&report);

    let block = quote! {
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
        pub enum Block {
            #(#enum_entries),*
        }

        impl Block {
            fn internal_type_id(&self) -> usize {
                match self {
                    #(#native_type_id_entries),*
                }
            }
            #internal_id_data_offset_fn
            #internal_state_id_fn
            #from_name_and_props_fn
            #from_name_and_default_props_fn
            #from_internal_state_id_fn
        }
    };

    let value = quote! {
        pub trait Value {
            fn value(&self) -> usize;
            fn from_value(val: usize) -> Option<Self>
                where Self: Sized;
        }

        impl Value for i32 {
            fn value(&self) -> usize {
                *self as usize
            }

            fn from_value(val: usize) -> Option<Self> {
                Some(val as i32)
            }
        }

        impl Value for bool {
            fn value(&self) -> usize {
                match *self {
                    true => 1,
                    false => 0,
                }
            }

            fn from_value(val: usize) -> Option<Self> {
                match val {
                    0 => Some(false),
                    1 => Some(true),
                    _ => None,
                }
            }
        }
    };

    let from_snake_case = quote! {
        pub trait FromSnakeCase {
            fn from_snake_case(val: &str) -> Option<Self>
                where Self: Sized;
        }

        impl FromSnakeCase for i32 {
            fn from_snake_case(val: &str) -> Option<Self> {
                use std::str::FromStr;
                match i32::from_str(val) {
                    Ok(x) => Some(x),
                    Err(_) => None,
                }
            }
        }

        impl FromSnakeCase for bool {
            fn from_snake_case(val: &str) -> Option<Self> {
                use std::str::FromStr;
                match bool::from_str(val) {
                    Ok(x) => Some(x),
                    Err(_) => None,
                }
            }
        }
    };

    let to_snake_case = quote! {
        pub trait ToSnakeCase {
            fn to_snake_case(&self) -> String;
        }

        impl ToSnakeCase for i32 {
            fn to_snake_case(&self) -> String {
                self.to_string()
            }
        }

        impl ToSnakeCase for bool {
            fn to_snake_case(&self) -> String {
                self.to_string()
            }
        }
    };

    let result = quote! {
        use feather_codegen::{ToSnakeCase, FromSnakeCase};
        use std::collections::HashMap;
        use num_traits::FromPrimitive;

        #internal_id_offsets

        #block
        #value
        #from_snake_case
        #to_snake_case
        #(#data_structs)*
        #(#property_enums)*
    };

    out_file.write_all(b"//! This file was generated by /generators/blocks\n")?;
    out_file.write_all(result.to_string().as_bytes())?;
    out_file.flush()?;

    info!("Successfully wrote code to {}", output);

    info!("Formatting code with rustfmt");

    run_rustfmt(output)?;

    info!("Success");

    Ok(())
}

fn run_rustfmt(file: &str) -> Result<(), Error> {
    Command::new("rustfmt").args(&[file]).output()?;

    Ok(())
}

fn generate_block_code(
    block: &Block,
    block_name: &str,
    property_enums: &mut Vec<TokenStream>,
    data_structs: &mut Vec<TokenStream>,
    enum_entries: &mut Vec<TokenStream>,
    native_type_id_entries: &mut Vec<TokenStream>,
    count: usize,
) {
    let variant_name = block_name[10..].to_camel_case();
    let variant_ident = Ident::new(&variant_name, Span::call_site());

    // If block has properties, we need to create a
    // data struct for the block and include it in the
    // enum variant.
    if block.properties.is_some() {
        create_block_data_struct(&variant_name, &block, property_enums, data_structs);
        let data_struct_ident = Ident::new(&format!("{}Data", variant_name), Span::call_site());
        enum_entries.push(quote! {
            #variant_ident(#data_struct_ident)
        });
        native_type_id_entries.push(quote! {
            Block::#variant_ident(_) => #count
        });
    } else {
        enum_entries.push(quote! {
            #variant_ident
        });

        native_type_id_entries.push(quote! {
            Block::#variant_ident => #count
        });
    }
}

fn create_block_data_struct(
    variant_name: &str,
    block: &Block,
    property_enums: &mut Vec<TokenStream>,
    data_structs: &mut Vec<TokenStream>,
) {
    let mut data_struct_entries = vec![];
    let mut from_map_entries = vec![];
    let mut to_map_entries = vec![];
    let mut default_impl_entries = vec![];

    let props = &block.properties.as_ref().unwrap();
    let states = &block.states;

    for (prop_name_str, possible_values) in &props.props {
        let ty = PropValueType::guess_from_value(&possible_values[0]);

        // If type is a custom enum, create the enum type
        if ty == PropValueType::Enum {
            create_property_enum(variant_name, prop_name_str, possible_values, property_enums);
        }

        let enum_name = format!("{}{}", variant_name, prop_name_str.to_camel_case());

        let ty_ident = Ident::new(
            match ty {
                PropValueType::Bool => "bool",
                PropValueType::I32 => "i32",
                PropValueType::Enum => &enum_name,
            },
            Span::call_site(),
        );

        let field_name = Ident::new(
            correct_variable_name(prop_name_str.as_str()),
            Span::call_site(),
        );

        let entry = quote! {
            pub #field_name: #ty_ident
        };
        data_struct_entries.push(entry);

        from_map_entries.push(quote! {
            #field_name: #ty_ident::from_snake_case(map.get(#prop_name_str)?)?
        });

        to_map_entries.push(quote! {
            m.insert(#prop_name_str.to_string(), self.#field_name.to_snake_case());
        });

        // Find default state and create an entry in the Default impl for it
        let default_state = states.iter().find(|state| state.default).unwrap();

        let default_value = {
            let value_str = &default_state.properties.as_ref().unwrap().props[prop_name_str];

            value_from_string(ty, variant_name, prop_name_str, value_str)
        };

        default_impl_entries.push(quote! {
            #field_name: #default_value,
        });
    }

    let data_ident = Ident::new(&format!("{}Data", variant_name), Span::call_site());

    let value_impl = generate_value_implementation(&data_ident, props, &variant_name);

    let data_struct = quote! {
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
        pub struct #data_ident {
            #(#data_struct_entries),*
        }

        impl #data_ident {
            pub fn from_map(map: &HashMap<String, String>) -> Option<Self> {
                Some(Self {
                    #(#from_map_entries),*
                })
            }

            pub fn to_map(&self) -> HashMap<String, String> {
                let mut m = HashMap::new();
                #(#to_map_entries)*
                m
            }
        }

        impl Default for #data_ident {
            fn default() -> Self {
                Self {
                    #(#default_impl_entries)*
                }
            }
        }

        #value_impl
    };

    data_structs.push(data_struct);
}

fn value_from_string(
    value_ty: PropValueType,
    variant_name: &str,
    prop_name: &str,
    value_str: &str,
) -> Box<dyn ToTokens> {
    match value_ty {
        PropValueType::I32 => Box::new(LitInt::new(value_str, Span::call_site())),
        PropValueType::Bool => Box::new(Ident::new(value_str, Span::call_site())),
        PropValueType::Enum => {
            let enum_ident = enum_ident(variant_name, prop_name);
            let value_ident = Ident::new(&value_str.to_camel_case(), Span::call_site());
            Box::new(quote! {
                #enum_ident::#value_ident
            })
        }
    }
}

fn enum_ident(variant_name: &str, prop_name: &str) -> Ident {
    Ident::new(
        &format!("{}{}", variant_name, prop_name.to_camel_case()),
        Span::call_site(),
    )
}

fn create_property_enum(
    variant_name: &str,
    prop_name: &str,
    possible_values: &[String],
    property_enums: &mut Vec<TokenStream>,
) {
    let enum_ident = enum_ident(variant_name, prop_name);

    let mut enum_variants = vec![];

    for possible_value_str in possible_values {
        let possible_value = Ident::new(
            possible_value_str.to_camel_case().as_str(),
            Span::call_site(),
        );
        enum_variants.push(quote! {
              #possible_value
        });
    }

    let en = quote! {
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ToSnakeCase, FromSnakeCase, FromPrimitive)]
        pub enum #enum_ident {
            #(#enum_variants),*
        }

        impl Value for #enum_ident {
            fn value(&self) -> usize {
                *self as usize
            }
            fn from_value(val: usize) -> Option<Self> {
                Self::from_usize(val)
            }
        }
    };

    property_enums.push(en);
}

pub fn correct_variable_name(name: &str) -> &str {
    match name {
        "type" => "ty",
        "in" => "_in",
        name => name,
    }
}

/// A property value type.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum PropValueType {
    Enum,
    I32,
    Bool,
}

impl PropValueType {
    pub fn guess_from_value(value: &str) -> Self {
        if i32::from_str(value).is_ok() {
            PropValueType::I32
        } else if bool::from_str(value).is_ok() {
            PropValueType::Bool
        } else {
            PropValueType::Enum // Custom enum
        }
    }
}

/// Generates a `Value` implementation for
/// a data struct.
///
/// This uses a special algorithm to generate
/// consecutive values in constant time.
fn generate_value_implementation(
    data_struct_ident: &Ident,
    props: &BlockProperties,
    variant_name: &str,
) -> TokenStream {
    use crate::util::{min_in_slice, slice_product};

    let mut terms = vec![];

    let possible_value_lens: Vec<usize> = props
        .props
        .iter()
        .map(|(_, possible_values)| possible_values.len())
        .collect();

    let total_permutations = slice_product(&possible_value_lens);

    for (count, (prop_name, vals)) in props.props.iter().enumerate() {
        let multiplier = if count == props.props.len() - 1 {
            // This is the last property - just multiply by 1.
            1
        } else {
            slice_product(&possible_value_lens[count + 1..])
        };

        // If the property is an integer and it starts at 1 rather
        // than 0, we need to subtract 1 for the function to work correctly.
        let mut should_subtract = false;
        let prop_type = PropValueType::guess_from_value(&vals[0]);
        if prop_type == PropValueType::I32 {
            let vals: Vec<i32> = vals.iter().map(|val| i32::from_str(val).unwrap()).collect();
            if min_in_slice(&vals) == 1 {
                should_subtract = true;
            }
            // TODO account for values which start at neither 0 nor 1 -
            // this hasn't been observed yet
            assert!(min_in_slice(&vals) <= 1);
        }

        let prop_field = Ident::new(correct_variable_name(prop_name.as_str()), Span::call_site());

        if should_subtract {
            terms.push(quote! {
                ((self.#prop_field.value() - 1) * #multiplier)
            });
        } else {
            terms.push(quote! {
                (self.#prop_field.value() * #multiplier)
            })
        }
    }

    // Calculate from_value function

    let mut variable_setters = vec![]; // e.g. "let facing = ..."
    let mut field_setters = vec![]; // e.g. "facing,"

    for (count, (prop_name, vals)) in props.props.iter().enumerate() {
        let prop_field = Ident::new(correct_variable_name(prop_name.as_str()), Span::call_site());
        let prop_stride = if count == props.props.len() - 1 {
            1
        } else {
            slice_product(&possible_value_lens[count + 1..])
        };

        let ty = PropValueType::guess_from_value(vals[0].as_str());
        let enum_name = format!("{}{}", variant_name, prop_name.to_camel_case());

        let ty_ident = Ident::new(
            match ty {
                PropValueType::Bool => "bool",
                PropValueType::I32 => "i32",
                PropValueType::Enum => &enum_name,
            },
            Span::call_site(),
        );

        // If the property is an integer and it starts at 1 rather
        // than 0, we need to subtract 1 for the function to work correctly.
        let mut should_subtract = false;
        let prop_type = PropValueType::guess_from_value(&vals[0]);
        if prop_type == PropValueType::I32 {
            let vals: Vec<i32> = vals.iter().map(|val| i32::from_str(val).unwrap()).collect();
            if min_in_slice(&vals) == 1 {
                should_subtract = true;
            }
            // TODO account for values which start at neither 0 nor 1 -
            // this hasn't been observed yet
            assert!(min_in_slice(&vals) <= 1);
        }

        let add: i32 = if should_subtract { 1 } else { 0 };
        let subtract: usize = if should_subtract { 1 } else { 0 };

        if should_subtract {
            variable_setters.push(quote! {
                let #prop_field = #ty_ident::from_value(val / #prop_stride).unwrap() + #add;
            });
        } else {
            variable_setters.push(quote! {
                let #prop_field = #ty_ident::from_value(val / #prop_stride).unwrap();
            });
        }

        variable_setters.push(quote! {
            val -= (#prop_field.value() - #subtract) * #prop_stride;
        });

        field_setters.push(quote! {
            #prop_field
        });
    }

    let result = quote! {
        impl Value for #data_struct_ident {
            fn value(&self) -> usize {
                #(#terms)+*
            }

            #[allow(warnings)]
            fn from_value(mut val: usize) -> Option<Self> {
                if val >= #total_permutations {
                    return None;
                }

                #(#variable_setters)*

                Some(Self {
                    #(#field_setters,)*
                })
            }
        }
    };

    result
}

/// Generates the function which retrieves the offset
/// from the block type's internal ID to the block state
/// internal ID.
fn generate_internal_id_data_offset_fn(report: &BlockReport) -> TokenStream {
    let mut match_arms = vec![];

    for (block_name, block) in &report.blocks {
        let ident = Ident::new(&block_name[10..].to_camel_case(), Span::call_site());
        match_arms.push(if block.properties.is_some() {
            quote! {
                Block::#ident(data) => data.value()
            }
        } else {
            quote! {
                Block::#ident => 0
            }
        });
    }

    let result = quote! {
        fn internal_id_data_offset(&self) -> usize {
            match self {
                #(#match_arms ,)*
            }
        }
    };
    result
}

/// Generates the global internal ID offsets array
/// which contains mappings from internal block type
/// IDs to their respective offsets.
/// To calculate the internal state ID of a block state,
/// add the block type ID offset from this from this array
/// to the internal_id_data_offset generated above.
fn generate_internal_id_offsets(report: &BlockReport) -> TokenStream {
    let mut entries = vec![];

    let mut count = 0usize;
    for (_, block) in &report.blocks {
        entries.push(quote! {
            #count
        });

        count += block.states.len();
    }

    let amnt = report.blocks.len();

    let result = quote! {
        const INTERNAL_ID_OFFSETS: [usize; #amnt] = [
            #(#entries ,)*
        ];
    };
    result
}

/// Generates the `internal_state_id` function.
fn generate_internal_state_id_fn() -> TokenStream {
    quote! {
        pub fn internal_state_id(&self) -> usize {
            let type_offset = INTERNAL_ID_OFFSETS[self.internal_type_id()];
            let data_offset = self.internal_id_data_offset();

            type_offset + data_offset
        }
    }
}

/// Generates the `from_internal_state_id` function.
fn generate_from_internal_state_id_fn(report: &BlockReport) -> TokenStream {
    let mut match_arms = vec![];

    let mut count = 0;
    for (block_name, block) in &report.blocks {
        let variant_name = block_name[10..].to_camel_case();
        let variant_ident = Ident::new(&variant_name, Span::call_site());

        if block.properties.is_some() {
            let range_start = count;
            let range_end = range_start + block.states.len() - 1;

            let data_struct_str = format!("{}Data", variant_name);
            let data_struct_ident = Ident::new(&data_struct_str, Span::call_site());

            match_arms.push(quote! {
                #range_start..=#range_end => {
                    let offset = id - #range_start;
                    let data = #data_struct_ident::from_value(offset)?;
                    Some(Block::#variant_ident(data))
                }
            });
        } else {
            match_arms.push(quote! {
                #count => {
                    Some(Block::#variant_ident)
                }
            });
        }

        count += block.states.len();
    }

    let result = quote! {
        pub fn from_internal_state_id(id: usize) -> Option<Self> {
            match id {
                #(#match_arms,)*
                _ => None,
            }
        }
    };
    result
}

/// Generates the `from_name_and_props` function.
fn generate_from_name_and_props_fn(report: &BlockReport) -> TokenStream {
    let mut match_arms = vec![];
    for (block_name, block) in &report.blocks {
        let variant_name = block_name[10..].to_camel_case();
        let variant_ident = Ident::new(&variant_name, Span::call_site());

        if block.properties.is_some() {
            let data_struct_str = format!("{}Data", variant_name);
            let data_struct_ident = Ident::new(&data_struct_str, Span::call_site());

            match_arms.push(quote! {
                #block_name => {
                    let data = #data_struct_ident::from_map(props)?;
                    Some(Block::#variant_ident(data))
                }
            });
        } else {
            match_arms.push(quote! {
                #block_name => Some(Block::#variant_ident)
            });
        }
    }

    let result = quote! {
        pub fn from_name_and_props(name: &str, props: &HashMap<String, String>) -> Option<Self> {
            match name {
                #(#match_arms ,)*
                _ => None,
            }
        }
    };
    result
}

/// Generates the `from_name_and_default_props` function.
fn generate_from_and_default_props_fn(report: &BlockReport) -> TokenStream {
    // More duplicate code than ever before!
    // This entire file should probably be rewritten at some point.
    let mut match_arms = vec![];

    for (block_name, block) in &report.blocks {
        let variant_name = block_name[10..].to_camel_case();
        let variant_ident = Ident::new(&variant_name, Span::call_site());

        if block.properties.is_some() {
            let data_struct_str = format!("{}Data", variant_name);
            let data_struct_ident = Ident::new(&data_struct_str, Span::call_site());

            match_arms.push(quote! {
                #block_name => {
                    let data = #data_struct_ident::default();
                    Some(Block::#variant_ident(data))
                }
            });
        } else {
            match_arms.push(quote! {
                #block_name => Some(Block::#variant_ident)
            });
        }
    }

    let result = quote! {
        pub fn from_name_and_default_props(name: &str) -> Option<Self> {
            match name {
                #(#match_arms ,)*
                _ => None,
            }
        }
    };
    result
}
