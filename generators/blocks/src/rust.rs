use super::*;
use std::process::Command;

pub fn generate_rust_code(input: &str, output: &str) -> Result<(), Error> {
    info!(
        "Writing Rust `Block` enum and data structs to {} using native input report {}",
        output, input,
    );

    let in_file = File::open(input)?;
    let mut out_file = File::create(output)?;

    info!("Parsing data file");
    let report: BlockReport = serde_json::from_reader(BufReader::new(&in_file))?;
    info!("Parsing successful");

    let mut enum_entries = vec![];
    //let mut name_fn_entries = vec![];
    //let mut from_name_and_props_fn_entries = vec![];
    let mut data_structs = vec![];
    let mut property_enums = vec![];

    info!("Generating code");

    for (block_name, block) in &report.blocks {
        generate_block_code(
            block,
            block_name,
            &mut property_enums,
            &mut data_structs,
            &mut enum_entries,
        );
    }

    let known_enums = generate_known_enums();

    let result = quote! {
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
        pub enum Block {
            #(#enum_entries),*
        }

        #(#data_structs)*
        #(#property_enums)*
        #known_enums
    };

    out_file.write(b"//! This file was generated by /generators/blocks\n")?;
    out_file.write(result.to_string().as_bytes())?;
    out_file.flush()?;

    info!("Successfully wrote code to {}", output);

    info!("Formatting code with rustfmt");

    run_rustfmt(output)?;

    info!("Success");

    Ok(())
}

fn run_rustfmt(file: &str) -> Result<(), Error> {
    Command::new("rustfmt").args(&[file]).output()?;

    Ok(())
}

fn generate_block_code(
    block: &Block,
    block_name: &String,
    property_enums: &mut Vec<TokenStream>,
    data_structs: &mut Vec<TokenStream>,
    enum_entries: &mut Vec<TokenStream>,
) {
    let variant_name = block_name[10..].to_camel_case();
    let variant_ident = Ident::new(&variant_name, Span::call_site());

    // If block has properties, we need to create a
    // data struct for the block and include it in the
    // enum variant.
    if let Some(props) = block.properties.clone() {
        create_block_data_struct(&variant_name, &props, property_enums, data_structs);
        let data_struct_ident = Ident::new(&format!("{}Data", variant_name), Span::call_site());
        enum_entries.push(quote! {
            #variant_ident(#data_struct_ident)
        });
    } else {
        enum_entries.push(quote! {
            #variant_ident
        })
    }
}

fn create_block_data_struct(
    variant_name: &str,
    props: &BlockProperties,
    property_enums: &mut Vec<TokenStream>,
    data_structs: &mut Vec<TokenStream>,
) {
    let mut data_struct_entries = vec![];

    for (prop_name, possible_values) in &props.props {
        let ty = PropValueType::guess_from_value(&possible_values[0]);

        // If type is a custom enum, create the enum type
        if ty == PropValueType::Enum {
            create_property_enum(variant_name, prop_name, possible_values, property_enums);
        }

        let enum_name = format!("{}{}", variant_name, prop_name.to_camel_case());

        let ty_ident = Ident::new(
            match ty {
                PropValueType::Bool => "bool",
                PropValueType::I32 => "i32",
                PropValueType::Part => "Part",
                PropValueType::Hinge => "Hinge",
                PropValueType::Shape => "Shape",
                PropValueType::Half => "Half",
                PropValueType::Axis => "Axis",
                PropValueType::Face => "Face",
                PropValueType::Facing => "Facing",
                PropValueType::Enum => &enum_name,
            },
            Span::call_site(),
        );

        let prop_name = Ident::new(correct_variable_name(prop_name.as_str()), Span::call_site());

        let entry = quote! {
            #prop_name: #ty_ident
        };
        data_struct_entries.push(entry);
    }

    let data_ident = Ident::new(&format!("{}Data", variant_name), Span::call_site());

    let data_struct = quote! {
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
        pub struct #data_ident {
            #(#data_struct_entries),*
        }
    };
    data_structs.push(data_struct);
}

fn create_property_enum(
    variant_name: &str,
    prop_name: &str,
    possible_values: &Vec<String>,
    property_enums: &mut Vec<TokenStream>,
) {
    let enum_ident = Ident::new(
        &format!("{}{}", variant_name, prop_name.to_camel_case()),
        Span::call_site(),
    );

    let mut enum_variants = vec![];
    for possible_value in possible_values {
        let possible_value = Ident::new(possible_value.to_camel_case().as_str(), Span::call_site());
        enum_variants.push(quote! {
              #possible_value
        });
    }

    let en = quote! {
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
        pub enum #enum_ident {
            #(#enum_variants),*
        }
    };

    property_enums.push(en);
}

fn correct_variable_name(name: &str) -> &str {
    match name {
        "type" => "ty",
        "in" => "_in",
        name => name,
    }
}

fn generate_known_enums() -> TokenStream {
    quote! {
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
        pub enum Facing {
            North,
            South,
            East,
            West,
            Up,
            Down,
        }

        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
        pub enum Axis {
            X,
            Y,
            Z,
        }

        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
        pub enum Half {
            Upper,
            Lower,
            Top,
            Bottom,
        }

        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
        pub enum Face {
            Floor,
            Wall,
            Ceiling,
        }

        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
        pub enum Shape {
            Straight,
            InnerLeft,
            InnerRight,
            OuterLeft,
            AscendingNorth,
            AscendingSouth,
            AscendingEast,
            AscendingWest,
            NorthEast,
            NorthWest,
            SouthEast,
            SouthWest,
            NorthSouth,
            EastWest,
        }

        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
        pub enum Hinge {
            Left,
            Right,
        }

        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
        pub enum Part {
            Head,
            Foot,
        }
    }
}

const FACING_VALUES: [&'static str; 6] = ["north", "south", "east", "west", "up", "down"];

const AXIS_VALUES: [&'static str; 3] = ["x", "y", "z"];

const HALF_VALUES: [&'static str; 4] = ["upper", "lower", "top", "bottom"];

const FACE_VALUES: [&'static str; 3] = ["floor", "wall", "ceiling"];

const SHAPE_VALUES: [&'static str; 14] = [
    "straight",
    "inner_left",
    "inner_right",
    "outer_left",
    "ascending_north",
    "ascending_south",
    "ascending_east",
    "ascending_west",
    "north_east",
    "north_west",
    "south_east",
    "south_west",
    "north_south",
    "east_west",
];

const HINGE_VALUES: [&'static str; 2] = ["left", "right"];

const PART_VALUES: [&'static str; 2] = ["head", "foot"];

/// A property value type.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
enum PropValueType {
    Facing,
    Axis,
    Half,
    Face,
    Shape,
    Hinge,
    Part,
    Enum,
    I32,
    Bool,
}

impl PropValueType {
    fn guess_from_value(value: &str) -> Self {
        if FACING_VALUES.contains(&value) {
            PropValueType::Facing
        } else if AXIS_VALUES.contains(&value) {
            PropValueType::Axis
        } else if HALF_VALUES.contains(&value) {
            PropValueType::Half
        } else if FACE_VALUES.contains(&value) {
            PropValueType::Face
        } else if SHAPE_VALUES.contains(&value) {
            PropValueType::Shape
        } else if HINGE_VALUES.contains(&value) {
            PropValueType::Hinge
        } else if PART_VALUES.contains(&value) {
            PropValueType::Part
        } else if i32::from_str(value).is_ok() {
            PropValueType::I32
        } else if bool::from_str(value).is_ok() {
            PropValueType::Bool
        } else {
            PropValueType::Enum // Custom enum
        }
    }
}
