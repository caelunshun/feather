//! This program is used to generate block state ID mappings
//! and corresponding Rust code. It reads from vanilla block.json
//! files. See `format.md` for more information.

#[macro_use]
extern crate serde_derive;
#[macro_use]
extern crate derive_deref;
#[macro_use]
extern crate clap;
#[macro_use]
extern crate log;

use byteorder::{LittleEndian, WriteBytesExt};
use clap::App;
use failure::Error;
use heck::CamelCase;
use proc_macro2::TokenStream;
use quote::quote;
use std::collections::HashMap;
use std::fs::File;
use std::io::{BufReader, BufWriter, Write};
use std::process::exit;
use std::str::FromStr;
use syn::export::Span;
use syn::Ident;

/// The block state ID to use when a block
/// in the native file was not found
/// in the input file. This would happen
/// when the input file is an older version
/// than the native version.
const DEFAULT_STATE_ID: u16 = 1; // Stone

/// Deserializable struct representing a block
/// data report from Vanilla.
#[derive(Clone, Debug, Deserialize, Deref, DerefMut)]
struct BlockReport {
    #[serde(flatten)]
    blocks: HashMap<String, Block>,
}

/// A block entry in the data report.
#[derive(Clone, Debug, Deserialize)]
struct Block {
    states: Vec<State>,
    properties: Option<BlockProperties>,
}

/// List of block properties.
#[derive(Clone, Debug, Deserialize, Deref, DerefMut)]
struct BlockProperties {
    #[serde(flatten)]
    props: HashMap<String, Vec<String>>,
}

/// A block state from the data report.
#[derive(Clone, Debug, Deserialize)]
struct State {
    id: u16,
    properties: Option<StateProperties>,
}

/// Properties of a block state from the data report.
#[derive(Clone, Debug, Deserialize, Deref, DerefMut, Default)]
struct StateProperties {
    #[serde(flatten)]
    props: HashMap<String, String>,
}

fn main() {
    simple_logger::init_with_level(log::Level::Info).unwrap();

    if let Err(e) = run() {
        error!("An error occurred: {}", e);
        exit(1);
    }
}

fn run() -> Result<(), Error> {
    let yaml = load_yaml!("cli.yml");
    let matches = App::from_yaml(yaml).get_matches();

    match matches.subcommand_name() {
        Some("mappings") => {
            let args = matches.subcommand_matches("mappings").unwrap();
            generate_mappings_file(
                args.value_of("input").unwrap(),
                args.value_of("output").unwrap(),
                args.value_of("native").unwrap(),
                u32::from_str(args.value_of("proto").unwrap())?,
                args.value_of("ver").unwrap(),
            )?;
        }
        Some("rust") => {
            let args = matches.subcommand_matches("rust").unwrap();
            generate_rust_code(
                args.value_of("input").unwrap(),
                args.value_of("output").unwrap(),
            )?;
        }
        Some(s) => {
            error!("Invalid subcommand {}", s);
            return Ok(());
        }
        None => {
            error!("No subcommand specified");
            return Ok(());
        }
    }

    Ok(())
}

fn generate_rust_code(input: &str, output: &str) -> Result<(), Error> {
    info!(
        "Writing Rust `Block` enum and data structs to {} using native input report {}",
        output, input,
    );

    let in_file = File::open(input)?;
    let mut out_file = File::create(output)?;

    info!("Parsing data file");
    let report: BlockReport = serde_json::from_reader(BufReader::new(&in_file))?;
    info!("Parsing successful");

    let mut enum_entries = vec![];
    //let mut name_fn_entries = vec![];
    //let mut from_name_and_props_fn_entries = vec![];
    let mut data_structs = vec![];
    let mut property_enums = vec![];

    info!("Generating code");

    for (block_name, block) in &report.blocks {
        let variant_name = block_name[10..].to_camel_case();
        let variant_ident = Ident::new(&variant_name, Span::call_site());

        // If block has properties, we need to create a
        // data struct for the block and include it in the
        // enum variant.
        if let Some(props) = block.properties.clone() {
            create_block_data_struct(
                &variant_name,
                &props,
                &mut property_enums,
                &mut data_structs,
            );
            let data_struct_ident = Ident::new(&format!("{}Data", variant_name), Span::call_site());
            enum_entries.push(quote! {
                #variant_ident(#data_struct_ident)
            });
        } else {
            enum_entries.push(quote! {
                #variant_ident
            })
        }
    }

    let known_enums = generate_known_enums();

    let result = quote! {
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
        pub enum Block {
            #(#enum_entries),*
        }

        #(#data_structs)*
        #(#property_enums)*
        #known_enums
    };

    out_file.write(b"//! This file was generated by /generators/blocks\n")?;
    out_file.write(result.to_string().as_bytes())?;
    out_file.flush()?;

    info!("Successfully wrote code to {}", output);

    Ok(())
}

fn create_block_data_struct(
    variant_name: &str,
    props: &BlockProperties,
    property_enums: &mut Vec<TokenStream>,
    data_structs: &mut Vec<TokenStream>,
) {
    let mut data_struct_entries = vec![];

    for (prop_name, possible_values) in &props.props {
        let ty = PropValueType::guess_from_value(&possible_values[0]);

        // If type is a custom enum, create the enum type
        if ty == PropValueType::Enum {
            let enum_ident = Ident::new(
                &format!("{}{}", variant_name, prop_name.to_camel_case()),
                Span::call_site(),
            );

            let mut enum_variants = vec![];
            for possible_value in possible_values {
                let possible_value =
                    Ident::new(possible_value.to_camel_case().as_str(), Span::call_site());
                enum_variants.push(quote! {
                      #possible_value
                });
            }

            let en = quote! {
                #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
                pub enum #enum_ident {
                    #(#enum_variants),*
                }
            };

            property_enums.push(en);
        }

        let enum_name = format!("{}{}", variant_name, prop_name.to_camel_case());

        let ty_ident = Ident::new(
            match ty {
                PropValueType::Bool => "bool",
                PropValueType::I32 => "i32",
                PropValueType::Part => "Part",
                PropValueType::Hinge => "Hinge",
                PropValueType::Shape => "Shape",
                PropValueType::Half => "Half",
                PropValueType::Axis => "Axis",
                PropValueType::Face => "Face",
                PropValueType::Facing => "Facing",
                PropValueType::Enum => &enum_name,
            },
            Span::call_site(),
        );

        let prop_name = Ident::new(correct_variable_name(prop_name.as_str()), Span::call_site());

        let entry = quote! {
            #prop_name: #ty_ident
        };
        data_struct_entries.push(entry);
    }

    let data_ident = Ident::new(&format!("{}Data", variant_name), Span::call_site());

    let data_struct = quote! {
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
        pub struct #data_ident {
            #(#data_struct_entries),*
        }
    };
    data_structs.push(data_struct);
}

fn correct_variable_name(name: &str) -> &str {
    match name {
        "type" => "ty",
        "in" => "_in",
        name => name,
    }
}

fn generate_known_enums() -> TokenStream {
    quote! {
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
        pub enum Facing {
            North,
            South,
            East,
            West,
            Up,
            Down,
        }

        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
        pub enum Axis {
            X,
            Y,
            Z,
        }

        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
        pub enum Half {
            Upper,
            Lower,
            Top,
            Bottom,
        }

        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
        pub enum Face {
            Floor,
            Wall,
            Ceiling,
        }

        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
        pub enum Shape {
            Straight,
            InnerLeft,
            InnerRight,
            OuterLeft,
            AscendingNorth,
            AscendingSouth,
            AscendingEast,
            AscendingWest,
            NorthEast,
            NorthWest,
            SouthEast,
            SouthWest,
            NorthSouth,
            EastWest,
        }

        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
        pub enum Hinge {
            Left,
            Right,
        }

        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
        pub enum Part {
            Head,
            Foot,
        }
    }
}

const FACING_VALUES: [&'static str; 6] = ["north", "south", "east", "west", "up", "down"];

const AXIS_VALUES: [&'static str; 3] = ["x", "y", "z"];

const HALF_VALUES: [&'static str; 4] = ["upper", "lower", "top", "bottom"];

const FACE_VALUES: [&'static str; 3] = ["floor", "wall", "ceiling"];

const SHAPE_VALUES: [&'static str; 14] = [
    "straight",
    "inner_left",
    "inner_right",
    "outer_left",
    "ascending_north",
    "ascending_south",
    "ascending_east",
    "ascending_west",
    "north_east",
    "north_west",
    "south_east",
    "south_west",
    "north_south",
    "east_west",
];

const HINGE_VALUES: [&'static str; 2] = ["left", "right"];

const PART_VALUES: [&'static str; 2] = ["head", "foot"];

/// A property value type.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
enum PropValueType {
    Facing,
    Axis,
    Half,
    Face,
    Shape,
    Hinge,
    Part,
    Enum,
    I32,
    Bool,
}

impl PropValueType {
    fn guess_from_value(value: &str) -> Self {
        if FACING_VALUES.contains(&value) {
            PropValueType::Facing
        } else if AXIS_VALUES.contains(&value) {
            PropValueType::Axis
        } else if HALF_VALUES.contains(&value) {
            PropValueType::Half
        } else if FACE_VALUES.contains(&value) {
            PropValueType::Face
        } else if SHAPE_VALUES.contains(&value) {
            PropValueType::Shape
        } else if HINGE_VALUES.contains(&value) {
            PropValueType::Hinge
        } else if PART_VALUES.contains(&value) {
            PropValueType::Part
        } else if i32::from_str(value).is_ok() {
            PropValueType::I32
        } else if bool::from_str(value).is_ok() {
            PropValueType::Bool
        } else {
            PropValueType::Enum // Custom enum
        }
    }
}

fn generate_mappings_file(
    input: &str,
    output: &str,
    native_input: &str,
    proto: u32,
    version: &str,
) -> Result<(), Error> {
    info!(
        "Generating mappings file {} using input report {} and native report {}",
        output, input, native_input
    );

    let in_file = File::open(input)?;
    let out_file = File::create(output)?;
    let native_file = File::open(native_input)?;

    info!("Parsing data files");

    let report: BlockReport = serde_json::from_reader(BufReader::new(&in_file))?;
    let native_report: BlockReport = serde_json::from_reader(BufReader::new(&native_file))?;

    info!("Parsing successful");

    let mut out = BufWriter::new(&out_file);

    // Write header to output file
    // See format.md
    out.write_all(b"FEATHER_BLOCK_DATA_FILE")?;
    out.write_string(version)?;
    out.write_u32::<LittleEndian>(proto)?;

    // Go through native block types and attempt
    // to find corresponding state ID in report.
    // If it doesn't exist, just set to `DEFAULT_STATE_ID`.
    let mut state_bufs = vec![];
    for (string_id, block) in &native_report.blocks {
        for state in &block.states {
            let mut state_buf = vec![];

            let props = state.properties.clone().unwrap_or_default();
            let props = props.props;

            // Try to find corresponding state ID, defaulting to `DEFAULT_STATE_ID`
            let state_id = find_state_in_report(&report, string_id.as_str(), &props)
                .unwrap_or(DEFAULT_STATE_ID);

            state_buf.write_u16::<LittleEndian>(state.id)?; // Native ID
            state_buf.write_u16::<LittleEndian>(state_id)?;
            state_bufs.push(state_buf);
        }
    }

    out.write_u32::<LittleEndian>(state_bufs.len() as u32)?;
    for buf in state_bufs {
        out.write_all(&buf)?;
    }

    out.flush()?;

    info!("Mappings file generated successfully");
    Ok(())
}

fn find_state_in_report(
    report: &BlockReport,
    name: &str,
    props: &HashMap<String, String>,
) -> Option<u16> {
    let block = report.blocks.get(name)?;

    let state = block.states.iter().find(|state| match &state.properties {
        None => props.is_empty(),
        Some(state_props) => props == &state_props.props,
    })?;

    Some(state.id)
}

trait WriteExt {
    fn write_string(&mut self, x: &str) -> std::io::Result<()>;
}

impl<W: Write> WriteExt for W {
    fn write_string(&mut self, x: &str) -> std::io::Result<()> {
        self.write_u32::<LittleEndian>(x.len() as u32)?;
        self.write_all(x.as_bytes())?;

        Ok(())
    }
}
